{"meta":{"title":"焦迪的博客","subtitle":"Shape of my heart.","description":null,"author":"焦迪","url":"http://jiaodi.tech"},"pages":[{"title":"","date":"2017-04-20T15:28:33.923Z","updated":"2017-04-20T15:28:33.923Z","comments":true,"path":"google32fe2dbbd68bea92.html","permalink":"http://jiaodi.tech/google32fe2dbbd68bea92.html","excerpt":"","text":"google-site-verification: google32fe2dbbd68bea92.html"},{"title":"焦迪测试文章","date":"2017-03-05T08:58:49.000Z","updated":"2017-03-05T08:59:58.169Z","comments":true,"path":"reserved/焦迪测试文章.html","permalink":"http://jiaodi.tech/reserved/焦迪测试文章.html","excerpt":"","text":"这是一篇测试文章，欢迎关注作者博客[1]: https://nemoj.github.io/"},{"title":"about","date":"2017-03-06T04:03:36.000Z","updated":"2017-03-06T04:03:36.384Z","comments":true,"path":"about/index-1.html","permalink":"http://jiaodi.tech/about/index-1.html","excerpt":"","text":""},{"title":"标签","date":"2017-03-06T03:48:21.000Z","updated":"2017-03-06T04:14:19.082Z","comments":false,"path":"tags/index.html","permalink":"http://jiaodi.tech/tags/index.html","excerpt":"","text":""},{"title":"关于我","date":"2017-03-06T03:54:42.000Z","updated":"2017-09-24T15:26:48.319Z","comments":false,"path":"about/index.html","permalink":"http://jiaodi.tech/about/index.html","excerpt":"","text":"雨下整夜 此刻初晴"},{"title":"Hello World","date":"2017-04-13T15:17:00.152Z","updated":"2017-03-05T08:35:02.085Z","comments":true,"path":"reserved/hello-world.html","permalink":"http://jiaodi.tech/reserved/hello-world.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}],"posts":[{"title":"利用SMT32F767驱动AD7616","slug":"stm32f767-fmc-ad7616","date":"2018-08-11T12:45:50.000Z","updated":"2018-09-12T13:21:08.617Z","comments":true,"path":"2018/08/11/stm32f767-fmc-ad7616/","link":"","permalink":"http://jiaodi.tech/2018/08/11/stm32f767-fmc-ad7616/","excerpt":"&emsp;本文介绍STM32F767 FMC控制AD7616的基本方法。","text":"&emsp;本文介绍STM32F767 FMC控制AD7616的基本方法。 开发环境硬件环境 电脑：Windows 10 Home x64 Apollo STM32F767开发板(ST-LINK V2仿真器) 软件环境 Keil Version 5.24.1 (Pack Installer：Keil.STM32F7xx_DFP.2.9.0.pack) STM32CubeMX Version 4.25.0(Packages Manager：STM32CubeF7) AD7616功能简介主要特性 16通道双核同步采样输入 独立可选的通道采样输入范围：±10V，±5V，±2.5V； 单端5V模拟供电，2.3V至3.6V数字驱动供电； 模拟特性：输入钳位保护、输入阻抗1MΩ； 16位SAR ADC，吞吐量位2*1MSPS，支持过采样，支持序列器； 支持串行并行接口，CRC校验； 设计目标 使用并行接口以获取AD7616最佳性能； 使用序列器模式降低控制复杂度：可以连续读取多个采样值； 实现效果SPI接口 基于SPI驱动完成； 在SPI时钟为27MHz下，单次触发模式下采样率可达380kHz双路；而AD7616允许的SPI最高时钟为50MHz，因此其速率可以进一步提高； 本次需要利用并口调试，故SPI未做深入研究；序列器等功能暂未加入； 并行接口 基于FMC接口驱动完成； 单次触发模式可以达到极限采样速率1MHz双路； 完成序列器功能。 实现方法&emsp;AD7616应用于一个重要项目，该模块属于核心模块，此部分技术内容保密。😄😄😄","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://jiaodi.tech/categories/嵌入式/"}],"tags":[{"name":"STM32F7","slug":"STM32F7","permalink":"http://jiaodi.tech/tags/STM32F7/"},{"name":"FMC","slug":"FMC","permalink":"http://jiaodi.tech/tags/FMC/"},{"name":"AD7616","slug":"AD7616","permalink":"http://jiaodi.tech/tags/AD7616/"}]},{"title":"STM32F767 MPU的基本用法","slug":"stm32f767-mpu","date":"2018-07-27T15:59:00.000Z","updated":"2018-07-28T17:15:13.753Z","comments":true,"path":"2018/07/27/stm32f767-mpu/","link":"","permalink":"http://jiaodi.tech/2018/07/27/stm32f767-mpu/","excerpt":"本文介绍STM32F767 MPU的基本用法。","text":"本文介绍STM32F767 MPU的基本用法。 开发环境硬件环境 电脑：Windows 10 Home x64 Apollo STM32F767开发板(ST-LINK V2仿真器) 软件环境 Keil Version 5.24.1 (Pack Installer：Keil.STM32F7xx_DFP.2.9.0.pack) STM32CubeMX Version 4.25.0(Packages Manager：STM32CubeF7) MPU功能简介主要特性&emsp;MPU(Memory Protection Unit)即为内存保护单元，其主要作用是实施存储器的保护，它能够在系统或程序出现异常而非正常地访问不应该访问的存储空间时，通过触发异常中断而达到提高系统可靠性的目的。 &emsp;其主要功能有： 将存储器映射为不同区域，可以设置每个区域的位置、大小、访问权限； 对于每一个区域，其属性设置包括：IsBufferable、IsCacheable、IsShareable； 对于每一个区域，可以控制区域是否可执行； 寄存器说明MPU对区域的属性与大小配置通过寄存器MPU_RASR实现，改寄存器的说明如下： Bits Name Function [31:29] - Reserved. [28] XN Instruction access disable bit:0：Instruction fetches enabled.1 Instruction fetches disabled. [27] - Reserved. [26:24] AP 见表1 [23:22] - Reserved. [21:19, 17, 16] TEX, C, B 见表2 [18] S 见表2 [15:8] SRD Subregion disable bits. For each bit in this field:0:Corresponding sub-region is enabled.1:Corresponding sub-region is disabled [7:6] - Reserved [5:1] SIZE $RegionSize(bytes) = 2^{SIZE+1}$ [0] ENABLE Region enable bit MPU_RASR中用来设置数据访问许可的AP字段详细设置选项如下： AP[2 :0] AP[2 :0] 用户模式 描述 000 不可访问 不可访问 所有的访问产生一个内存管理异常 001 RW 不可访问 仅可从特权模式访问 010 RW RO 在用户模式下的写访问会产生内存管理异常 011 RW RW 完全访问 100 不可预知 不可预知 保留 101 RO 不可访问 仅可在特权模式下进行读访问 110 RO RO 特权和用户模式只读 111 RO RO 特权和用户模式只读 对于TEX, C, B, S位的设置，常用模式下TEX取1，此时配置方法为如下： 基于MPU对SDRAM数据区进行保护MPU的设置MPU的设置代码如下所示： 12345678910111213141516171819202122232425262728293031323334353637/** * @brief Configures the main MPU regions. * @param None * @retval None */void MPU_Config(void)&#123; MPU_Region_InitTypeDef MPU_InitStruct; /* Disable MPU */ HAL_MPU_Disable(); /* SDRAM配置 */ MPU_InitStruct.Enable = MPU_REGION_ENABLE; MPU_InitStruct.Number = MPU_REGION_NUMBER0; MPU_InitStruct.BaseAddress = SDRAM_BASE_ADDRESS; MPU_InitStruct.Size = MPU_REGION_SIZE_32MB; MPU_InitStruct.SubRegionDisable = 0x00; MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0; MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS; MPU_InitStruct.IsBufferable = MPU_ACCESS_BUFFERABLE; MPU_InitStruct.IsCacheable = MPU_ACCESS_CACHEABLE; MPU_InitStruct.IsShareable = MPU_ACCESS_NOT_SHAREABLE; MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE; HAL_MPU_ConfigRegion(&amp;MPU_InitStruct); /* Enable MPU (any access not covered by any enabled region will cause a fault) */ HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);&#125; 其设置功能主要有： 使能对SDRAM区域的保护； 设置区域编号为0； 设置SDRAM数据区的地址与大小； 关闭子区域功能； TEX拓展字段设置为0； 访问权限为完全访问； 设置该区域为BUFFERABLE、CACHEABLE、不可共享； 设置该区域禁止执行代码。 MPU设置对SDRAM读写速率的影响","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://jiaodi.tech/categories/嵌入式/"}],"tags":[{"name":"STM32F7","slug":"STM32F7","permalink":"http://jiaodi.tech/tags/STM32F7/"},{"name":"MPU","slug":"MPU","permalink":"http://jiaodi.tech/tags/MPU/"}]},{"title":"STM32F767 FMC-SDRAM的基本用法","slug":"stm32f767-sdram","date":"2018-07-16T14:10:41.000Z","updated":"2018-07-27T15:46:41.006Z","comments":true,"path":"2018/07/16/stm32f767-sdram/","link":"","permalink":"http://jiaodi.tech/2018/07/16/stm32f767-sdram/","excerpt":"&emsp;本文介绍STM32F767 FMC-SDRAM的基本用法。","text":"&emsp;本文介绍STM32F767 FMC-SDRAM的基本用法。 开发环境硬件环境 电脑：Windows 10 Home x64 Apollo STM32F767开发板(ST-LINK V2仿真器) 软件环境 Keil Version 5.24.1 (Pack Installer：Keil.STM32F7xx_DFP.2.9.0.pack) STM32CubeMX Version 4.25.0(Packages Manager：STM32CubeF7) FMC功能简介主要特性&emsp;本例使用FMC的SDRAM控制器，其主要特性如下： 两个 SDRAM 存储区域，可独立配置 8 位、16 位和 32 位数据总线宽度 13 位地址行，11 位地址列，4 个内部存储区域：4x16Mx32bit (256 MB)、4x16Mx16bit(128 MB)、4x16Mx8bit (64 MB) 支持字、半字和字节访问 SDRAM 时钟可以是 HCLK/2 或 HCLK/3 自动进行行和存储区域边界管理 多存储区域乒乓访问 可编程时序参数 支持自动刷新操作，可编程刷新速率 自刷新模式 掉电模式 通过软件进行 SDRAM 上电初始化 CAS 延迟 1,2,3 读 FIFO 可缓存，支持 6 行 x 32 位深度（6 x14 位地址标记） SDRAM外部存储器接口信号 SDRAM初始化流程&emsp;该部分直接以软件形式介绍。 SDRAM的使用SDRAM初始化函数&emsp;SDRAM的初始化函数如下所示。 12345678910111213141516171819202122232425262728293031323334353637/* FMC initialization function */void MX_FMC_Init(void)&#123; FMC_SDRAM_TimingTypeDef SdramTiming; FMC_SDRAM_CommandTypeDef Command; /** Perform the SDRAM1 memory initialization sequence */ hsdram1.Instance = FMC_SDRAM_DEVICE; /* hsdram1.Init */ hsdram1.Init.SDBank = FMC_SDRAM_BANK1; hsdram1.Init.ColumnBitsNumber = FMC_SDRAM_COLUMN_BITS_NUM_9; hsdram1.Init.RowBitsNumber = FMC_SDRAM_ROW_BITS_NUM_13; hsdram1.Init.MemoryDataWidth = FMC_SDRAM_MEM_BUS_WIDTH_16; hsdram1.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4; hsdram1.Init.CASLatency = FMC_SDRAM_CAS_LATENCY_2; hsdram1.Init.WriteProtection = FMC_SDRAM_WRITE_PROTECTION_DISABLE; hsdram1.Init.SDClockPeriod = FMC_SDRAM_CLOCK_PERIOD_2; hsdram1.Init.ReadBurst = FMC_SDRAM_RBURST_ENABLE; hsdram1.Init.ReadPipeDelay = FMC_SDRAM_RPIPE_DELAY_0; /* SdramTiming */ SdramTiming.LoadToActiveDelay = 2; SdramTiming.ExitSelfRefreshDelay = 8; SdramTiming.SelfRefreshTime = 7; SdramTiming.RowCycleDelay = 7; SdramTiming.WriteRecoveryTime = 2; SdramTiming.RPDelay = 2; SdramTiming.RCDDelay = 2; if (HAL_SDRAM_Init(&amp;hsdram1, &amp;SdramTiming) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; SDRAM_Initialization_Sequence(&amp;hsdram1, &amp;Command);//发送SDRAM初始化序列&#125; &emsp;其中，使用hsdram1.Init设置SDRAM的基本参数，使用SdramTiming设置的为SDRAM的时序参数，SDRAM_Initialization_Sequence()函数为SDRAM的初始化序列。以下将针对每个模块进行介绍。 SDRAM的基本参数&emsp;本例中使用的SDRAM为W9825G66KH-6，其基本参数如下： 4M x 4Banks x 16Bits = 32MByte 最高速率166MHz@CL3 CAS Latency：2和3 8K Refresh Cycles/64ms 行(Row)地址A0-A12，列(Column)地址A0-A8 &emsp;涉及SDRAM基本参数的初始化函数如下表所示。 参数 说明 可选值 本例取值 SDBank SDRAM存储器区域 FMC_SDRAM_BANK1/2 FMC_SDRAM_BANK1 ColumnBitsNumber 列地址位数 FMC_SDRAM_COLUMN_BITS_NUM_8/9/10/11 FMC_SDRAM_COLUMN_BITS_NUM_9 RowBitsNumber 行地址位数 FMC_SDRAM_ROW_BITS_NUM_11/12/13 FMC_SDRAM_ROW_BITS_NUM_13 MemoryDataWidth 数据线位数 FMC_SDRAM_MEM_BUS_WIDTH_8/16/32 FMC_SDRAM_MEM_BUS_WIDTH_16 InternalBankNumber bank数目 FMC_SDRAM_INTERN_BANKS_NUM_2/4 FMC_SDRAM_INTERN_BANKS_NUM_4 CASLatency CAS延迟 FMC_SDRAM_CAS_LATENCY_1/2/3 FMC_SDRAM_CAS_LATENCY_3 WriteProtection 写保护控制 FMC_SDRAM_WRITE_PROTECTION_DISABLE/ENABLE FMC_SDRAM_WRITE_PROTECTION_DISABLE SDClockPeriod SDRAM时钟周期 FMC_SDRAM_CLOCK_DISABLE/PERIOD_2/PERIOD_3 FMC_SDRAM_CLOCK_PERIOD_2 ReadBurst Read_Burst控制 FMC_SDRAM_RBURST_DISABLE/ENABLE FMC_SDRAM_RBURST_ENABLE ReadPipeDelay Read_Pipe_Delay控制 FMC_SDRAM_RPIPE_DELAY_0/1/2 FMC_SDRAM_RPIPE_DELAY_1 SDBank对应SDRAM存储器区域，STM32F7可以外接2片SDRAM，本例仅在区域1接SDRAM； 列地址、行地址、数据线位数、bank位数根据SDRAM相应参数选择； CAS延迟：本例中SDRAM的时钟频率为108MHz，CAS延迟可以设置为2； WriteProtection：禁用写保护以提高写入效率； SDClockPeriod：设置SDCLK相对于HCLK的分频数，本例中HCLK等于系统时钟频率，为216MHz，SDCLK为HCLK二分频得到； ReadBurst：定义在 CAS 延迟后延后多少个 HCLK 时钟周期读取数据，本例延时为0； SDRAM的时序参数&emsp;SdramTiming结构体中定义SDRAM的时序参数，其计算方法如下。注意所有的时间均按照SDRAM时钟周期计算。 &emsp;本例使用的SDRAM型号为：W9825G6KH-6，其时序参数也记录在表中。 参数 定义 W9825G6KH-6要求 最终取值 LoadToActiveDelay 加载模式寄存器到激活：加载模式寄存器命令和激活或刷新命令之间的延迟 $t{RSC}=2 \\cdot t{CK}$ 2 ExitSelfRefreshDelay 退出自刷新延迟：自刷新命令到发出激活命令之间的延迟 $t_{XSR}=72ns$ 7.7≈8 SelfRefreshTime 自刷新时间：最短的自刷新周期 $t_{RC}=60ns$ 6.5≈7 RowCycleDelay 行循环延迟：刷新命令和激活命令之间的延迟，以及两个相邻刷新命令之间的延迟 $t_{RC}=60ns$ 6.5≈7 WriteRecoveryTime 恢复延迟：写命令和预充电命令之间的延迟 $t{WR}=2 \\cdot t{CK}$ 2 RPDelay 行预充电延迟：预充电命令与其它命令之间的延迟 $t_{RP}=60ns$ 6.5≈7 RCDDelay 行到列延迟：激活命令与读/写命令之间的延迟 $t_{RCD}=60ns$ 6.5≈7 SDRAM的初始化序列&emsp;SDRAM的初始化序列如下所示。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * @brief Perform the SDRAM exernal memory inialization sequence * @param hsdram: SDRAM handle * @param Command: Pointer to SDRAM command structure * @retval None */void SDRAM_Initialization_Sequence(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command)&#123; vuint32 tmpmrd = 0; /* Step 1: Configure a clock configuration enable command */ Command-&gt;CommandMode = FMC_SDRAM_CMD_CLK_ENABLE; Command-&gt;CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1; Command-&gt;AutoRefreshNumber = 1; Command-&gt;ModeRegisterDefinition = 0; /* Send the command */ HAL_SDRAM_SendCommand(hsdram, Command, 0x1000); /* Step 2: Insert 100 us minimum delay */ SYS_Delay_US(500); /* Step 3: Configure a PALL (precharge all) command */ Command-&gt;CommandMode = FMC_SDRAM_CMD_PALL; Command-&gt;CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1; Command-&gt;AutoRefreshNumber = 1; Command-&gt;ModeRegisterDefinition = 0; /* Send the command */ HAL_SDRAM_SendCommand(hsdram, Command, 0x1000); /* Step 4 : Configure a Auto-Refresh command */ Command-&gt;CommandMode = FMC_SDRAM_CMD_AUTOREFRESH_MODE; Command-&gt;CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1; Command-&gt;AutoRefreshNumber = 8; Command-&gt;ModeRegisterDefinition = 0; /* Send the command */ HAL_SDRAM_SendCommand(hsdram, Command, 0x1000); /* Step 5: Program the external memory mode register */ tmpmrd=(uint32)SDRAM_MODEREG_BURST_LENGTH_1 | SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL | SDRAM_MODEREG_CAS_LATENCY_2 | SDRAM_MODEREG_OPERATING_MODE_STANDARD | SDRAM_MODEREG_WRITEBURST_MODE_SINGLE; printf(\"tmpmrd is: %x\\n\", tmpmrd); Command-&gt;CommandMode = FMC_SDRAM_CMD_LOAD_MODE; Command-&gt;CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1; Command-&gt;AutoRefreshNumber = 1; Command-&gt;ModeRegisterDefinition = tmpmrd; /* Send the command */ HAL_SDRAM_SendCommand(hsdram, Command, 0x1000); /* Step 6: Set the refresh rate counter */ HAL_SDRAM_ProgramRefreshRate(&amp;hsdram1,824); &#125; step 1：使能SDRAM时钟； step 2：上电后，在precharge all banks前延时500us，本例中W9825G6KH-6要求最低200us； step 3：precharge all banks； step 4：设置自刷新cycle数，本例中要求至少8个Auto Refresh cycles(CBR); step 5：设置SDRAM模式寄存器，在本例中，设置burst长度为1(STM32F767要求burst length为1，数据手册中原文说明为：the Burst Length (BL) of 1 must be selected by configuring the M[2:0] bits to 000 in the mode register)、burst类型为Sequential、CAS_LATENCY为2(与FMC中SDRAM控制器设置相对应)、运行模式为标准、Write Burst模式为Single Location Access； step 6：设置FMC_SDRTR 寄存器中的刷新速率，计算方法为COUNT = (SDRAM refresh period ⁄ Number of rows) – 20，本例为824； 至此，SDRAM配置完毕。 SDRAM的读写实现&emsp;SDRAM的读写非常简单，其被处理器映射为一段起始地址为0XC0000000的存储区域，其读写实现如下所示。 123456789101112131415161718192021222324252627#define Bank5_SDRAM_ADDR ((uint32)(0XC0000000)) /* SDRAM开始地址 */void FMC_SDRAM_WriteBuffer16b(uint16 *pSrcBuffer,uint32 WriteAddr,uint32 BufferSize)&#123; __IO uint16_t *pSdramAddress = (uint16_t *)(Bank5_SDRAM_ADDR + WriteAddr); /* Write data to memory */ for(; BufferSize != 0; BufferSize--) &#123; *(__IO uint16_t *)pSdramAddress = *pSrcBuffer; pSrcBuffer++; pSdramAddress++; &#125;&#125;void FMC_SDRAM_ReadBuffer16b(uint16 *pDstBuffer,uint32 pAddress,uint32 BufferSize)&#123; __IO uint16_t *pSdramAddress = (uint16_t *)(Bank5_SDRAM_ADDR + pAddress); /* Read data from source */ for(; BufferSize != 0; BufferSize--) &#123; *pDstBuffer = *(__IO uint16_t *)pSdramAddress; pDstBuffer++; pSdramAddress++; &#125;&#125; SDRAM的读写测试&emsp;对SDRAM进行读写测试，测试代码如下。 123456#define BUFFER_SIZE (64*1024)uint32 test_addr = 0x00000000;uint32 test_index = 0;uint16 test_writeBuff[BUFFER_SIZE];uint16 test_readBuff[BUFFER_SIZE];uint16 testErrorNum = 0; 123456789101112131415161718192021222324252627282930printf(\"----SDRAM write and read test----\\n\");for (test_index = 0; test_index &lt; BUFFER_SIZE; test_index++)&#123; test_writeBuff[test_index] = test_index % UINT16_MAX;&#125;printf(\"SDRAM write start...\\n\");HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);FMC_SDRAM_WriteBuffer16b(test_writeBuff,test_addr,BUFFER_SIZE);HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);printf(\"SDRAM write finished\\n\\n\"); printf(\"SDRAM read start...\\n\");HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);FMC_SDRAM_ReadBuffer16b(test_readBuff,test_addr,BUFFER_SIZE);HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);printf(\"SDRAM read finished\\n\\n\");HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);for (test_index = 0; test_index &lt; BUFFER_SIZE; test_index++)&#123; if (test_readBuff[test_index] != test_writeBuff[test_index]) &#123; //printf(\"readBuff is NOT equal with writeBuff at: %d\\n\", test_index); testErrorNum++; &#125;&#125;printf(\"Total test number is: %d, error number is: %d\\n\", test_index, testErrorNum); &emsp;测试结果表示读写无误。","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://jiaodi.tech/categories/嵌入式/"}],"tags":[{"name":"STM32F7","slug":"STM32F7","permalink":"http://jiaodi.tech/tags/STM32F7/"},{"name":"FMC","slug":"FMC","permalink":"http://jiaodi.tech/tags/FMC/"},{"name":"SDRAM","slug":"SDRAM","permalink":"http://jiaodi.tech/tags/SDRAM/"}]},{"title":"STM32F767 QUADSPI的基本用法","slug":"stm32f767-qspi","date":"2018-06-30T03:26:08.000Z","updated":"2018-07-16T14:13:21.944Z","comments":true,"path":"2018/06/30/stm32f767-qspi/","link":"","permalink":"http://jiaodi.tech/2018/06/30/stm32f767-qspi/","excerpt":"本文介绍STM32F767 QUADSPI的基本用法。","text":"本文介绍STM32F767 QUADSPI的基本用法。 开发环境硬件环境 电脑：Windows 10 Home x64 Apollo STM32F767开发板(ST-LINK V2仿真器) 软件环境 Keil Version 5.24.1 (Pack Installer：Keil.STM32F7xx_DFP.2.9.0.pack) STM32CubeMX Version 4.25.0(Packages Manager：STM32CubeF7) QUADSPI功能简介主要特性 三种功能模式：间接模式、状态轮询模式和内存映射模式 双闪存模式，通过并行访问两个 Flash，可同时发送/接收 8 位数据 支持 SDR 和 DDR 模式 针对间接模式和内存映射模式，完全可编程操作码 针对间接模式和内存映射模式，完全可编程帧格式 集成 FIFO，用于发送和接收 允许 8、16 和 32 位数据访问 具有适用于间接模式操作的 DMA 通道 在达到 FIFO 阈值、超时、操作完成以及发生访问错误时产生中断 QUADSPI 命令序列&emsp;QUADSPI 通过命令与 Flash 通信每条命令包括指令、地址、交替字节、空指令和数据这五个阶段 任一阶段均可跳过，但至少要包含指令、地址、交替字节或数据阶段之一。nCS 在每条指令开始前下降，在每条指令完成后再次上升。 指令阶段&emsp;这一阶段，将在 QUADSPI_CCR[7:0] 寄存器的 INSTRUCTION 字段中配置的一条 8 位指令发送到 Flash，指定待执行操作的类型。&emsp;尽管大多数 Flash 从 IO0/SO 信号(单线 SPI 模式)只能以一次 1 位的方式接收指令，但指令阶段可选择一次发送 2 位(在双线 SPI 模式中通过 IO0/IO1)或一次发送 4 位(在四线SPI 模式中通过 IO0/IO1/IO2/IO3)。这可通过 QUADSPI_CCR[9:8] 寄存器中的 IMODE[1:0]字段进行配置。&emsp;若 IMODE = 00，则跳过指令阶段，命令序列从地址阶段(如果存在)开始。 地址阶段&emsp;在地址阶段，将 1-4 字节发送到 Flash，指示操作地址。待发送的地址字节数在QUADSPI_CCR[13:12] 寄存器的 ADSIZE[1:0] 字段中进行配置。在间接模式和自动轮询模式下，待发送的地址字节在 QUADSPI_AR 寄存器的 ADDRESS[31:0] 中指定。在内存映射模式下，则通过 AHB(来自于 Cortex® 或 DMA)直接给出地址。&emsp;地址阶段可一次发送 1 位(在单线 SPI 模式中通过 SO)、2 位(在双线 SPI 模式中通过 IO0/IO1)或 4 位(在四线 SPI 模式中通过 IO0/IO1/IO2/IO3)。这可通过QUADSPI_CCR[11:10] 寄存器中的 ADMODE[1:0] 字段进行配置。&emsp;若 ADMODE = 00，则跳过地址阶段，命令序列直接进入下一阶段(如果存在)。 交替字节阶段&emsp;在交替字节阶段，将 1-4 字节发送到 Flash，一般用于控制操作模式。待发送的交替字节数在 QUADSPI_CCR[17:16] 寄存器的 ABSIZE[1:0] 字段中进行配置。待发送的字节在QUADSPI_ABR 寄存器中指定。交替字节阶段可一次发送 1 位(在单线 SPI 模式中通过 SO)、2 位(在双线 SPI 模式中通过 IO0/IO1)或 4 位(在四线 SPI 模式中通过 IO0/IO1/IO2/IO3)。这可通过QUADSPI_CCR[15:14] 寄存器中的 ABMODE[1:0] 字段进行配置。&emsp;若 ABMODE = 00，则跳过交替字节阶段，命令序列直接进入下一阶段(如果存在)。 空指令周期阶段&emsp;在空指令周期阶段，给定的 1-31 个周期内不发送或接收任何数据，目的是当采用更高的时钟频率时，给 Flash 留出准备数据阶段的时间。这一阶段中给定的周期数在QUADSPI_CCR[22:18] 寄存器的 DCYC[4:0] 字段中指定。在 SDR 和 DDR 模式下，持续时间被指定为一定个数的全时钟周期。&emsp;若 DCYC 为零，则跳过空指令周期阶段，命令序列直接进入数据阶段(如果存在)。&emsp;空指令周期阶段的操作模式由 DMODE 确定。&emsp;为确保数据信号从输出模式转变为输入模式有足够的“周转”时间，使用双线和四线模式从Flash 接收数据时，至少需要指定一个空指令周期。 数据阶段&emsp;在数据阶段，可从 Flash 接收或向其发送任意数量的字节。&emsp;在间接模式和自动轮询模式下，待发送/接收的字节数在 QUADSPI_DLR 寄存器中指定。&emsp;在间接写入模式下，发送到 Flash 的数据必须写入 QUADSPI_DR 寄存器。在间接读取模式下，通过读取 QUADSPI_DR 寄存器获得从 Flash 接收的数据。&emsp;在内存映射模式下，读取的数据通过 AHB 直接发送回 Cortex 或 DMA。&emsp;数据阶段可一次发送/ 接收 1 位(在单线 SPI 模式中通过 SO)、2 位(在双线 SPI 模式中通过 IO0/IO1)或 4 位(在四线 SPI 模式中通过 IO0/IO1/IO2/IO3)。这可通过QUADSPI_CCR[15:14] 寄存器中的 ABMODE[1:0] 字段进行配置。&emsp;若 DMODE = 00，则跳过数据阶段，命令序列在拉高 nCS 时立即完成。这一配置仅可用于仅间接写入模式。 QUADSPI Flash 配置&emsp;设备配置寄存器 (QUADSPI_DCR) 可用于指定外部 SPI Flash 的特性。&emsp;FSIZE[4:0] 字段使用下面的公式定义外部存储器的大小：$$Flash 中的字节数 = 2^{FSIZE+1}$$&emsp;FSIZE+1 是对 Flash 寻址所需的地址位数。在间接模式下，Flash 容量最高可达 4GB(使用32 位进行寻址)，但在内存映射模式下的可寻址空间限制为 256MB。&emsp;如果 DFM = 1，FSIZE 表示两个 Flash 容量的总和。&emsp;QUADSPI 连续执行两条命令时，它在两条命令之间将片选信号 (nCS) 置为高电平默认仅一个 CLK 周期时长。如果 Flash 需要命令之间的时间更长，可使用片选高电平时间 (CSHT) 字段指定 nCS 必须保持高电平的最少 CLK 周期数(最大为 8)。&emsp;时钟模式 (CKMODE) 位指示命令之间的 CLK 信号逻辑电平(nCS = 1 时)。 QUADSPI 延迟数据采样&emsp;默认情况下，QUADSPI 在 Flash 驱动信号后过半个 CLK 周期才对 Flash 驱动的数据采样。&emsp;在外部信号延迟时，这有利于推迟数据采样。使用 SSHIFT 位 (QUADSPI_CR[4])，可将数据采样移位半个 CLK 周期。&emsp;DDR 模式下不支持时钟移位：若 DDRM 位置 1，SSHIFT 位必须清零。 使用QSPI读写W25Q256FV&emsp;W25Q256为32MB串行flash存储，支持dual/quad与QPI模式。本例中将使用QSPI接口对W25Q256进行读写。 QSPI的初始化&emsp;QSPI的初始化函数如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103QSPI_HandleTypeDef hqspi;/* QUADSPI init function */void MX_QUADSPI_Init(void)&#123; hqspi.Instance = QUADSPI; hqspi.Init.ClockPrescaler = 2; hqspi.Init.FifoThreshold = 4; hqspi.Init.SampleShifting = QSPI_SAMPLE_SHIFTING_HALFCYCLE; hqspi.Init.FlashSize = QSPI_FLASH_SIZE - 1; hqspi.Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_4_CYCLE; hqspi.Init.ClockMode = QSPI_CLOCK_MODE_0; hqspi.Init.FlashID = QSPI_FLASH_ID_1; hqspi.Init.DualFlash = QSPI_DUALFLASH_DISABLE; if (HAL_QSPI_Init(&amp;hqspi) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125;&#125;void HAL_QSPI_MspInit(QSPI_HandleTypeDef* qspiHandle)&#123; GPIO_InitTypeDef GPIO_InitStruct; if(qspiHandle-&gt;Instance==QUADSPI) &#123; /* USER CODE BEGIN QUADSPI_MspInit 0 */ /* USER CODE END QUADSPI_MspInit 0 */ /* QUADSPI clock enable */ __HAL_RCC_QSPI_CLK_ENABLE(); /**QUADSPI GPIO Configuration PF6 ------&gt; QUADSPI_BK1_IO3 PF7 ------&gt; QUADSPI_BK1_IO2 PF8 ------&gt; QUADSPI_BK1_IO0 PF9 ------&gt; QUADSPI_BK1_IO1 PB2 ------&gt; QUADSPI_CLK PB6 ------&gt; QUADSPI_BK1_NCS */ GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_HIGH; GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI; HAL_GPIO_Init(GPIOF, &amp;GPIO_InitStruct); GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_HIGH; GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI; HAL_GPIO_Init(GPIOF, &amp;GPIO_InitStruct); GPIO_InitStruct.Pin = GPIO_PIN_2; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_HIGH; GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI; HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct); GPIO_InitStruct.Pin = GPIO_PIN_6; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_PULLUP; GPIO_InitStruct.Speed = GPIO_SPEED_HIGH; GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI; HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct); /* USER CODE BEGIN QUADSPI_MspInit 1 */ /* USER CODE END QUADSPI_MspInit 1 */ &#125;&#125;void HAL_QSPI_MspDeInit(QSPI_HandleTypeDef* qspiHandle)&#123; if(qspiHandle-&gt;Instance==QUADSPI) &#123; /* USER CODE BEGIN QUADSPI_MspDeInit 0 */ /* USER CODE END QUADSPI_MspDeInit 0 */ /* Peripheral clock disable */ __HAL_RCC_QSPI_CLK_DISABLE(); /**QUADSPI GPIO Configuration PF6 ------&gt; QUADSPI_BK1_IO3 PF7 ------&gt; QUADSPI_BK1_IO2 PF8 ------&gt; QUADSPI_BK1_IO0 PF9 ------&gt; QUADSPI_BK1_IO1 PB2 ------&gt; QUADSPI_CLK PB6 ------&gt; QUADSPI_BK1_NCS */ HAL_GPIO_DeInit(GPIOF, GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9); HAL_GPIO_DeInit(GPIOB, GPIO_PIN_2|GPIO_PIN_6); /* USER CODE BEGIN QUADSPI_MspDeInit 1 */ /* USER CODE END QUADSPI_MspDeInit 1 */ &#125;&#125; &emsp;其主要功能为： 查询W25Q256FV手册可知，其最大可支持的读写时钟频率为104MHz；QSPI使用AHB1时钟，AHB主时钟的频率为216MHz，设置分频系数为2，则QSPI时钟为72MHz； 设置QSPI的FIFO深度为4byte； 设置移位半个周期进行数据采样，有助于提高数据读取稳定性； 设置flash容量参数为32MB，对应QSPI_FLASH_SIZE为25； 查询W25Q256FV手册可知，CS片选信号的禁止时间至少为50ns；因此设置片选高电平时间为4个时钟周期； 时钟模式为模式0，即片选信号CS释放后，CLK保持低电平；W25Q256FV对此无要求； FlashID选择Flash ID 1； 非双flash模式； 初始化QSPI。 &emsp;初始化函数如下所示。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273HAL_StatusTypeDef HAL_QSPI_Init(QSPI_HandleTypeDef *hqspi)&#123; HAL_StatusTypeDef status = HAL_ERROR; uint32_t tickstart = HAL_GetTick(); /* Check the QSPI handle allocation */ if(hqspi == NULL) &#123; return HAL_ERROR; &#125; /* Check the parameters */ assert_param(IS_QSPI_ALL_INSTANCE(hqspi-&gt;Instance)); assert_param(IS_QSPI_CLOCK_PRESCALER(hqspi-&gt;Init.ClockPrescaler)); assert_param(IS_QSPI_FIFO_THRESHOLD(hqspi-&gt;Init.FifoThreshold)); assert_param(IS_QSPI_SSHIFT(hqspi-&gt;Init.SampleShifting)); assert_param(IS_QSPI_FLASH_SIZE(hqspi-&gt;Init.FlashSize)); assert_param(IS_QSPI_CS_HIGH_TIME(hqspi-&gt;Init.ChipSelectHighTime)); assert_param(IS_QSPI_CLOCK_MODE(hqspi-&gt;Init.ClockMode)); assert_param(IS_QSPI_DUAL_FLASH_MODE(hqspi-&gt;Init.DualFlash)); if (hqspi-&gt;Init.DualFlash != QSPI_DUALFLASH_ENABLE ) &#123; assert_param(IS_QSPI_FLASH_ID(hqspi-&gt;Init.FlashID)); &#125; /* Process locked */ __HAL_LOCK(hqspi); if(hqspi-&gt;State == HAL_QSPI_STATE_RESET) &#123; /* Allocate lock resource and initialize it */ hqspi-&gt;Lock = HAL_UNLOCKED; /* Init the low level hardware : GPIO, CLOCK */ HAL_QSPI_MspInit(hqspi); /* Configure the default timeout for the QSPI memory access */ HAL_QSPI_SetTimeout(hqspi, HAL_QPSI_TIMEOUT_DEFAULT_VALUE); &#125; /* Configure QSPI FIFO Threshold */ MODIFY_REG(hqspi-&gt;Instance-&gt;CR, QUADSPI_CR_FTHRES, ((hqspi-&gt;Init.FifoThreshold - 1) &lt;&lt; 8)); /* Wait till BUSY flag reset */ status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi-&gt;Timeout); if(status == HAL_OK) &#123; /* Configure QSPI Clock Prescaler and Sample Shift */ MODIFY_REG(hqspi-&gt;Instance-&gt;CR,(QUADSPI_CR_PRESCALER | QUADSPI_CR_SSHIFT | QUADSPI_CR_FSEL | QUADSPI_CR_DFM), ((hqspi-&gt;Init.ClockPrescaler &lt;&lt; 24)| hqspi-&gt;Init.SampleShifting | hqspi-&gt;Init.FlashID| hqspi-&gt;Init.DualFlash )); /* Configure QSPI Flash Size, CS High Time and Clock Mode */ MODIFY_REG(hqspi-&gt;Instance-&gt;DCR, (QUADSPI_DCR_FSIZE | QUADSPI_DCR_CSHT | QUADSPI_DCR_CKMODE), ((hqspi-&gt;Init.FlashSize &lt;&lt; 16) | hqspi-&gt;Init.ChipSelectHighTime | hqspi-&gt;Init.ClockMode)); /* Enable the QSPI peripheral */ __HAL_QSPI_ENABLE(hqspi); /* Set QSPI error code to none */ hqspi-&gt;ErrorCode = HAL_QSPI_ERROR_NONE; /* Initialize the QSPI state */ hqspi-&gt;State = HAL_QSPI_STATE_READY; &#125; /* Release Lock */ __HAL_UNLOCK(hqspi); /* Return function status */ return status;&#125; &emsp;其具体配置通过QUADSPI 控制寄存器 (QUADSPI_CR)与QUADSPI 器件配置寄存器 (QUADSPI_CCR)实现，这里不再详细说明。 QSPI的指令与读写实现&emsp;QSPI的指令发送函数如下所示。该函数的输入参数可以完整实现对指令阶段的控制。 12345678910111213141516171819202122232425262728293031323334353637383940/** * 说明： 使用QSPI发送Cmd * 参数： insMode： 指令模式 * ins： 指令值 * addrMode：地址模式 * addr： 地址值 * addrSize： 地址值大小 * alterMode： 复用字节模式 * alter： 复用字节值 * altersize： 复用字节大小 * dummyCycles： 空周期时钟数 * dataMode： 数据模式 * @返回值 无 */QSPI_StatusTypeDef QSPI_SendCmd(uint32_t insMode, uint32 ins, uint32_t addrMode, uint32_t addr, uint32_t addrSize, uint32 alterMode, uint32 alter, uint32 altersize, uint32_t dummyCycles, uint32_t dataMode)&#123; QSPI_CommandTypeDef qspiCmdhandler; qspiCmdhandler.Instruction = ins; qspiCmdhandler.Address = addr; qspiCmdhandler.AlternateBytes = alter; qspiCmdhandler.AddressSize=addrSize; qspiCmdhandler.AlternateBytesSize = altersize; qspiCmdhandler.DummyCycles = dummyCycles; qspiCmdhandler.InstructionMode = insMode; qspiCmdhandler.AddressMode = addrMode; qspiCmdhandler.AlternateByteMode = alterMode; qspiCmdhandler.DataMode=dataMode; qspiCmdhandler.SIOOMode=QSPI_SIOO_INST_EVERY_CMD; qspiCmdhandler.DdrMode=QSPI_DDR_MODE_DISABLE; qspiCmdhandler.DdrHoldHalfCycle=QSPI_DDR_HHC_ANALOG_DELAY; if (HAL_OK == HAL_QSPI_Command(&amp;hqspi,&amp;qspiCmdhandler,HAL_QPSI_TIMEOUT_DEFAULT_VALUE)) return QSPI_OK; else return QSPI_ERROR;&#125; &emsp;QSPI的的读写函数实现如下，均利用了HAL库完成。 1234567891011121314151617QSPI_StatusTypeDef QSPI_Receive(uint8 *buf,uint32 datalen)&#123; hqspi.Instance-&gt;DLR = datalen - 1; if(HAL_OK == HAL_QSPI_Receive(&amp;hqspi,buf,HAL_QPSI_TIMEOUT_DEFAULT_VALUE)) return QSPI_OK; else return QSPI_ERROR;&#125;QSPI_StatusTypeDef QSPI_Transmit(uint8 *buf,uint32 datalen)&#123; hqspi.Instance-&gt;DLR = datalen - 1; if(HAL_OK == HAL_QSPI_Transmit(&amp;hqspi,buf,HAL_QPSI_TIMEOUT_DEFAULT_VALUE)) return QSPI_OK; else return QSPI_ERROR;&#125; W25Q256FV的初始化操作框图&emsp;W25Q256FV的操作框图如下所示。其上电后根据ADP的值决定进入3byte或者4byte地址线模式，单均处于SPI模式下。之后可以控制其进去QPI模式。 &emsp;本例中，将其控制在QPI模式以达到最高性能。 运行模式判断&emsp;运行模式的判断通过以SPI/QPI读取Device ID实现，哪种方法可以得到正确的ID则说明具体为哪种模式；确认模式后，在读取ADP值确认是3byte或者4byte地址线模式。 &emsp;函数实现如下： 123456789101112131415161718192021222324252627282930313233343536373839W25QxxModeTypeDef GetW25QxxMode(void)&#123; uint16 id = 0; uint8 buf; if (QSPI_OK != W25QxxReadDeciveID(&amp;id, SPI_3_Byte)) return UnknownMode; if (Q25Q256FV_ID == id) &#123; if (QSPI_OK != QSPI_SendCmd(QSPI_INSTRUCTION_1_LINE, ReadStatusReg3, QSPI_ADDRESS_NONE, 0, 0, QSPI_ALTERNATE_BYTES_NONE, 0, 0, 0, QSPI_DATA_1_LINE)) return UnknownMode; if (QSPI_OK != QSPI_Receive(&amp;buf,1)) return UnknownMode; if ((buf &amp; ReadStatusReg3_ADS_Msk) != ReadStatusReg3_ADS_Msk) return SPI_3_Byte; else return SPI_4_Byte; &#125; if (QSPI_OK != W25QxxReadDeciveID(&amp;id, QPI_3_Byte)) return UnknownMode; if (Q25Q256FV_ID == id) &#123; if (QSPI_OK != QSPI_SendCmd(QSPI_INSTRUCTION_4_LINES, ReadStatusReg3, QSPI_ADDRESS_NONE, 0, 0, QSPI_ALTERNATE_BYTES_NONE, 0, 0, 0, QSPI_DATA_4_LINES)) return UnknownMode; if (QSPI_OK != QSPI_Receive(&amp;buf,1)) return UnknownMode; if ((buf &amp; ReadStatusReg3_ADS_Msk) != ReadStatusReg3_ADS_Msk) return QPI_3_Byte; else return QPI_4_Byte; &#125; return UnknownMode;&#125; 初始化&emsp;W25Q256FV初始化函数的功能包括： 设置为QPI模式； 设置为4byte地址线模式； 设置SetReadParameters参数，以便获得最高读写速度； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950QSPI_StatusTypeDef W25QxxEnterQspiMode_FourByte(void)&#123; uint8 buf = 0; QSPI_StatusTypeDef res = QSPI_OK; if (QSPI_OK != W25QxxReadReg(ReadStatusReg2, &amp;buf)) return QSPI_ERROR; if ((buf &amp; ReadStatusReg2_QE_Msk) != ReadStatusReg2_QE_Msk) &#123; if (QSPI_OK != W25QxxWriteVolatileEnable()) return QSPI_ERROR; buf |= ReadStatusReg2_QE_Msk; if (QSPI_OK != W25QxxWriteReg(WriteStatusReg2, &amp;buf)) return QSPI_ERROR; if (QSPI_OK != W25QxxWriteDisable()) return QSPI_ERROR; &#125; if ((W25QxxMode == SPI_3_Byte) || (W25QxxMode == SPI_4_Byte)) res = QSPI_SendCmd(QSPI_INSTRUCTION_1_LINE, EnterQPIMode, QSPI_ADDRESS_NONE, 0, 0, QSPI_ALTERNATE_BYTES_NONE, 0, 0, 0, QSPI_DATA_NONE); if (res != QSPI_OK) return QSPI_ERROR; if (QSPI_OK != W25QxxReadReg(ReadStatusReg3, &amp;buf)) return QSPI_ERROR; if ((buf &amp; ReadStatusReg3_ADP_Msk) != ReadStatusReg3_ADP_Msk) &#123; if (QSPI_OK != W25QxxWriteVolatileEnable()) return QSPI_ERROR; buf |= ReadStatusReg3_ADP_Msk; if (QSPI_OK != W25QxxWriteReg(WriteStatusReg3, &amp;buf)) return QSPI_ERROR; if (QSPI_OK != W25QxxWriteDisable()) return QSPI_ERROR; if (QSPI_OK != QSPI_SendCmd(QSPI_INSTRUCTION_4_LINES, Enter4ByteAddrMode, QSPI_ADDRESS_NONE, 0, 0, QSPI_ALTERNATE_BYTES_NONE, 0, 0, 0, QSPI_DATA_NONE)) return QSPI_ERROR; &#125; W25QxxMode = QPI_4_Byte; if (QSPI_OK != QSPI_SendCmd(QSPI_INSTRUCTION_4_LINES, SetReadParameters, QSPI_ADDRESS_NONE, 0, 0, QSPI_ALTERNATE_BYTES_NONE, 0, 0, 0, QSPI_DATA_4_LINES)) return QSPI_ERROR; buf = SetReadParametersVal; if (QSPI_OK != QSPI_Transmit(&amp;buf,1)) return QSPI_ERROR; return QSPI_OK;&#125; 擦除与读写操作&emsp;W25Q256FV初始化完毕后，按照QPI 4byte模式对其进行擦除与读写操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970QSPI_StatusTypeDef W25QxxEraseSector4KB(uint32 addr)&#123; if (QSPI_OK != W25QxxWriteEnable()) return QSPI_ERROR; while (isW25QxxBusy() == TRUE) &#123;printf(\"4KB erase done: %x\\n\", addr);&#125;; if (QSPI_OK != QSPI_SendCmd(QSPI_INSTRUCTION_4_LINES, EraseSector4KB, QSPI_ADDRESS_4_LINES, addr, QSPI_ADDRESS_32_BITS, QSPI_ALTERNATE_BYTES_NONE, 0, 0, 0, QSPI_DATA_NONE)) return QSPI_ERROR; while (isW25QxxBusy() == TRUE) &#123;printf(\"W25QxxEraseSector4KB: %x\\n\", addr);&#125;; return QSPI_OK;&#125;QSPI_StatusTypeDef W25QxxEraseSector64KB(uint32 addr)&#123; if (QSPI_OK != W25QxxWriteEnable()) return QSPI_ERROR; while (isW25QxxBusy() == TRUE) &#123;printf(\"4KB erase done: %x\\n\", addr);&#125;; if (QSPI_OK != QSPI_SendCmd(QSPI_INSTRUCTION_4_LINES, EraseSector64KB, QSPI_ADDRESS_4_LINES, addr, QSPI_ADDRESS_32_BITS, QSPI_ALTERNATE_BYTES_NONE, 0, 0, 0, QSPI_DATA_NONE)) return QSPI_ERROR; while (isW25QxxBusy() == TRUE) &#123;printf(\"W25QxxEraseSector64KB: %x\\n\", addr);&#125;; return QSPI_OK;&#125;QSPI_StatusTypeDef W25QxxEraseChip(void)&#123; if (QSPI_OK != W25QxxWriteEnable()) return QSPI_ERROR; while (isW25QxxBusy() == TRUE) &#123;printf(\"W25QxxEraseChip\\n\");&#125;; if (QSPI_OK != QSPI_SendCmd(QSPI_INSTRUCTION_4_LINES, ChipErase, QSPI_ADDRESS_NONE, 0, 0, QSPI_ALTERNATE_BYTES_NONE, 0, 0, 0, QSPI_DATA_NONE)) return QSPI_ERROR; while (isW25QxxBusy() == TRUE) &#123;printf(\"W25QxxEraseChip\\n\");&#125;; return QSPI_OK;&#125;QSPI_StatusTypeDef W25QxxWritePage32B(uint32 addr, uint8 *writeBuff, uint32 writeBuffLen)&#123; if (QSPI_OK != W25QxxWriteEnable()) return QSPI_ERROR; if (QSPI_OK != QSPI_SendCmd(QSPI_INSTRUCTION_4_LINES, PageProgram32B, QSPI_ADDRESS_4_LINES, addr, QSPI_ADDRESS_32_BITS, QSPI_ALTERNATE_BYTES_NONE, 0, 0, 0, QSPI_DATA_4_LINES)) return QSPI_ERROR; if (QSPI_OK != QSPI_Transmit(writeBuff,writeBuffLen)) return QSPI_ERROR; while (isW25QxxBusy() == TRUE) &#123;printf(\"W25QxxWritePage32B: %x\\n\", addr);&#125;; return QSPI_OK;&#125;QSPI_StatusTypeDef W25QxxRead(uint32 addr, uint8 *readBuff, uint32 readBuffLen)&#123; if (QSPI_OK != QSPI_SendCmd(QSPI_INSTRUCTION_4_LINES, FastRead, QSPI_ADDRESS_4_LINES, addr, QSPI_ADDRESS_32_BITS, QSPI_ALTERNATE_BYTES_NONE, 0, 0, 8, QSPI_DATA_4_LINES)) return QSPI_ERROR; if (QSPI_OK != QSPI_Receive(readBuff, readBuffLen)) return QSPI_ERROR; while (isW25QxxBusy() == TRUE) &#123;printf(\"busy\");&#125;; return QSPI_OK;&#125; 实验验证&emsp;测试函数设置如下： 程序首先擦除了地址test_addr所在的4KB区域； 之后读取擦除后的test_addr所在区域数值并打印； 对test_addr所在区域进行32byte的数值写入； 读取写入区域的数值并打印确定是否正确写入。 123456789101112131415161718192021222324252627uint32 test_addr = 0x00000000;uint32 test_index = 0;uint8 test_writeBuff[256];uint8 test_readBuff[256];printf(\"4KB erase addr is: %x\\n\", test_addr);res = W25QxxEraseSector4KB(test_addr);printf(\"W25QxxEraseSector4KB(test_addr) res is: %x\\n\", res);printf(\"4KB erase done: %x\\n\\n\", test_addr);res = W25QxxRead(test_addr, test_readBuff, 256); printf(\"W25QxxRead res is: %x\\n\", res); for (test_index = 0; test_index &lt; 256; test_index++) printf(\"test_readBuff[test_index] is: %x\\n\", test_readBuff[test_index]); for (test_index = 0; test_index &lt; 256; test_index++) test_writeBuff[test_index] = test_index; res = W25QxxWritePage32B(test_addr, test_writeBuff, 256); printf(\"W25QxxWritePage32B res is: %x\\n\", res); res = W25QxxRead(test_addr, test_readBuff, 256); printf(\"W25QxxRead res is: %x\\n\", res); for (test_index = 0; test_index &lt; 256; test_index++) printf(\"test_readBuff[test_index] is: %x\\n\", test_readBuff[test_index]); &emsp;程序运行结果符合预期。务必注意读写操作所针对的区域必须首先完成擦除操作。","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://jiaodi.tech/categories/嵌入式/"}],"tags":[{"name":"STM32F7","slug":"STM32F7","permalink":"http://jiaodi.tech/tags/STM32F7/"},{"name":"QUADSPI","slug":"QUADSPI","permalink":"http://jiaodi.tech/tags/QUADSPI/"}]},{"title":"STM32F767 Flash的基本用法","slug":"stm32f767-flash","date":"2018-05-27T03:26:08.000Z","updated":"2018-05-28T16:04:36.636Z","comments":true,"path":"2018/05/27/stm32f767-flash/","link":"","permalink":"http://jiaodi.tech/2018/05/27/stm32f767-flash/","excerpt":"&emsp;本文介绍STM32F767 Flash的基本用法。","text":"&emsp;本文介绍STM32F767 Flash的基本用法。 开发环境硬件环境 电脑：Windows 10 Home x64 Apollo STM32F767开发板(ST-LINK V2仿真器) 软件环境 Keil Version 5.24.1 (Pack Installer：Keil.STM32F7xx_DFP.2.9.0.pack) STM32CubeMX Version 4.25.0(Packages Manager：STM32CubeF7) Flash功能介绍Flash构成&emsp;Flash 具有以下主要特性： 容量高达 1 MB； 256 位宽数据读取； 字节、半字、字和双字数据写入； 扇区擦除与全部擦除； &emsp;Flash结构如下： 主存储器块：分为 4 个 32 KB 扇区、1 个 128 KB 扇区和 3 个 256 KB 扇区； 信息块：系统存储器、OTP和选项字节 读访问延时&emsp;该部分内容在系统内核与时钟设置文中已经讲解，这里不再介绍。 Flash控制器解锁&emsp;复位后，Flash 控制寄存器 (FLASH_CR) 不允许执行写操作，以防因电气干扰等原因出现对Flash 的意外操作。此寄存器的解锁顺序如下： 在 Flash 密钥寄存器 (FLASH_KEYR) 中写入 KEY1 = 0x45670123； 在 Flash 密钥寄存器 (FLASH_KEYR) 中写入 KEY2 = 0xCDEF89AB。 编程/擦除并行位数&emsp;通过 FLASH_CR 寄存器中的 PSIZE 域配置并行位数。并行位数表示每次对 Flash 进行写操作时将编程的字节数。PSIZE 受限于电源电压以及是否使用外部 VPP 电源。因此，在进行任何编程/擦除操作前，必须在 FLASH_CR 寄存器中对其进行正确配置。 Flash擦除顺序&emsp;Flash 擦除操作可针对扇区或整个 Flash（批量擦除）执行。执行批量擦除时，不会影响 OTP扇区或配置扇区。 扇区擦除&emsp;扇区擦除的具体步骤如下： 检查 FLASH_SR 寄存器中的 BSY 位，以确认当前未执行任何 Flash 操作； 在 FLASH_CR 寄存器中将 SER 位置 1 并选择需要擦除的扇区 (SNB)，所选扇区应为主存储器块中的 8 个扇区之一； 将 FLASH_CR 寄存器中的 STRT 位置 1； 等待 BSY 位清零。 批量擦除&emsp;要执行批量擦除，建议采用以下步骤： 检查 FLASH_SR 寄存器中的 BSY 位，以确认当前未执行任何 Flash 操作； 将 FLASH_CR 寄存器中的 MER 位置 1； 将 FLASH_CR 寄存器中的 STRT 位置 1； 等待 BSY 位清零。 Flash编程顺序标准编程&emsp;Flash 编程顺序如下： 检查 FLASH_SR 中的 BSY 位，以确认当前未执行任何主要 Flash 操作； 将 FLASH_CR 寄存器中的 PG 位置 1； 针对所需存储器地址（主存储器块或 OTP 区域内）执行数据写入操作：– 并行位数为 x8 时按字节写入– 并行位数为 x16 时按半字写入– 并行位数为 x32 时按字写入– 并行位数为 x64 时按双字写入 等待 BSY 位清零。 HAL库Flash读写操作实现&emsp;Flash擦除的最小单位为扇区，同时写入数据前必须对扇区进行擦除。因此一次Flash的写入过程为：确认写入的扇区、擦除对应扇区、写入数据。 &emsp;Flash的读取相对简单，直接利用指针读取即可。 获取内存地址对应扇区&emsp;STM32F76x最大支持2MB Flash，本例中所用的STM32767 Flash为1MB，即DUAL_BANK未被定义。 Flash扇区的地址对应关系如下所示。 12345678910111213141516171819202122232425262728293031323334353637383940/* Base address of the Flash sectors */#if defined(DUAL_BANK)#define ADDR_FLASH_SECTOR_0 ((uint32_t)0x08000000) /* Base address of Sector 0, 16 Kbytes */#define ADDR_FLASH_SECTOR_1 ((uint32_t)0x08004000) /* Base address of Sector 1, 16 Kbytes */#define ADDR_FLASH_SECTOR_2 ((uint32_t)0x08008000) /* Base address of Sector 2, 16 Kbytes */#define ADDR_FLASH_SECTOR_3 ((uint32_t)0x0800C000) /* Base address of Sector 3, 16 Kbytes */#define ADDR_FLASH_SECTOR_4 ((uint32_t)0x08010000) /* Base address of Sector 4, 64 Kbytes */#define ADDR_FLASH_SECTOR_5 ((uint32_t)0x08020000) /* Base address of Sector 5, 128 Kbytes */#define ADDR_FLASH_SECTOR_6 ((uint32_t)0x08040000) /* Base address of Sector 6, 128 Kbytes */#define ADDR_FLASH_SECTOR_7 ((uint32_t)0x08060000) /* Base address of Sector 7, 128 Kbytes */#define ADDR_FLASH_SECTOR_8 ((uint32_t)0x08080000) /* Base address of Sector 8, 128 Kbytes */#define ADDR_FLASH_SECTOR_9 ((uint32_t)0x080A0000) /* Base address of Sector 9, 128 Kbytes */#define ADDR_FLASH_SECTOR_10 ((uint32_t)0x080C0000) /* Base address of Sector 10, 128 Kbytes */#define ADDR_FLASH_SECTOR_11 ((uint32_t)0x080E0000) /* Base address of Sector 11, 128 Kbytes */#define ADDR_FLASH_SECTOR_12 ((uint32_t)0x08100000) /* Base address of Sector 12, 16 Kbytes */#define ADDR_FLASH_SECTOR_13 ((uint32_t)0x08104000) /* Base address of Sector 13, 16 Kbytes */#define ADDR_FLASH_SECTOR_14 ((uint32_t)0x08108000) /* Base address of Sector 14, 16 Kbytes */#define ADDR_FLASH_SECTOR_15 ((uint32_t)0x0810C000) /* Base address of Sector 15, 16 Kbytes */#define ADDR_FLASH_SECTOR_16 ((uint32_t)0x08110000) /* Base address of Sector 16, 64 Kbytes */#define ADDR_FLASH_SECTOR_17 ((uint32_t)0x08120000) /* Base address of Sector 17, 128 Kbytes */#define ADDR_FLASH_SECTOR_18 ((uint32_t)0x08140000) /* Base address of Sector 18, 128 Kbytes */#define ADDR_FLASH_SECTOR_19 ((uint32_t)0x08160000) /* Base address of Sector 19, 128 Kbytes */#define ADDR_FLASH_SECTOR_20 ((uint32_t)0x08180000) /* Base address of Sector 20, 128 Kbytes */#define ADDR_FLASH_SECTOR_21 ((uint32_t)0x081A0000) /* Base address of Sector 21, 128 Kbytes */#define ADDR_FLASH_SECTOR_22 ((uint32_t)0x081C0000) /* Base address of Sector 22, 128 Kbytes */#define ADDR_FLASH_SECTOR_23 ((uint32_t)0x081E0000) /* Base address of Sector 23, 128 Kbytes */#else#define ADDR_FLASH_SECTOR_0 ((uint32_t)0x08000000) /* Base address of Sector 0, 32 Kbytes */#define ADDR_FLASH_SECTOR_1 ((uint32_t)0x08008000) /* Base address of Sector 1, 32 Kbytes */#define ADDR_FLASH_SECTOR_2 ((uint32_t)0x08010000) /* Base address of Sector 2, 32 Kbytes */#define ADDR_FLASH_SECTOR_3 ((uint32_t)0x08018000) /* Base address of Sector 3, 32 Kbytes */#define ADDR_FLASH_SECTOR_4 ((uint32_t)0x08020000) /* Base address of Sector 4, 128 Kbytes */#define ADDR_FLASH_SECTOR_5 ((uint32_t)0x08040000) /* Base address of Sector 5, 256 Kbytes */#define ADDR_FLASH_SECTOR_6 ((uint32_t)0x08080000) /* Base address of Sector 6, 256 Kbytes */#define ADDR_FLASH_SECTOR_7 ((uint32_t)0x080C0000) /* Base address of Sector 7, 256 Kbytes */#define ADDR_FLASH_SECTOR_8 ((uint32_t)0x08100000) /* Base address of Sector 8, 256 Kbytes */#define ADDR_FLASH_SECTOR_9 ((uint32_t)0x08140000) /* Base address of Sector 9, 256 Kbytes */#define ADDR_FLASH_SECTOR_10 ((uint32_t)0x08180000) /* Base address of Sector 10, 256 Kbytes */#define ADDR_FLASH_SECTOR_11 ((uint32_t)0x081C0000) /* Base address of Sector 11, 256 Kbytes */#endif /* DUAL_BANK */ &emsp;Flash扇区号的定义如下所示。对于STM32F767，其Flash只有7个扇区。 123456789101112131415161718192021222324252627282930313233/** @defgroup FLASH_Sectors FLASH Sectors * @&#123; */#define FLASH_SECTOR_0 ((uint32_t)0U) /*!&lt; Sector Number 0 */#define FLASH_SECTOR_1 ((uint32_t)1U) /*!&lt; Sector Number 1 */#define FLASH_SECTOR_2 ((uint32_t)2U) /*!&lt; Sector Number 2 */#define FLASH_SECTOR_3 ((uint32_t)3U) /*!&lt; Sector Number 3 */#define FLASH_SECTOR_4 ((uint32_t)4U) /*!&lt; Sector Number 4 */#define FLASH_SECTOR_5 ((uint32_t)5U) /*!&lt; Sector Number 5 */#define FLASH_SECTOR_6 ((uint32_t)6U) /*!&lt; Sector Number 6 */#define FLASH_SECTOR_7 ((uint32_t)7U) /*!&lt; Sector Number 7 *//** @defgroup FLASHEx_Sectors FLASH Sectors * @&#123; */#if (FLASH_SECTOR_TOTAL == 24)#define FLASH_SECTOR_8 ((uint32_t)8U) /*!&lt; Sector Number 8 */#define FLASH_SECTOR_9 ((uint32_t)9U) /*!&lt; Sector Number 9 */#define FLASH_SECTOR_10 ((uint32_t)10U) /*!&lt; Sector Number 10 */#define FLASH_SECTOR_11 ((uint32_t)11U) /*!&lt; Sector Number 11 */#define FLASH_SECTOR_12 ((uint32_t)12U) /*!&lt; Sector Number 12 */#define FLASH_SECTOR_13 ((uint32_t)13U) /*!&lt; Sector Number 13 */#define FLASH_SECTOR_14 ((uint32_t)14U) /*!&lt; Sector Number 14 */#define FLASH_SECTOR_15 ((uint32_t)15U) /*!&lt; Sector Number 15 */#define FLASH_SECTOR_16 ((uint32_t)16U) /*!&lt; Sector Number 16 */#define FLASH_SECTOR_17 ((uint32_t)17U) /*!&lt; Sector Number 17 */#define FLASH_SECTOR_18 ((uint32_t)18U) /*!&lt; Sector Number 18 */#define FLASH_SECTOR_19 ((uint32_t)19U) /*!&lt; Sector Number 19 */#define FLASH_SECTOR_20 ((uint32_t)20U) /*!&lt; Sector Number 20 */#define FLASH_SECTOR_21 ((uint32_t)21U) /*!&lt; Sector Number 21 */#define FLASH_SECTOR_22 ((uint32_t)22U) /*!&lt; Sector Number 22 */#define FLASH_SECTOR_23 ((uint32_t)23U) /*!&lt; Sector Number 23 */#endif /* FLASH_SECTOR_TOTAL == 24 */ &emsp;获取Flash对应扇区的函数如下所示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/** * 说明： 获取指定flash地址所在的扇区 * 参数： Address：指定flash地址 * * @返回值 对应flash地址的扇区 */uint32_t STMFLASH_GetFlashSector(uint32 Address)&#123; uint32_t sector = 0; if((Address &lt; ADDR_FLASH_SECTOR_1) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_0)) &#123; sector = FLASH_SECTOR_0; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_2) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_1)) &#123; sector = FLASH_SECTOR_1; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_3) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_2)) &#123; sector = FLASH_SECTOR_2; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_4) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_3)) &#123; sector = FLASH_SECTOR_3; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_5) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_4)) &#123; sector = FLASH_SECTOR_4; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_6) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_5)) &#123; sector = FLASH_SECTOR_5; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_7) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_6)) &#123; sector = FLASH_SECTOR_6; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_8) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_7)) &#123; sector = FLASH_SECTOR_7; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_9) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_8)) &#123; sector = FLASH_SECTOR_8; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_10) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_9)) &#123; sector = FLASH_SECTOR_9; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_11) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_10)) &#123; sector = FLASH_SECTOR_10; &#125;#if defined(DUAL_BANK) else if((Address &lt; ADDR_FLASH_SECTOR_12) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_11)) &#123; sector = FLASH_SECTOR_11; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_13) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_12)) &#123; sector = FLASH_SECTOR_12; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_14) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_13)) &#123; sector = FLASH_SECTOR_13; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_15) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_14)) &#123; sector = FLASH_SECTOR_14; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_16) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_15)) &#123; sector = FLASH_SECTOR_15; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_17) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_16)) &#123; sector = FLASH_SECTOR_16; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_18) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_17)) &#123; sector = FLASH_SECTOR_17; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_19) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_18)) &#123; sector = FLASH_SECTOR_18; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_20) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_19)) &#123; sector = FLASH_SECTOR_19; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_21) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_20)) &#123; sector = FLASH_SECTOR_20; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_22) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_21)) &#123; sector = FLASH_SECTOR_21; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_23) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_22)) &#123; sector = FLASH_SECTOR_22; &#125; else /* (Address &lt; FLASH_END_ADDR) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_23) */ &#123; sector = FLASH_SECTOR_23; &#125; #else else /* (Address &lt; FLASH_END_ADDR) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_11) */ &#123; sector = FLASH_SECTOR_11; &#125;#endif /* DUAL_BANK */ return sector;&#125; Flash擦除函数&emsp;Flash擦除函数的实现如下所示。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * @brief Perform a mass erase or erase the specified FLASH memory sectors * @param[in] pEraseInit pointer to an FLASH_EraseInitTypeDef structure that * contains the configuration information for the erasing. * * @param[out] SectorError pointer to variable that * contains the configuration information on faulty sector in case of error * (0xFFFFFFFF means that all the sectors have been correctly erased) * * @retval HAL Status */HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *SectorError)&#123; HAL_StatusTypeDef status = HAL_ERROR; uint32_t index = 0; /* Process Locked */ __HAL_LOCK(&amp;pFlash); /* Check the parameters */ assert_param(IS_FLASH_TYPEERASE(pEraseInit-&gt;TypeErase)); /* Wait for last operation to be completed */ status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE); if(status == HAL_OK) &#123; /*Initialization of SectorError variable*/ *SectorError = 0xFFFFFFFFU; if(pEraseInit-&gt;TypeErase == FLASH_TYPEERASE_MASSERASE) &#123; /*Mass erase to be done*/#if defined (FLASH_OPTCR_nDBANK) FLASH_MassErase((uint8_t) pEraseInit-&gt;VoltageRange, pEraseInit-&gt;Banks);#else FLASH_MassErase((uint8_t) pEraseInit-&gt;VoltageRange); #endif /* FLASH_OPTCR_nDBANK */ /* Wait for last operation to be completed */ status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE); /* if the erase operation is completed, disable the MER Bit */ FLASH-&gt;CR &amp;= (~FLASH_MER_BIT); &#125; else &#123; /* Check the parameters */ assert_param(IS_FLASH_NBSECTORS(pEraseInit-&gt;NbSectors + pEraseInit-&gt;Sector)); /* Erase by sector by sector to be done*/ for(index = pEraseInit-&gt;Sector; index &lt; (pEraseInit-&gt;NbSectors + pEraseInit-&gt;Sector); index++) &#123; FLASH_Erase_Sector(index, (uint8_t) pEraseInit-&gt;VoltageRange); /* Wait for last operation to be completed */ status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE); /* If the erase operation is completed, disable the SER Bit and SNB Bits */ CLEAR_BIT(FLASH-&gt;CR, (FLASH_CR_SER | FLASH_CR_SNB)); if(status != HAL_OK) &#123; /* In case of error, stop erase procedure and return the faulty sector*/ *SectorError = index; break; &#125; &#125; &#125; &#125; /* Process Unlocked */ __HAL_UNLOCK(&amp;pFlash); return status;&#125; FLASH_WaitForLastOperation()函数&emsp;FLASH_WaitForLastOperation()函数用于等待Flash操作完成。 &emsp;该函数首先对Flash状态进行读取，等待Flash操作完成。读取寄存器FLASH_SR的BSY位，直到确认当前未执行任何Flash操作；读取寄存器FLASH_SR的所有错误位，判断有无错误；读取寄存器FLASH_SR的EOP位，确认完成当前Flash操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);/** * @brief Wait for a FLASH operation to complete. * @param Timeout maximum flash operationtimeout * @retval HAL Status */HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)&#123; uint32_t tickstart = 0; /* Clear Error Code */ pFlash.ErrorCode = HAL_FLASH_ERROR_NONE; /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset. Even if the FLASH operation fails, the BUSY flag will be reset and an error flag will be set */ /* Get tick */ tickstart = HAL_GetTick(); while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) &#123; if(Timeout != HAL_MAX_DELAY) &#123; if((Timeout == 0)||((HAL_GetTick() - tickstart ) &gt; Timeout)) &#123; return HAL_TIMEOUT; &#125; &#125; &#125; if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_ALL_ERRORS) != RESET) &#123; /*Save the error code*/ FLASH_SetErrorCode(); return HAL_ERROR; &#125; /* Check FLASH End of Operation flag */ if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET) &#123; /* Clear FLASH End of Operation pending bit */ __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP); &#125; /* If there is an error flag set */ return HAL_OK; &#125; #define __HAL_FLASH_GET_FLAG(__FLAG__) ((FLASH-&gt;SR &amp; (__FLAG__))) FLASH_MassErase()函数&emsp;FLASH_MassErase()函数用于擦除Flash全部扇区，即按照bank进行擦除。首先通过寄存器FLASH_CR的MER位选择需要批量擦除的bank。STM32F767仅有一个bank，故此处只能选择bank1。之后向FLASH_CR寄存器PSIZE位写入编程大小值，向STRT位写入1启动擦除操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#if defined (FLASH_OPTCR_nDBANK)/** * @brief Full erase of FLASH memory sectors * @param VoltageRange The device voltage range which defines the erase parallelism. * This parameter can be one of the following values: * @arg VOLTAGE_RANGE_1: when the device voltage range is 1.8V to 2.1V, * the operation will be done by byte (8-bit) * @arg VOLTAGE_RANGE_2: when the device voltage range is 2.1V to 2.7V, * the operation will be done by half word (16-bit) * @arg VOLTAGE_RANGE_3: when the device voltage range is 2.7V to 3.6V, * the operation will be done by word (32-bit) * @arg VOLTAGE_RANGE_4: when the device voltage range is 2.7V to 3.6V + External Vpp, * the operation will be done by double word (64-bit) * @param Banks Banks to be erased * This parameter can be one of the following values: * @arg FLASH_BANK_1: Bank1 to be erased * @arg FLASH_BANK_2: Bank2 to be erased * @arg FLASH_BANK_BOTH: Bank1 and Bank2 to be erased * * @retval HAL Status */static void FLASH_MassErase(uint8_t VoltageRange, uint32_t Banks)&#123; /* Check the parameters */ assert_param(IS_VOLTAGERANGE(VoltageRange)); assert_param(IS_FLASH_BANK(Banks)); /* if the previous operation is completed, proceed to erase all sectors */ FLASH-&gt;CR &amp;= CR_PSIZE_MASK; if(Banks == FLASH_BANK_BOTH) &#123; /* bank1 &amp; bank2 will be erased*/ FLASH-&gt;CR |= FLASH_MER_BIT; &#125; else if(Banks == FLASH_BANK_2) &#123; /*Only bank2 will be erased*/ FLASH-&gt;CR |= FLASH_CR_MER2; &#125; else &#123; /*Only bank1 will be erased*/ FLASH-&gt;CR |= FLASH_CR_MER1; &#125; FLASH-&gt;CR |= FLASH_CR_STRT | ((uint32_t)VoltageRange &lt;&lt;8); /* Data synchronous Barrier (DSB) Just after the write operation This will force the CPU to respect the sequence of instruction (no optimization).*/ __DSB();&#125; FLASH_Erase_Sector()函数&emsp;FLASH_Erase_Sector()函数用于擦除特定的Flash扇区。 向FLASH_CR寄存器PSIZE位写入编程大小值； 向FLASH_CR寄存器SNB位写入待擦除的扇区编号；向SER位写入1使能扇区擦除模式； 向FLASH_CR寄存器STRT位写入1启动擦除操作； 执行__DSB()指令：Data synchronous Barrier，即数据同步屏障。只有当此指令执行完毕后，才会执行程序中位于此指令后的指令。 A Data Synchronization Barrier (DSB) completes when all instructions before this instruction complete. A Data Memory Barrier (DMB) ensures that all explicit memory accesses before the DMB instruction complete before any explicit memory accesses after the DMB instruction start. An Instruction Synchronization Barrier (ISB) flushes the pipeline in the processor, so that all instructions following the ISB are fetched from cache or memory, after the ISB has been completed. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * @brief Erase the specified FLASH memory sector * @param Sector FLASH sector to erase * The value of this parameter depend on device used within the same series * @param VoltageRange The device voltage range which defines the erase parallelism. * This parameter can be one of the following values: * @arg FLASH_VOLTAGE_RANGE_1: when the device voltage range is 1.8V to 2.1V, * the operation will be done by byte (8-bit) * @arg FLASH_VOLTAGE_RANGE_2: when the device voltage range is 2.1V to 2.7V, * the operation will be done by half word (16-bit) * @arg FLASH_VOLTAGE_RANGE_3: when the device voltage range is 2.7V to 3.6V, * the operation will be done by word (32-bit) * @arg FLASH_VOLTAGE_RANGE_4: when the device voltage range is 2.7V to 3.6V + External Vpp, * the operation will be done by double word (64-bit) * * @retval None */void FLASH_Erase_Sector(uint32_t Sector, uint8_t VoltageRange)&#123; uint32_t tmp_psize = 0; /* Check the parameters */ assert_param(IS_FLASH_SECTOR(Sector)); assert_param(IS_VOLTAGERANGE(VoltageRange)); if(VoltageRange == FLASH_VOLTAGE_RANGE_1) &#123; tmp_psize = FLASH_PSIZE_BYTE; &#125; else if(VoltageRange == FLASH_VOLTAGE_RANGE_2) &#123; tmp_psize = FLASH_PSIZE_HALF_WORD; &#125; else if(VoltageRange == FLASH_VOLTAGE_RANGE_3) &#123; tmp_psize = FLASH_PSIZE_WORD; &#125; else &#123; tmp_psize = FLASH_PSIZE_DOUBLE_WORD; &#125; /* Need to add offset of 4 when sector higher than FLASH_SECTOR_11 */ if(Sector &gt; FLASH_SECTOR_11) &#123; Sector += 4; &#125; /* If the previous operation is completed, proceed to erase the sector */ FLASH-&gt;CR &amp;= CR_PSIZE_MASK; FLASH-&gt;CR |= tmp_psize; CLEAR_BIT(FLASH-&gt;CR, FLASH_CR_SNB); FLASH-&gt;CR |= FLASH_CR_SER | (Sector &lt;&lt; FLASH_CR_SNB_Pos); FLASH-&gt;CR |= FLASH_CR_STRT; /* Data synchronous Barrier (DSB) Just after the write operation This will force the CPU to respect the sequence of instruction (no optimization).*/ __DSB();&#125; HAL_FLASHEx_Erase()函数&emsp;HAL_FLASHEx_Erase()函数为对Flash进行bank擦除或者多个区块擦除的函数，其实现利用了FLASH_MassErase()函数与FLASH_Erase_Sector()函数。其实现非常简单，这里不再说明。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * @brief Perform a mass erase or erase the specified FLASH memory sectors * @param[in] pEraseInit pointer to an FLASH_EraseInitTypeDef structure that * contains the configuration information for the erasing. * * @param[out] SectorError pointer to variable that * contains the configuration information on faulty sector in case of error * (0xFFFFFFFF means that all the sectors have been correctly erased) * * @retval HAL Status */HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *SectorError)&#123; HAL_StatusTypeDef status = HAL_ERROR; uint32_t index = 0; /* Process Locked */ __HAL_LOCK(&amp;pFlash); /* Check the parameters */ assert_param(IS_FLASH_TYPEERASE(pEraseInit-&gt;TypeErase)); /* Wait for last operation to be completed */ status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE); if(status == HAL_OK) &#123; /*Initialization of SectorError variable*/ *SectorError = 0xFFFFFFFFU; if(pEraseInit-&gt;TypeErase == FLASH_TYPEERASE_MASSERASE) &#123; /*Mass erase to be done*/#if defined (FLASH_OPTCR_nDBANK) FLASH_MassErase((uint8_t) pEraseInit-&gt;VoltageRange, pEraseInit-&gt;Banks);#else FLASH_MassErase((uint8_t) pEraseInit-&gt;VoltageRange); #endif /* FLASH_OPTCR_nDBANK */ /* Wait for last operation to be completed */ status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE); /* if the erase operation is completed, disable the MER Bit */ FLASH-&gt;CR &amp;= (~FLASH_MER_BIT); &#125; else &#123; /* Check the parameters */ assert_param(IS_FLASH_NBSECTORS(pEraseInit-&gt;NbSectors + pEraseInit-&gt;Sector)); /* Erase by sector by sector to be done*/ for(index = pEraseInit-&gt;Sector; index &lt; (pEraseInit-&gt;NbSectors + pEraseInit-&gt;Sector); index++) &#123; FLASH_Erase_Sector(index, (uint8_t) pEraseInit-&gt;VoltageRange); /* Wait for last operation to be completed */ status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE); /* If the erase operation is completed, disable the SER Bit and SNB Bits */ CLEAR_BIT(FLASH-&gt;CR, (FLASH_CR_SER | FLASH_CR_SNB)); if(status != HAL_OK) &#123; /* In case of error, stop erase procedure and return the faulty sector*/ *SectorError = index; break; &#125; &#125; &#125; &#125; /* Process Unlocked */ __HAL_UNLOCK(&amp;pFlash); return status;&#125; Flash编程函数&emsp;Flash编程函数的实现如下所示。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * @brief Program byte, halfword, word or double word at a specified address * @param TypeProgram Indicate the way to program at a specified address. * This parameter can be a value of @ref FLASH_Type_Program * @param Address specifies the address to be programmed. * @param Data specifies the data to be programmed * * @retval HAL_StatusTypeDef HAL Status */HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)&#123; HAL_StatusTypeDef status = HAL_ERROR; /* Process Locked */ __HAL_LOCK(&amp;pFlash); /* Check the parameters */ assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram)); /* Wait for last operation to be completed */ status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE); if(status == HAL_OK) &#123; switch(TypeProgram) &#123; case FLASH_TYPEPROGRAM_BYTE : &#123; /*Program byte (8-bit) at a specified address.*/ FLASH_Program_Byte(Address, (uint8_t) Data); break; &#125; case FLASH_TYPEPROGRAM_HALFWORD : &#123; /*Program halfword (16-bit) at a specified address.*/ FLASH_Program_HalfWord(Address, (uint16_t) Data); break; &#125; case FLASH_TYPEPROGRAM_WORD : &#123; /*Program word (32-bit) at a specified address.*/ FLASH_Program_Word(Address, (uint32_t) Data); break; &#125; case FLASH_TYPEPROGRAM_DOUBLEWORD : &#123; /*Program double word (64-bit) at a specified address.*/ FLASH_Program_DoubleWord(Address, Data); break; &#125; default : break; &#125; /* Wait for last operation to be completed */ status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE); /* If the program operation is completed, disable the PG Bit */ FLASH-&gt;CR &amp;= (~FLASH_CR_PG); &#125; /* Process Unlocked */ __HAL_UNLOCK(&amp;pFlash); return status;&#125; FLASH_Program_Byte()函数&emsp;FLASH_Program_Byte()函数用于向特定地址写入byte数据。具体功能如下： 向FLASH_CR寄存器PSIZE位写入编程大小值：byte； 向FLASH_CR寄存器PG位写入1，激活Flash编程； 向Flash对应地址写入数值，注意指针类型的变换； 通过DSB保障数据同步。 12345678910111213141516171819202122232425262728/** * @brief Program byte (8-bit) at a specified address. * @note This function must be used when the device voltage range is from * 2.7V to 3.6V. * * @note If an erase and a program operations are requested simultaneously, * the erase operation is performed before the program one. * * @param Address specifies the address to be programmed. * @param Data specifies the data to be programmed. * @retval None */static void FLASH_Program_Byte(uint32_t Address, uint8_t Data)&#123; /* Check the parameters */ assert_param(IS_FLASH_ADDRESS(Address)); /* If the previous operation is completed, proceed to program the new data */ FLASH-&gt;CR &amp;= CR_PSIZE_MASK; FLASH-&gt;CR |= FLASH_PSIZE_BYTE; FLASH-&gt;CR |= FLASH_CR_PG; *(__IO uint8_t*)Address = Data; /* Data synchronous Barrier (DSB) Just after the write operation This will force the CPU to respect the sequence of instruction (no optimization).*/ __DSB();&#125; &emsp;FLASH_Program_HalfWord()、FLASH_Program_Word()、FLASH_Program_DoubleWord()函数实现与此类似，不再进行介绍。 当该函数执行完毕后，需要将FLASH_CR寄存器PG位复位，关闭Flash编程。 基于HAL库的Flash读写函数实现Flash写入函数&emsp;Flash写入函数的实现如下所示。该函数逻辑简明，这里不再说明。使用时请务必注意待写入flash的地址，本例中采用字写入方式，故写入地址必须为4的倍数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 说明： 向指定flash区域写入数据 * @参数 WriteAddr：待写入flash的地址，本例中采用字写入方式，故写入地址必须为4的倍数； * @参数 pBuffer：指向待写入数据的指针，按照字写入方式，所以类型为uint32； * @参数 NumToWrite：待写入数据个数。 * * @返回值 HAL Status */HAL_StatusTypeDef STMFLASH_Write(uint32 WriteAddr,uint32 *pBuffer,uint32 NumToWrite) &#123; FLASH_EraseInitTypeDef EraseInitStruct; HAL_StatusTypeDef status = HAL_ERROR; uint32 SECTORError = 0; uint32_t FirstSector = 0, NbOfSectors = 0; uint32 addrStart = WriteAddr; /* flash写入的起始地址 */ uint32 addrEnd = WriteAddr + NumToWrite * 4 - 1; /* flash写入的结束地址 */ /* 检测flash地址是否合法 */ assert_param(IS_FLASH_ADDRESS(addrStart)); assert_param(IS_FLASH_ADDRESS(addrEnd)); /* 如果写入数据量为0，则返回错误 */ if (NumToWrite == 0) return status; /* 解锁flash */ HAL_FLASH_Unlock(); /* 获取要擦除的首个扇区 */ FirstSector = STMFLASH_GetFlashSector(addrStart); /* 获取要擦除的扇区个数 */ NbOfSectors = STMFLASH_GetFlashSector(addrEnd) - FirstSector + 1; /* 设置EraseInitStruct结构体信息 */ EraseInitStruct.TypeErase = FLASH_TYPEERASE_SECTORS; /* 扇区擦除 */ EraseInitStruct.VoltageRange = FLASH_VOLTAGE_RANGE_3; /* 电压在2.7-3.6V之间，实际为3.3V */ EraseInitStruct.Sector = FirstSector; EraseInitStruct.NbSectors = NbOfSectors; /* 擦除相应的flash扇区 */ status = HAL_FLASHEx_Erase(&amp;EraseInitStruct, &amp;SECTORError); if (status != HAL_OK) return status; status = FLASH_WaitForLastOperation(FLASH_WAITETIME); /* 等待flash操作完成 */ if(status == HAL_OK) &#123; while(addrStart &lt;= addrEnd)//写数据 &#123; /* 向flash写入数据 */ status = HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD,addrStart,*pBuffer); if(status != HAL_OK) return status; addrStart += 4; pBuffer++; &#125; &#125; /* 锁定flash */ HAL_FLASH_Lock(); return status;&#125; Flash读取函数&emsp;Flash读取函数的实现如下所示。该函数逻辑简明，这里不再说明。使用时请务必注意待读取入flash的地址，本例中采用字读取方式，故读取地址必须为4的倍数。 123456789101112131415161718192021222324252627/** * 说明： 从指定flash区域读取一个字 * * @返回值 对应flash区域的数据 */uint32 STMFLASH_ReadWord(uint32 Address)&#123; return *(__IO uint32_t *)Address; &#125;/** * 说明： 从指定flash区域读取数据 * @参数 ReadAddr：待读取flash的地址，本例中采用字读取方式，故读取地址必须为4的倍数； * @参数 pBuffer：指向存储读取数据数组的指针，按照字读取方式，所以类型为uint32； * @参数 NumToRead：待读取数据个数。 * * @返回值 无 */void STMFLASH_Read(uint32 ReadAddr,uint32 *pBuffer,uint32 NumToRead) &#123; uint32 i; for(i = 0;i &lt; NumToRead;i++) &#123; pBuffer[i] = STMFLASH_ReadWord(ReadAddr); /* 读取一个字 */ ReadAddr += 4; &#125;&#125; 实验验证&emsp;验证程序片段如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243uint32 mainloop = 0;#define FLASH_SAVE_ADDR ADDR_FLASH_SECTOR_7 - 8uint8 writeBuffer[200];uint8 readBuffer[200];#define TEXT_LENTH sizeof(writeBuffer) //数组长度 #define SIZE TEXT_LENTH/4+((TEXT_LENTH%4)?1:0)int16 test = 0;uint16 screenShow = 0;/* 初始化部分省略 */ while (1) &#123; mainloop++; oled_putuint32(0, 2, mainloop); SYS_Delay_US(1000000); for (test = 0; test &lt; 200; test++) &#123; writeBuffer[test] = test + mainloop%50; &#125; screenShow += STMFLASH_Write(FLASH_SAVE_ADDR,(uint32*)writeBuffer,SIZE); STMFLASH_Read(FLASH_SAVE_ADDR,(uint32*)readBuffer,SIZE); HAL_UART_Transmit(&amp;huart1,readBuffer,200,1000); for (test = 0; test &lt; 200; test++) &#123; if (writeBuffer[test] != readBuffer[test]) screenShow++; &#125; oled_putuint32(0, 5, screenShow); &#125; &emsp;程序功能如下： 写入地址为扇区7首地址减去8，实际为扇区6靠近末端，则擦除、读取均进行跨扇区操作； 向该地址flash写入200字节数据并读取比对，确认有无读写错误； 经验证读写均正常，实验完成。","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://jiaodi.tech/categories/嵌入式/"}],"tags":[{"name":"STM32F7","slug":"STM32F7","permalink":"http://jiaodi.tech/tags/STM32F7/"},{"name":"Flash","slug":"Flash","permalink":"http://jiaodi.tech/tags/Flash/"}]},{"title":"STM32F767 RTC的基本用法","slug":"stm32f767-rtc","date":"2018-05-21T15:12:27.000Z","updated":"2018-06-02T03:08:11.210Z","comments":true,"path":"2018/05/21/stm32f767-rtc/","link":"","permalink":"http://jiaodi.tech/2018/05/21/stm32f767-rtc/","excerpt":"&emsp;本文介绍STM32F767 RTC(Real-time clock)的基本用法。","text":"&emsp;本文介绍STM32F767 RTC(Real-time clock)的基本用法。 开发环境硬件环境 电脑：Windows 10 Home x64 Apollo STM32F767开发板(ST-LINK V2仿真器) 软件环境 Keil Version 5.24.1 (Pack Installer：Keil.STM32F7xx_DFP.2.9.0.pack) STM32CubeMX Version 4.25.0(Packages Manager：STM32CubeF7) RTC功能介绍RTC主要特性 包含亚秒、秒、分钟、小时（12/24 小时制）、星期几、日期、月份和年份的日历； 软件可编程的夏令时补偿； 具有中断功能的可编程闹钟。可通过任意日历字段的组合触发闹钟； 自动唤醒单元，可周期性地生成标志以触发自动唤醒中断； 参考时钟检测：可使用更加精确的第二时钟源（50 Hz 或 60 Hz）来提高日历的精确度； 利用亚秒级移位特性与外部时钟实现精确同步； 数字校准电路（周期性计数器调整）：精度为 0.95 ppm，在数秒钟的校准窗口中获得； 用于事件保存的时间戳功能； 带可配置过滤器和内部上拉的入侵检测事件； 可屏蔽中断/事件：闹钟A、闹钟B、唤醒中断、时间戳、入侵检测 32备份寄存器。 RTC系统框图 &emsp;本例中仅使用RTC的基本功能：设置RTC事件后进行读取操作，故不再对框图进行说明。 RTC的基本用法RTC时钟设置&emsp;本例中，使用外部低速时钟LSE作为时钟源，其频率为32.768kHz。 &emsp;RTC的时钟设置函数如下所示。 12345678910111213141516171819202122232425262728293031323334/** * @brief RTC Clock Configuration * @retval None */void RTC_Clock_Config(void)&#123; RCC_OscInitTypeDef RCC_OscInitStruct; RCC_PeriphCLKInitTypeDef PeriphClkInitStruct; /**Configure the main internal regulator output voltage */ __HAL_RCC_PWR_CLK_ENABLE(); __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1); /**初始化LSE时钟：32.768kHz */ RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE; /* LSE配置 */ RCC_OscInitStruct.LSEState = RCC_LSE_ON; /* LSE使能 */ RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE; /* LSE无PLL */ if (HAL_RCC_OscConfig(&amp;RCC_OscInitStruct) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC; /* 外设为RTC */ PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE; /* RTC时钟源为LSE */ if (HAL_RCCEx_PeriphCLKConfig(&amp;PeriphClkInitStruct) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125;&#125; &emsp;RTC时钟初始化函数的主要功能如下： 使能外部LSE时钟，LSE无PLL功能； 设置RTC的时钟源为LSE。 RTC初始化函数&emsp;RTC初始化函数如下所示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051RTC_HandleTypeDef hrtc;#define RTC_BKP_Mask 0x5051/* RTC init function */void MX_RTC_Init(void)&#123; RTC_TimeTypeDef sTime; RTC_DateTypeDef sDate; /**Initialize RTC Only */ hrtc.Instance = RTC;if(HAL_RTCEx_BKUPRead(&amp;hrtc, RTC_BKP_DR0) != RTC_BKP_Mask)&#123; hrtc.Init.HourFormat = RTC_HOURFORMAT_24; /* 24小时制 */ hrtc.Init.AsynchPrediv = 127; hrtc.Init.SynchPrediv = 255; /* 分频系数 = 128 * 256 = 32768 */ hrtc.Init.OutPut = RTC_OUTPUT_DISABLE; /* 禁用RTC output输出 */ hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH; hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN; if (HAL_RTC_Init(&amp;hrtc) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; /**初始化RTC时间与日期 */ sTime.Hours = 23; sTime.Minutes = 8; sTime.Seconds = 50; sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE; /* 关闭夏令时 */ sTime.StoreOperation = RTC_STOREOPERATION_RESET; if (HAL_RTC_SetTime(&amp;hrtc, &amp;sTime, RTC_FORMAT_BIN) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; sDate.WeekDay = RTC_WEEKDAY_WEDNESDAY; sDate.Month = RTC_MONTH_MAY; sDate.Date = 30; sDate.Year = 18; if (HAL_RTC_SetDate(&amp;hrtc, &amp;sDate, RTC_FORMAT_BIN) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; HAL_RTCEx_BKUPWrite(&amp;hrtc,RTC_BKP_DR0,RTC_BKP_Mask); &#125;&#125; &emsp;初始化函数的功能如下： 设置RTC为24小时制； 设置RTC分频系数，32.768kHz时钟分频后为1Hz； 初始化RTC； 设置RTC时分秒，关闭夏令时； 设置RTC年月日星期； 初始化RTC时间与日期。 HAL_RTC_Init()函数实现&emsp;HAL_RTC_Init()函数用于初始化RTC，其实现如下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * @brief Initializes the RTC peripheral * @param hrtc pointer to a RTC_HandleTypeDef structure that contains * the configuration information for RTC. * @retval HAL status */HAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc)&#123; /* Check the RTC peripheral state */ if(hrtc == NULL) &#123; return HAL_ERROR; &#125; /* Check the parameters */ assert_param(IS_RTC_ALL_INSTANCE(hrtc-&gt;Instance)); assert_param(IS_RTC_HOUR_FORMAT(hrtc-&gt;Init.HourFormat)); assert_param(IS_RTC_ASYNCH_PREDIV(hrtc-&gt;Init.AsynchPrediv)); assert_param(IS_RTC_SYNCH_PREDIV(hrtc-&gt;Init.SynchPrediv)); assert_param (IS_RTC_OUTPUT(hrtc-&gt;Init.OutPut)); assert_param (IS_RTC_OUTPUT_POL(hrtc-&gt;Init.OutPutPolarity)); assert_param(IS_RTC_OUTPUT_TYPE(hrtc-&gt;Init.OutPutType)); if(hrtc-&gt;State == HAL_RTC_STATE_RESET) &#123; /* Allocate lock resource and initialize it */ hrtc-&gt;Lock = HAL_UNLOCKED; /* Initialize RTC MSP */ HAL_RTC_MspInit(hrtc); /* 使能RTC时钟 */ &#125; /* Set RTC state */ hrtc-&gt;State = HAL_RTC_STATE_BUSY; /* Disable the write protection for RTC registers */ __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc); /* 解锁RTC寄存器的写保护 */ /* Set Initialization mode */ if(RTC_EnterInitMode(hrtc) != HAL_OK) /* 进入RTC初始化模式 */ &#123; /* Enable the write protection for RTC registers */ __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); /* Set RTC state */ hrtc-&gt;State = HAL_RTC_STATE_ERROR; return HAL_ERROR; &#125; else &#123; /* Clear RTC_CR FMT, OSEL and POL Bits */ hrtc-&gt;Instance-&gt;CR &amp;= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL)); /* 配置RTC模式 */ /* Set RTC_CR register */ hrtc-&gt;Instance-&gt;CR |= (uint32_t)(hrtc-&gt;Init.HourFormat | hrtc-&gt;Init.OutPut | hrtc-&gt;Init.OutPutPolarity); /* Configure the RTC PRER */ /* 配置RTC分频系数 */ hrtc-&gt;Instance-&gt;PRER = (uint32_t)(hrtc-&gt;Init.SynchPrediv); hrtc-&gt;Instance-&gt;PRER |= (uint32_t)(hrtc-&gt;Init.AsynchPrediv &lt;&lt; 16); /* Exit Initialization mode */ hrtc-&gt;Instance-&gt;ISR &amp;= (uint32_t)~RTC_ISR_INIT; /* 跳出初始化模式 */ hrtc-&gt;Instance-&gt;OR &amp;= (uint32_t)~RTC_OR_ALARMTYPE; /* ALARM TIMESTAMP IO设置 */ hrtc-&gt;Instance-&gt;OR |= (uint32_t)(hrtc-&gt;Init.OutPutType); /* Enable the write protection for RTC registers */ __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); /* 上锁RTC寄存器的写保护 */ /* Set RTC state */ hrtc-&gt;State = HAL_RTC_STATE_READY; return HAL_OK; &#125;&#125; &emsp;HAL_RTC_MspInit()函数仅用于使能RTC时钟，具体如下。 123456789101112131415void HAL_RTC_MspInit(RTC_HandleTypeDef* rtcHandle)&#123; if(rtcHandle-&gt;Instance==RTC) &#123; /* USER CODE BEGIN RTC_MspInit 0 */ /* USER CODE END RTC_MspInit 0 */ /* RTC clock enable */ __HAL_RCC_RTC_ENABLE(); /* USER CODE BEGIN RTC_MspInit 1 */ /* USER CODE END RTC_MspInit 1 */ &#125;&#125; &emsp;RTC具有寄存器写保护功能，进行寄存器写入之前必须首先进行解锁。解锁的操作为：按顺序写入0xCA与0x53即可解锁所有RTC寄存器；写入一个错误的关键字会再次激活写保护。 1234567891011121314151617181920/** * @brief Disable the write protection for RTC registers. * @param __HANDLE__ specifies the RTC handle. * @retval None */#define __HAL_RTC_WRITEPROTECTION_DISABLE(__HANDLE__) \\ do&#123; \\ (__HANDLE__)-&gt;Instance-&gt;WPR = 0xCAU; \\ (__HANDLE__)-&gt;Instance-&gt;WPR = 0x53U; \\ &#125; while(0U)/** * @brief Enable the write protection for RTC registers. * @param __HANDLE__ specifies the RTC handle. * @retval None */#define __HAL_RTC_WRITEPROTECTION_ENABLE(__HANDLE__) \\ do&#123; \\ (__HANDLE__)-&gt;Instance-&gt;WPR = 0xFFU; \\ &#125; while(0U) &emsp;RTC_EnterInitMode()函数用于将RTC设置为初始化模式。通过将RTC RTC_ISR寄存器INIT位置位实现。 123456789101112131415161718192021222324252627282930313233/** * @brief Enters the RTC Initialization mode. * @note The RTC Initialization mode is write protected, use the * __HAL_RTC_WRITEPROTECTION_DISABLE() before calling this function. * @param hrtc pointer to a RTC_HandleTypeDef structure that contains * the configuration information for RTC. * @retval HAL status */HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef* hrtc)&#123; uint32_t tickstart = 0; /* Check if the Initialization mode is set */ if((hrtc-&gt;Instance-&gt;ISR &amp; RTC_ISR_INITF) == (uint32_t)RESET) &#123; /* Set the Initialization mode */ hrtc-&gt;Instance-&gt;ISR = (uint32_t)RTC_INIT_MASK; /* Get tick */ tickstart = HAL_GetTick(); /* Wait till RTC is in INIT state and if Time out is reached exit */ while((hrtc-&gt;Instance-&gt;ISR &amp; RTC_ISR_INITF) == (uint32_t)RESET) &#123; if((HAL_GetTick() - tickstart ) &gt; RTC_TIMEOUT_VALUE) &#123; return HAL_TIMEOUT; &#125; &#125; &#125; return HAL_OK; &#125; &emsp;之后进入主配置环节，具体配置如下： 通过RTC_CR寄存器FMT、OSEL、POL位分别设置小时格式、输出选择与输出极性，本例设置为24小时制，输出禁用； 通过RTC_PRER寄存器设置预分频系数； 跳出初始化模式； 设置ALARM与TIMESTAMP，本例中不使用； 上锁RTC寄存器写保护。 HAL_RTC_SetTime()函数实现&emsp;HAL_RTC_SetTime()函数用于设置RTC时间，具体实现如下。该函数的核心功能为通过向RTC时间寄存器RTC_TR写入时分秒时间实现，本例中不启用夏令时。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/** * @brief Sets RTC current time. * @param hrtc pointer to a RTC_HandleTypeDef structure that contains * the configuration information for RTC. * @param sTime Pointer to Time structure * @param Format Specifies the format of the entered parameters. * This parameter can be one of the following values: * @arg FORMAT_BIN: Binary data format * @arg FORMAT_BCD: BCD data format * @retval HAL status */HAL_StatusTypeDef HAL_RTC_SetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)&#123; uint32_t tmpreg = 0; /* Check the parameters */ assert_param(IS_RTC_FORMAT(Format)); assert_param(IS_RTC_DAYLIGHT_SAVING(sTime-&gt;DayLightSaving)); assert_param(IS_RTC_STORE_OPERATION(sTime-&gt;StoreOperation)); /* Process Locked */ __HAL_LOCK(hrtc); hrtc-&gt;State = HAL_RTC_STATE_BUSY; if(Format == RTC_FORMAT_BIN) &#123; if((hrtc-&gt;Instance-&gt;CR &amp; RTC_CR_FMT) != (uint32_t)RESET) &#123; assert_param(IS_RTC_HOUR12(sTime-&gt;Hours)); assert_param(IS_RTC_HOURFORMAT12(sTime-&gt;TimeFormat)); &#125; else &#123; sTime-&gt;TimeFormat = 0x00; assert_param(IS_RTC_HOUR24(sTime-&gt;Hours)); &#125; assert_param(IS_RTC_MINUTES(sTime-&gt;Minutes)); assert_param(IS_RTC_SECONDS(sTime-&gt;Seconds)); tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime-&gt;Hours) &lt;&lt; 16) | \\ ((uint32_t)RTC_ByteToBcd2(sTime-&gt;Minutes) &lt;&lt; 8) | \\ ((uint32_t)RTC_ByteToBcd2(sTime-&gt;Seconds)) | \\ (((uint32_t)sTime-&gt;TimeFormat) &lt;&lt; 16)); &#125; else &#123; if((hrtc-&gt;Instance-&gt;CR &amp; RTC_CR_FMT) != (uint32_t)RESET) &#123; tmpreg = RTC_Bcd2ToByte(sTime-&gt;Hours); assert_param(IS_RTC_HOUR12(tmpreg)); assert_param(IS_RTC_HOURFORMAT12(sTime-&gt;TimeFormat)); &#125; else &#123; sTime-&gt;TimeFormat = 0x00; assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sTime-&gt;Hours))); &#125; assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sTime-&gt;Minutes))); assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sTime-&gt;Seconds))); tmpreg = (((uint32_t)(sTime-&gt;Hours) &lt;&lt; 16) | \\ ((uint32_t)(sTime-&gt;Minutes) &lt;&lt; 8) | \\ ((uint32_t)sTime-&gt;Seconds) | \\ ((uint32_t)(sTime-&gt;TimeFormat) &lt;&lt; 16)); &#125; /* Disable the write protection for RTC registers */ __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc); /* Set Initialization mode */ if(RTC_EnterInitMode(hrtc) != HAL_OK) &#123; /* Enable the write protection for RTC registers */ __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); /* Set RTC state */ hrtc-&gt;State = HAL_RTC_STATE_ERROR; /* Process Unlocked */ __HAL_UNLOCK(hrtc); return HAL_ERROR; &#125; else &#123; /* Set the RTC_TR register */ hrtc-&gt;Instance-&gt;TR = (uint32_t)(tmpreg &amp; RTC_TR_RESERVED_MASK); /* Clear the bits to be configured */ hrtc-&gt;Instance-&gt;CR &amp;= (uint32_t)~RTC_CR_BKP; /* Configure the RTC_CR register */ hrtc-&gt;Instance-&gt;CR |= (uint32_t)(sTime-&gt;DayLightSaving | sTime-&gt;StoreOperation); /* Exit Initialization mode */ hrtc-&gt;Instance-&gt;ISR &amp;= (uint32_t)~RTC_ISR_INIT; /* If CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */ if((hrtc-&gt;Instance-&gt;CR &amp; RTC_CR_BYPSHAD) == RESET) &#123; if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK) &#123; /* Enable the write protection for RTC registers */ __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); hrtc-&gt;State = HAL_RTC_STATE_ERROR; /* Process Unlocked */ __HAL_UNLOCK(hrtc); return HAL_ERROR; &#125; &#125; /* Enable the write protection for RTC registers */ __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); hrtc-&gt;State = HAL_RTC_STATE_READY; __HAL_UNLOCK(hrtc); return HAL_OK; &#125;&#125; HAL_RTC_SetDate()函数实现&emsp;HAL_RTC_SetDate()函数用于设置RTC日期，具体实现如下。该函数的核心功能为通过向RTC时间寄存器RTC_DR写入年月日以及周时间实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/** * @brief Sets RTC current date. * @param hrtc pointer to a RTC_HandleTypeDef structure that contains * the configuration information for RTC. * @param sDate Pointer to date structure * @param Format specifies the format of the entered parameters. * This parameter can be one of the following values: * @arg RTC_FORMAT_BIN: Binary data format * @arg RTC_FORMAT_BCD: BCD data format * @retval HAL status */HAL_StatusTypeDef HAL_RTC_SetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)&#123; uint32_t datetmpreg = 0; /* Check the parameters */ assert_param(IS_RTC_FORMAT(Format)); /* Process Locked */ __HAL_LOCK(hrtc); hrtc-&gt;State = HAL_RTC_STATE_BUSY; if((Format == RTC_FORMAT_BIN) &amp;&amp; ((sDate-&gt;Month &amp; 0x10U) == 0x10U)) &#123; sDate-&gt;Month = (uint8_t)((sDate-&gt;Month &amp; (uint8_t)~(0x10U)) + (uint8_t)0x0AU); &#125; assert_param(IS_RTC_WEEKDAY(sDate-&gt;WeekDay)); if(Format == RTC_FORMAT_BIN) &#123; assert_param(IS_RTC_YEAR(sDate-&gt;Year)); assert_param(IS_RTC_MONTH(sDate-&gt;Month)); assert_param(IS_RTC_DATE(sDate-&gt;Date)); datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate-&gt;Year) &lt;&lt; 16) | \\ ((uint32_t)RTC_ByteToBcd2(sDate-&gt;Month) &lt;&lt; 8) | \\ ((uint32_t)RTC_ByteToBcd2(sDate-&gt;Date)) | \\ ((uint32_t)sDate-&gt;WeekDay &lt;&lt; 13)); &#125; else &#123; assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(sDate-&gt;Year))); assert_param(IS_RTC_MONTH(sDate-&gt;Month)); assert_param(IS_RTC_DATE(sDate-&gt;Date)); datetmpreg = ((((uint32_t)sDate-&gt;Year) &lt;&lt; 16) | \\ (((uint32_t)sDate-&gt;Month) &lt;&lt; 8) | \\ ((uint32_t)sDate-&gt;Date) | \\ (((uint32_t)sDate-&gt;WeekDay) &lt;&lt; 13)); &#125; /* Disable the write protection for RTC registers */ __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc); /* Set Initialization mode */ if(RTC_EnterInitMode(hrtc) != HAL_OK) &#123; /* Enable the write protection for RTC registers */ __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); /* Set RTC state*/ hrtc-&gt;State = HAL_RTC_STATE_ERROR; /* Process Unlocked */ __HAL_UNLOCK(hrtc); return HAL_ERROR; &#125; else &#123; /* Set the RTC_DR register */ hrtc-&gt;Instance-&gt;DR = (uint32_t)(datetmpreg &amp; RTC_DR_RESERVED_MASK); /* Exit Initialization mode */ hrtc-&gt;Instance-&gt;ISR &amp;= (uint32_t)~RTC_ISR_INIT; /* If CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */ if((hrtc-&gt;Instance-&gt;CR &amp; RTC_CR_BYPSHAD) == RESET) &#123; if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK) &#123; /* Enable the write protection for RTC registers */ __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); hrtc-&gt;State = HAL_RTC_STATE_ERROR; /* Process Unlocked */ __HAL_UNLOCK(hrtc); return HAL_ERROR; &#125; &#125; /* Enable the write protection for RTC registers */ __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); hrtc-&gt;State = HAL_RTC_STATE_READY ; /* Process Unlocked */ __HAL_UNLOCK(hrtc); return HAL_OK; &#125;&#125; HAL_RTCEx_BKUPRead/Write()函数实现&emsp;RTC有32个备份寄存器，可以用于存储一些特征变量。本例中RTC初始化函数展示了备份寄存器的一个用法：用于标记是否进行过RTC初始化，防止重新上电对RTC进行重复初始化。RTC初始化函数首先读取本分寄存器0存储的数值，如果与比对值不一致则初始化RTC；当初始化完成重新上电后，寄存器值与比对值一致，所以不再重新初始化。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * @brief Reads data from the specified RTC Backup data Register. * @param hrtc pointer to a RTC_HandleTypeDef structure that contains * the configuration information for RTC. * @param BackupRegister RTC Backup data Register number. * This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to * specify the register. * @retval Read value */uint32_t HAL_RTCEx_BKUPRead(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister)&#123; uint32_t tmp = 0; /* Check the parameters */ assert_param(IS_RTC_BKP(BackupRegister)); tmp = (uint32_t)&amp;(hrtc-&gt;Instance-&gt;BKP0R); tmp += (BackupRegister * 4); /* Read the specified register */ return (*(__IO uint32_t *)tmp);&#125;/** * @brief Writes a data in a specified RTC Backup data register. * @param hrtc pointer to a RTC_HandleTypeDef structure that contains * the configuration information for RTC. * @param BackupRegister RTC Backup data Register number. * This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to * specify the register. * @param Data Data to be written in the specified RTC Backup data register. * @retval None */void HAL_RTCEx_BKUPWrite(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister, uint32_t Data)&#123; uint32_t tmp = 0; /* Check the parameters */ assert_param(IS_RTC_BKP(BackupRegister)); tmp = (uint32_t)&amp;(hrtc-&gt;Instance-&gt;BKP0R); tmp += (BackupRegister * 4); /* Write the specified register */ *(__IO uint32_t *)tmp = (uint32_t)Data;&#125; 实验验证&emsp;RTC初始化完成后可以对RTC时间进行读取，具体方法如下。 123456789101112131415161718while (1)&#123; mainloop++; oled_putuint32(0, 2, mainloop); HAL_RTC_GetTime(&amp;hrtc, &amp;rtcTime, RTC_FORMAT_BIN); LCD_P6x8Num3(0, 5, rtcTime.Hours); LCD_P6x8Num3(4, 5, rtcTime.Minutes); LCD_P6x8Num3(8, 5, rtcTime.Seconds); HAL_RTC_GetDate(&amp;hrtc, &amp;rtcData, RTC_FORMAT_BIN); LCD_P6x8Num3(0, 4, rtcData.Year); LCD_P6x8Num3(4, 4, rtcData.Month); LCD_P6x8Num3(8, 4, rtcData.Date); SYS_Delay_US(500000); &#125; &emsp;运行程序后，可以看到时间、日期读取正确；断电后由于后备电池的存在RTC依然可以计时。 有一点需要注意的是，HAL_RTC_GetTime()函数必须先于HAL_RTC_GetDate()函数调用，ST对此的解释如下： 关于这个问题，读日历时间时有两种模式。 一种是通过影子寄存器来读取，一种是直接日历计数器中读。你谈到的情况是前者。 在该情形下，建议先读时分秒寄存器即TR寄存器，然后读日期寄存器，即DR寄存器。 在读取TR/SSR寄存器后，DR影子寄存器的数据会被锁定而不被更新，直到你来读它，这 样是为了保持数据的一致性。 比如你在5月29日的23:59:59秒去读该时间【TR/SSR】，此时29日就会被锁定，这样你 可以悠然地去读日期，日期还是正确的29日，否则1秒过后去读的话，你读到日期就是30日 了，显然整个读进来的时间就不对了。 &emsp;本例中RTC_CR寄存器的BYPSHAD位设置为0，即日历值（从 RTC_SSR、RTC_TR 和 RTC_DR 读取时）取自影子寄存器，该影子寄存器每两个 RTCCLK 周期更新一次，对应了上述情况，所以应该按照先读TR寄存器，再读DR寄存器的方式。","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://jiaodi.tech/categories/嵌入式/"}],"tags":[{"name":"STM32F7","slug":"STM32F7","permalink":"http://jiaodi.tech/tags/STM32F7/"},{"name":"RTC","slug":"RTC","permalink":"http://jiaodi.tech/tags/RTC/"}]},{"title":"STM32F767 DMA的基本用法","slug":"stm32f767-uart-dma","date":"2018-05-19T12:19:51.000Z","updated":"2018-05-21T15:01:43.353Z","comments":true,"path":"2018/05/19/stm32f767-uart-dma/","link":"","permalink":"http://jiaodi.tech/2018/05/19/stm32f767-uart-dma/","excerpt":"本文介绍STM32F767 DMA(Direct memory access controller)的基本用法。","text":"本文介绍STM32F767 DMA(Direct memory access controller)的基本用法。 开发环境硬件环境 电脑：Windows 10 Home x64 Apollo STM32F767开发板(ST-LINK V2仿真器) 软件环境 Keil Version 5.24.1 (Pack Installer：Keil.STM32F7xx_DFP.2.9.0.pack) STM32CubeMX Version 4.25.0(Packages Manager：STM32CubeF7) DMA的基本特性&emsp;直接存储器访问 (DMA) 用于在外设与存储器之间以及存储器与存储器之间提供高速数据传输。可以在无需任何 CPU 操作的情况下通过 DMA 快速移动数据。这样节省的 CPU 资源可供其它操作使用。 &emsp;两个 DMA 控制器总共有 16 个数据流（每个控制器 8 个），每一个 DMA 控制器都用于管理一个或多个外设的存储器访问请求。每个数据流总共可以有多达 8 个通道（或称请求）。每个通道都有一个仲裁器，用于处理 DMA 请求间的优先级。 系统框图&emsp;DMA的系统框图如下所示。 主要特性&emsp;DMA的特性较为复杂，重点如下： STM32F767具有2个DMA控制器； 每个 DMA 控制器有 8 个数据流，每个数据流有多达 8 个通道(或称请求)； 每个数据流有4级32位先进先出FIFO； 通过硬件可以将每个数据流配置为：支持外设到存储器、存储器到外设和存储器到存储器传输的常规通道；在存储器端支持双缓冲的双缓冲区通道； DMA 数据流请求之间的优先级可用软件编程（4 个级别：非常高、高、中、低）； 可供每个数据流选择的通道请求多达 8 个； 要传输的数据项的数目可以由 DMA 控制器或外设管理； DMA 流控制器：要传输的数据项的数目可用软件编程，从 1 至 65535； 对源和目标的增量或非增量寻址； 5 个事件标志（DMA 半传输、DMA 传输完成、DMA 传输错误、DMA FIFO 错误、直接模式错误），进行逻辑或运算，从而产生每个数据流的单个中断请求。 DMA通道选择&emsp;DMA中每一个数据流均有一个DMA请求。DMA请求映射的列表如下所示。 DMA的基本设置&emsp;DMA的具体应用方式很多，本文以用DMA实现UART1数据发送为例讲解DMA的用法。 DMA通道选择&emsp;USART1_TX请求位于DMA2的数据流7，通道4。 DMA时钟与NVIC初始化&emsp;初始化代码如下所示。 1234567891011121314/** * Enable DMA controller clock */void MX_DMA_Init(void) &#123; /* DMA controller clock enable */ __HAL_RCC_DMA2_CLK_ENABLE(); /* DMA interrupt init */ /* DMA2_Stream7_IRQn interrupt configuration */ HAL_NVIC_SetPriority(DMA2_Stream7_IRQn, 0, 0); HAL_NVIC_EnableIRQ(DMA2_Stream7_IRQn);&#125; &emsp;代码的主要功能为： 使能DMA2时钟； 设定DMA2数据流7的NVIC优先级并使能；DMA中断优先级需要根据系统整体进行确定，本处设置只是示例。 UART初始化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/* USART1 init function */void MX_USART1_UART_Init(void)&#123; huart1.Instance = USART1; huart1.Init.BaudRate = 115200; huart1.Init.WordLength = UART_WORDLENGTH_8B; huart1.Init.StopBits = UART_STOPBITS_1; huart1.Init.Parity = UART_PARITY_NONE; huart1.Init.Mode = UART_MODE_TX_RX; huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart1.Init.OverSampling = UART_OVERSAMPLING_16; huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE; huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT; if (HAL_UART_Init(&amp;huart1) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125;&#125;void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)&#123; GPIO_InitTypeDef GPIO_InitStruct; if(uartHandle-&gt;Instance==USART1) &#123; /* USER CODE BEGIN USART1_MspInit 0 */ /* USER CODE END USART1_MspInit 0 */ /* USART1 clock enable */ __HAL_RCC_USART1_CLK_ENABLE(); /**USART1 GPIO Configuration PA9 ------&gt; USART1_TX PA10 ------&gt; USART1_RX */ GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH; GPIO_InitStruct.Alternate = GPIO_AF7_USART1; HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct); /* USART1 DMA Init */ /* USART1_TX Init */ hdma_usart1_tx.Instance = DMA2_Stream7; hdma_usart1_tx.Init.Channel = DMA_CHANNEL_4; hdma_usart1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH; hdma_usart1_tx.Init.PeriphInc = DMA_PINC_DISABLE; hdma_usart1_tx.Init.MemInc = DMA_MINC_ENABLE; hdma_usart1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE; hdma_usart1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE; hdma_usart1_tx.Init.Mode = DMA_NORMAL; hdma_usart1_tx.Init.Priority = DMA_PRIORITY_LOW; hdma_usart1_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE; if (HAL_DMA_Init(&amp;hdma_usart1_tx) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; __HAL_LINKDMA(uartHandle,hdmatx,hdma_usart1_tx); /* USART1 interrupt Init */ HAL_NVIC_SetPriority(USART1_IRQn, 0, 0); HAL_NVIC_EnableIRQ(USART1_IRQn); /* USER CODE BEGIN USART1_MspInit 1 */ /* USER CODE END USART1_MspInit 1 */ &#125;&#125; &emsp;UART的初始化串口部分之前已经介绍过，这里不再复述，DMA相关部分功能如下： 初始化实例选择为DMA2数据流7，通道4； 方向为：存储器到外设； DMA外设：非增量模式； 存储器外设：增量模式； 外设数据对齐：byte，即为8bit； 存储器数据对齐：byte，即为8bit； DMA模式：normal； DMA优先级：低； DMA FIFO模式：禁用； 通过HAL_DMA_Init()函数初始化DMA； 通过__HAL_LINKDMA()函数建立huart1与hdma_usart1_tx关联； 设置USART1 NVIC优先级并使能中断。 HAL_DMA_Init()实现&emsp;以上设置通过HAL_DMA_Init()函数实现，该函数具体如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139/** * @brief Initialize the DMA according to the specified * parameters in the DMA_InitTypeDef and create the associated handle. * @param hdma Pointer to a DMA_HandleTypeDef structure that contains * the configuration information for the specified DMA Stream. * @retval HAL status */HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)&#123; uint32_t tmp = 0U; uint32_t tickstart = HAL_GetTick(); DMA_Base_Registers *regs; /* Check the DMA peripheral state */ if(hdma == NULL) &#123; return HAL_ERROR; &#125; /* Check the parameters */ assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma-&gt;Instance)); assert_param(IS_DMA_CHANNEL(hdma-&gt;Init.Channel)); assert_param(IS_DMA_DIRECTION(hdma-&gt;Init.Direction)); assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma-&gt;Init.PeriphInc)); assert_param(IS_DMA_MEMORY_INC_STATE(hdma-&gt;Init.MemInc)); assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma-&gt;Init.PeriphDataAlignment)); assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma-&gt;Init.MemDataAlignment)); assert_param(IS_DMA_MODE(hdma-&gt;Init.Mode)); assert_param(IS_DMA_PRIORITY(hdma-&gt;Init.Priority)); assert_param(IS_DMA_FIFO_MODE_STATE(hdma-&gt;Init.FIFOMode)); /* Check the memory burst, peripheral burst and FIFO threshold parameters only when FIFO mode is enabled */ if(hdma-&gt;Init.FIFOMode != DMA_FIFOMODE_DISABLE) &#123; assert_param(IS_DMA_FIFO_THRESHOLD(hdma-&gt;Init.FIFOThreshold)); assert_param(IS_DMA_MEMORY_BURST(hdma-&gt;Init.MemBurst)); assert_param(IS_DMA_PERIPHERAL_BURST(hdma-&gt;Init.PeriphBurst)); &#125; /* Allocate lock resource */ __HAL_UNLOCK(hdma); /* Change DMA peripheral state */ hdma-&gt;State = HAL_DMA_STATE_BUSY; /* Disable the peripheral */ __HAL_DMA_DISABLE(hdma); /* Check if the DMA Stream is effectively disabled */ while((hdma-&gt;Instance-&gt;CR &amp; DMA_SxCR_EN) != RESET) &#123; /* Check for the Timeout */ if((HAL_GetTick() - tickstart ) &gt; HAL_TIMEOUT_DMA_ABORT) &#123; /* Update error code */ hdma-&gt;ErrorCode = HAL_DMA_ERROR_TIMEOUT; /* Change the DMA state */ hdma-&gt;State = HAL_DMA_STATE_TIMEOUT; return HAL_TIMEOUT; &#125; &#125; /* Get the CR register value */ tmp = hdma-&gt;Instance-&gt;CR; /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */ tmp &amp;= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \\ DMA_SxCR_PL | DMA_SxCR_MSIZE | DMA_SxCR_PSIZE | \\ DMA_SxCR_MINC | DMA_SxCR_PINC | DMA_SxCR_CIRC | \\ DMA_SxCR_DIR | DMA_SxCR_CT | DMA_SxCR_DBM)); /* Prepare the DMA Stream configuration */ tmp |= hdma-&gt;Init.Channel | hdma-&gt;Init.Direction | hdma-&gt;Init.PeriphInc | hdma-&gt;Init.MemInc | hdma-&gt;Init.PeriphDataAlignment | hdma-&gt;Init.MemDataAlignment | hdma-&gt;Init.Mode | hdma-&gt;Init.Priority; /* the Memory burst and peripheral burst are not used when the FIFO is disabled */ if(hdma-&gt;Init.FIFOMode == DMA_FIFOMODE_ENABLE) &#123; /* Get memory burst and peripheral burst */ tmp |= hdma-&gt;Init.MemBurst | hdma-&gt;Init.PeriphBurst; &#125; /* Write to DMA Stream CR register */ hdma-&gt;Instance-&gt;CR = tmp; /* Get the FCR register value */ tmp = hdma-&gt;Instance-&gt;FCR; /* Clear Direct mode and FIFO threshold bits */ tmp &amp;= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH); /* Prepare the DMA Stream FIFO configuration */ tmp |= hdma-&gt;Init.FIFOMode; /* The FIFO threshold is not used when the FIFO mode is disabled */ if(hdma-&gt;Init.FIFOMode == DMA_FIFOMODE_ENABLE) &#123; /* Get the FIFO threshold */ tmp |= hdma-&gt;Init.FIFOThreshold; /* Check compatibility between FIFO threshold level and size of the memory burst */ /* for INCR4, INCR8, INCR16 bursts */ if (hdma-&gt;Init.MemBurst != DMA_MBURST_SINGLE) &#123; if (DMA_CheckFifoParam(hdma) != HAL_OK) &#123; /* Update error code */ hdma-&gt;ErrorCode = HAL_DMA_ERROR_PARAM; /* Change the DMA state */ hdma-&gt;State = HAL_DMA_STATE_READY; return HAL_ERROR; &#125; &#125; &#125; /* Write to DMA Stream FCR */ hdma-&gt;Instance-&gt;FCR = tmp; /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */ regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma); /* Clear all interrupt flags */ regs-&gt;IFCR = 0x3FU &lt;&lt; hdma-&gt;StreamIndex; /* Initialize the error code */ hdma-&gt;ErrorCode = HAL_DMA_ERROR_NONE; /* Initialize the DMA state */ hdma-&gt;State = HAL_DMA_STATE_READY; return HAL_OK;&#125; &emsp;该函数的主要功能有： 通过DMA配置寄存器DMA_SxCR EN位复位禁止数据流，并等待确认数据流已关闭； tmp首先读取DMA_SxCR寄存器的值，同时复位所有需要配置的控制位； tmp中写入CHSEL、DIR、PINC、MINC、PSIZE、MINC、CIRC、PFCTRL、PL等配置位； 将tmp值写入到DMA_SxCR寄存器； tmp读取FIFO控制寄存器DMA_SxFCR的值，复位直接模式禁止位DMDIS与FIFO阈值选择位FTH； tmp写入FIFO模式位，本例中使用直接模式，禁用FIFO； 将tmp值写入到DMA_SxFCR寄存器； 通过DMA_HIFCR/DMA_LIFCR寄存器清除DMA所有中断标志位； 至此，完成DMA初始化。 源代码中通过0x3F清除中断标志位可能存在问题，DMA_HIFCR/DMA_LIFCR寄存器中断清除标志位仅有5个，此处我认为写入0x3D才是合理值。 ST官方回复：这个预留位，软件上写0/写1对它没有影响，这个预留动作时靠硬件保证的。 __HAL_LINKDMA()实现&emsp;该函数具体如下。 1234567__HAL_LINKDMA(uartHandle,hdmatx,hdma_usart1_tx);#define __HAL_LINKDMA(__HANDLE__, __PPP_DMA_FIELD__, __DMA_HANDLE__) \\ do&#123; \\ (__HANDLE__)-&gt;__PPP_DMA_FIELD__ = &amp;(__DMA_HANDLE__); \\ (__DMA_HANDLE__).Parent = (__HANDLE__); \\ &#125; while(0) &emsp;该函数的功能如下： __HAL_LINKDMA()传入的参数为huart1，hdmatx代表huart1结构体UART_HandleTypeDef定义中的具体成员变量，即将hdma_usart1_tx作为huart1的hdmatx成员变量；同时huart1作为hdma_usart1_tx的Parent成员变量。 基于DMA的UART发送实现HAL_UART_Transmit_DMA()实现&emsp;DMA设置完成后，即可基于DMA进行UART发送，具体通过HAL_UART_Transmit_DMA()函数实现，使用方法如下。 12uint8 sendStr[65535] = \"1234567890\";HAL_UART_Transmit_DMA(&amp;huart1,sendStr,sizeof(sendStr)); &emsp;HAL_UART_Transmit_DMA()函数的定义如下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * @brief Send an amount of data in DMA mode. * @param huart UART handle. * @param pData pointer to data buffer. * @param Size amount of data to be sent. * @retval HAL status */HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)&#123; uint32_t *tmp; /* Check that a Tx process is not already ongoing */ if(huart-&gt;gState == HAL_UART_STATE_READY) &#123; if((pData == NULL ) || (Size == 0U)) &#123; return HAL_ERROR; &#125; /* Process Locked */ __HAL_LOCK(huart); huart-&gt;pTxBuffPtr = pData; huart-&gt;TxXferSize = Size; huart-&gt;TxXferCount = Size; huart-&gt;ErrorCode = HAL_UART_ERROR_NONE; huart-&gt;gState = HAL_UART_STATE_BUSY_TX; /* Set the UART DMA transfer complete callback */ huart-&gt;hdmatx-&gt;XferCpltCallback = UART_DMATransmitCplt; /* Set the UART DMA Half transfer complete callback */ huart-&gt;hdmatx-&gt;XferHalfCpltCallback = UART_DMATxHalfCplt; /* Set the DMA error callback */ huart-&gt;hdmatx-&gt;XferErrorCallback = UART_DMAError; /* Set the DMA abort callback */ huart-&gt;hdmatx-&gt;XferAbortCallback = NULL; /* Enable the UART transmit DMA channel */ tmp = (uint32_t*)&amp;pData; HAL_DMA_Start_IT(huart-&gt;hdmatx, *(uint32_t*)tmp, (uint32_t)&amp;huart-&gt;Instance-&gt;TDR, Size); /* Clear the TC flag in the SR register by writing 0 to it */ __HAL_UART_CLEAR_IT(huart, UART_FLAG_TC); /* Process Unlocked */ __HAL_UNLOCK(huart); /* Enable the DMA transfer for transmit request by setting the DMAT bit in the UART CR3 register */ SET_BIT(huart-&gt;Instance-&gt;CR3, USART_CR3_DMAT); return HAL_OK; &#125; else &#123; return HAL_BUSY; &#125;&#125; &emsp;该函数实现的功能为： huart1的成员变量pTxBuffPtr为发送数据buffer指针，将其指向待发送数据； huart1的成员变量TxXferSize代表发送数据数目，成员变量TxXferCount代表发送数据计数器，初始值都将其设置为待发送数据个数； huart1的成员变量hdmatx也为一个结构体，其成员变量为DMA相关中断的函数指针：XferCpltCallback为DMA传输完成回调函数，XferHalfCpltCallback为DMA半传输完成回调函数，XferErrorCallback为DMA故障回调函数，XferAbortCallback为DMA中止回调函数； 通过HAL_DMA_Start_IT()使能DMA发送通道； 清除UART发送完成中断标志位TC； 置位USARTx_CR3寄存器DMAT位，使能DMA发送模式。 &emsp;执行该函数后，UART将基于DMA模式进行发送。 HAL_DMA_Start_IT()实现&emsp;HAL_UART_Transmit_DMA()中调用的核心函数HAL_DMA_Start_IT()实现如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/** * @brief Start the DMA Transfer with interrupt enabled. * @param hdma pointer to a DMA_HandleTypeDef structure that contains * the configuration information for the specified DMA Stream. * @param SrcAddress The source memory Buffer address * @param DstAddress The destination memory Buffer address * @param DataLength The length of data to be transferred from source to destination * @retval HAL status */HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)&#123; HAL_StatusTypeDef status = HAL_OK; /* calculate DMA base and stream number */ DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma-&gt;StreamBaseAddress; /* Check the parameters */ assert_param(IS_DMA_BUFFER_SIZE(DataLength)); /* Process locked */ __HAL_LOCK(hdma); if(HAL_DMA_STATE_READY == hdma-&gt;State) &#123; /* Change DMA peripheral state */ hdma-&gt;State = HAL_DMA_STATE_BUSY; /* Initialize the error code */ hdma-&gt;ErrorCode = HAL_DMA_ERROR_NONE; /* Configure the source, destination address and the data length */ DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength); /* Clear all interrupt flags at correct offset within the register */ regs-&gt;IFCR = 0x3FU &lt;&lt; hdma-&gt;StreamIndex; /* Enable Common interrupts*/ hdma-&gt;Instance-&gt;CR |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME; hdma-&gt;Instance-&gt;FCR |= DMA_IT_FE; if(hdma-&gt;XferHalfCpltCallback != NULL) &#123; hdma-&gt;Instance-&gt;CR |= DMA_IT_HT; &#125; /* Enable the Peripheral */ __HAL_DMA_ENABLE(hdma); &#125; else &#123; /* Process unlocked */ __HAL_UNLOCK(hdma); /* Return error status */ status = HAL_BUSY; &#125; return status;&#125;/** * @brief Sets the DMA Transfer parameter. * @param hdma pointer to a DMA_HandleTypeDef structure that contains * the configuration information for the specified DMA Stream. * @param SrcAddress The source memory Buffer address * @param DstAddress The destination memory Buffer address * @param DataLength The length of data to be transferred from source to destination * @retval HAL status */static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)&#123; /* Clear DBM bit */ hdma-&gt;Instance-&gt;CR &amp;= (uint32_t)(~DMA_SxCR_DBM); /* Configure DMA Stream data length */ hdma-&gt;Instance-&gt;NDTR = DataLength; /* Memory to Peripheral */ if((hdma-&gt;Init.Direction) == DMA_MEMORY_TO_PERIPH) &#123; /* Configure DMA Stream destination address */ hdma-&gt;Instance-&gt;PAR = DstAddress; /* Configure DMA Stream source address */ hdma-&gt;Instance-&gt;M0AR = SrcAddress; &#125; /* Peripheral to Memory */ else &#123; /* Configure DMA Stream source address */ hdma-&gt;Instance-&gt;PAR = SrcAddress; /* Configure DMA Stream destination address */ hdma-&gt;Instance-&gt;M0AR = DstAddress; &#125;&#125;/** * @brief Enable the specified DMA Stream. * @param __HANDLE__ DMA handle * @retval None */#define __HAL_DMA_ENABLE(__HANDLE__) ((__HANDLE__)-&gt;Instance-&gt;CR |= DMA_SxCR_EN) &emsp;该函数实现的功能为： 检查DMA发送数据长度是否合理，在1~65535范围内均可； 通过DMA_SetConfig()函数设置DMA发送的DMA数据流、数据项数目，设置外设地址为目标地址，设置存储器地址为源地址； 清空DMA数据流相关中断标志位； 置位DMA配置寄存器DMA_SxCR TCIE、TEIE、DMEIE位，分别使能传输完成中断、传输错误中断与直接模式错误中断； 置位DMA FIFO控制寄存器FEIE位，使能FIFO错误中断；本例中未使能FIFO； XferHalfCpltCallback为DMA半传输完成回调函数，其不为NULL时使能DMA半传输完成中断； 置位DMA_SxCR寄存器EN位，使能DMA数据流，随即开始DMA传输。 DMA中断服务函数&emsp;DMA中断服务函数如下所示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230/*** @brief This function handles DMA2 stream7 global interrupt.*/void DMA2_Stream7_IRQHandler(void)&#123; /* USER CODE BEGIN DMA2_Stream7_IRQn 0 */ /* USER CODE END DMA2_Stream7_IRQn 0 */ HAL_DMA_IRQHandler(&amp;hdma_usart1_tx); /* USER CODE BEGIN DMA2_Stream7_IRQn 1 */ /* USER CODE END DMA2_Stream7_IRQn 1 */&#125;/** * @brief Handles DMA interrupt request. * @param hdma pointer to a DMA_HandleTypeDef structure that contains * the configuration information for the specified DMA Stream. * @retval None */void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)&#123; uint32_t tmpisr; __IO uint32_t count = 0; uint32_t timeout = SystemCoreClock / 9600; /* calculate DMA base and stream number */ DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma-&gt;StreamBaseAddress; tmpisr = regs-&gt;ISR; /* Transfer Error Interrupt management ***************************************/ if ((tmpisr &amp; (DMA_FLAG_TEIF0_4 &lt;&lt; hdma-&gt;StreamIndex)) != RESET) &#123; if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET) &#123; /* Disable the transfer error interrupt */ hdma-&gt;Instance-&gt;CR &amp;= ~(DMA_IT_TE); /* Clear the transfer error flag */ regs-&gt;IFCR = DMA_FLAG_TEIF0_4 &lt;&lt; hdma-&gt;StreamIndex; /* Update error code */ hdma-&gt;ErrorCode |= HAL_DMA_ERROR_TE; &#125; &#125; /* FIFO Error Interrupt management ******************************************/ if ((tmpisr &amp; (DMA_FLAG_FEIF0_4 &lt;&lt; hdma-&gt;StreamIndex)) != RESET) &#123; if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET) &#123; /* Clear the FIFO error flag */ regs-&gt;IFCR = DMA_FLAG_FEIF0_4 &lt;&lt; hdma-&gt;StreamIndex; /* Update error code */ hdma-&gt;ErrorCode |= HAL_DMA_ERROR_FE; &#125; &#125; /* Direct Mode Error Interrupt management ***********************************/ if ((tmpisr &amp; (DMA_FLAG_DMEIF0_4 &lt;&lt; hdma-&gt;StreamIndex)) != RESET) &#123; if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET) &#123; /* Clear the direct mode error flag */ regs-&gt;IFCR = DMA_FLAG_DMEIF0_4 &lt;&lt; hdma-&gt;StreamIndex; /* Update error code */ hdma-&gt;ErrorCode |= HAL_DMA_ERROR_DME; &#125; &#125; /* Half Transfer Complete Interrupt management ******************************/ if ((tmpisr &amp; (DMA_FLAG_HTIF0_4 &lt;&lt; hdma-&gt;StreamIndex)) != RESET) &#123; if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET) &#123; /* Clear the half transfer complete flag */ regs-&gt;IFCR = DMA_FLAG_HTIF0_4 &lt;&lt; hdma-&gt;StreamIndex; /* Multi_Buffering mode enabled */ if(((hdma-&gt;Instance-&gt;CR) &amp; (uint32_t)(DMA_SxCR_DBM)) != RESET) &#123; /* Current memory buffer used is Memory 0 */ if((hdma-&gt;Instance-&gt;CR &amp; DMA_SxCR_CT) == RESET) &#123; if(hdma-&gt;XferHalfCpltCallback != NULL) &#123; /* Half transfer callback */ hdma-&gt;XferHalfCpltCallback(hdma); &#125; &#125; /* Current memory buffer used is Memory 1 */ else &#123; if(hdma-&gt;XferM1HalfCpltCallback != NULL) &#123; /* Half transfer callback */ hdma-&gt;XferM1HalfCpltCallback(hdma); &#125; &#125; &#125; else &#123; /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */ if((hdma-&gt;Instance-&gt;CR &amp; DMA_SxCR_CIRC) == RESET) &#123; /* Disable the half transfer interrupt */ hdma-&gt;Instance-&gt;CR &amp;= ~(DMA_IT_HT); &#125; if(hdma-&gt;XferHalfCpltCallback != NULL) &#123; /* Half transfer callback */ hdma-&gt;XferHalfCpltCallback(hdma); &#125; &#125; &#125; &#125; /* Transfer Complete Interrupt management ***********************************/ if ((tmpisr &amp; (DMA_FLAG_TCIF0_4 &lt;&lt; hdma-&gt;StreamIndex)) != RESET) &#123; if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET) &#123; /* Clear the transfer complete flag */ regs-&gt;IFCR = DMA_FLAG_TCIF0_4 &lt;&lt; hdma-&gt;StreamIndex; if(HAL_DMA_STATE_ABORT == hdma-&gt;State) &#123; /* Disable all the transfer interrupts */ hdma-&gt;Instance-&gt;CR &amp;= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME); hdma-&gt;Instance-&gt;FCR &amp;= ~(DMA_IT_FE); if((hdma-&gt;XferHalfCpltCallback != NULL) || (hdma-&gt;XferM1HalfCpltCallback != NULL)) &#123; hdma-&gt;Instance-&gt;CR &amp;= ~(DMA_IT_HT); &#125; /* Clear all interrupt flags at correct offset within the register */ regs-&gt;IFCR = 0x3FU &lt;&lt; hdma-&gt;StreamIndex; /* Process Unlocked */ __HAL_UNLOCK(hdma); /* Change the DMA state */ hdma-&gt;State = HAL_DMA_STATE_READY; if(hdma-&gt;XferAbortCallback != NULL) &#123; hdma-&gt;XferAbortCallback(hdma); &#125; return; &#125; if(((hdma-&gt;Instance-&gt;CR) &amp; (uint32_t)(DMA_SxCR_DBM)) != RESET) &#123; /* Current memory buffer used is Memory 0 */ if((hdma-&gt;Instance-&gt;CR &amp; DMA_SxCR_CT) == RESET) &#123; if(hdma-&gt;XferM1CpltCallback != NULL) &#123; /* Transfer complete Callback for memory1 */ hdma-&gt;XferM1CpltCallback(hdma); &#125; &#125; /* Current memory buffer used is Memory 1 */ else &#123; if(hdma-&gt;XferCpltCallback != NULL) &#123; /* Transfer complete Callback for memory0 */ hdma-&gt;XferCpltCallback(hdma); &#125; &#125; &#125; /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */ else &#123; if((hdma-&gt;Instance-&gt;CR &amp; DMA_SxCR_CIRC) == RESET) &#123; /* Disable the transfer complete interrupt */ hdma-&gt;Instance-&gt;CR &amp;= ~(DMA_IT_TC); /* Process Unlocked */ __HAL_UNLOCK(hdma); /* Change the DMA state */ hdma-&gt;State = HAL_DMA_STATE_READY; &#125; if(hdma-&gt;XferCpltCallback != NULL) &#123; /* Transfer complete callback */ hdma-&gt;XferCpltCallback(hdma); &#125; &#125; &#125; &#125; /* manage error case */ if(hdma-&gt;ErrorCode != HAL_DMA_ERROR_NONE) &#123; if((hdma-&gt;ErrorCode &amp; HAL_DMA_ERROR_TE) != RESET) &#123; hdma-&gt;State = HAL_DMA_STATE_ABORT; /* Disable the stream */ __HAL_DMA_DISABLE(hdma); do &#123; if (++count &gt; timeout) &#123; break; &#125; &#125; while((hdma-&gt;Instance-&gt;CR &amp; DMA_SxCR_EN) != RESET); /* Process Unlocked */ __HAL_UNLOCK(hdma); /* Change the DMA state */ hdma-&gt;State = HAL_DMA_STATE_READY; &#125; if(hdma-&gt;XferErrorCallback != NULL) &#123; /* Transfer error callback */ hdma-&gt;XferErrorCallback(hdma); &#125; &#125;&#125; &emsp;该函数中主要关注半传输完成中断以及传输完成中断。 &emsp;对于半传输完成中断相关函数，其主要功能有： 清除半传输完成中断标志位； DMA_SxCR寄存器DBM位为复位状态，双缓冲器模式未使能； DMA_SxCR寄存器CIRC位为复位状态，循环模式为禁止状态；禁用DMA半传输中断； 本例中半传输完成中断回调函数为空函数，不执行任何操作。 &emsp;对于传输完成中断相关函数，其主要功能有： 清除传输完成中断标志位； 如果DMA状态为ABORT，禁用所有DMA中断，清除所有中断标志位，并调用ABORT回调函数； DMA_SxCR寄存器DBM位为复位状态，双缓冲器模式未使能； DMA_SxCR寄存器CIRC位为复位状态，循环模式为禁止状态； 调用传输完成中断回调函数UART_DMATransmitCplt()，该函数具体如下。 123456789101112131415161718192021222324252627/** * @brief DMA UART transmit process complete callback * @param hdma DMA handle * @retval None */static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)&#123; UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)-&gt;Parent; /* DMA Normal mode*/ if((hdma-&gt;Instance-&gt;CR &amp; DMA_SxCR_CIRC) == 0U) &#123; huart-&gt;TxXferCount = 0U; /* Disable the DMA transfer for transmit request by setting the DMAT bit in the UART CR3 register */ CLEAR_BIT(huart-&gt;Instance-&gt;CR3, USART_CR3_DMAT); /* Enable the UART Transmit Complete Interrupt */ SET_BIT(huart-&gt;Instance-&gt;CR1, USART_CR1_TCIE); &#125; /* DMA Circular mode */ else &#123; HAL_UART_TxCpltCallback(huart); &#125;&#125; &emsp;UART_DMATransmitCplt()的功能如下： 本例中DMA模式为Normal； DMA发送计数器置零； 禁止DMA发送模式； 通过置位USARTx_CR1寄存器TCIE位，软件产生一个UART传输完成中断。 UART中断服务函数&emsp;UART中断服务函数如下所示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185/*** @brief This function handles USART1 global interrupt.*/void USART1_IRQHandler(void)&#123; /* USER CODE BEGIN USART1_IRQn 0 */ /* USER CODE END USART1_IRQn 0 */ HAL_UART_IRQHandler(&amp;huart1); /* USER CODE BEGIN USART1_IRQn 1 */ /* USER CODE END USART1_IRQn 1 */&#125;/** * @brief This function handles UART interrupt request. * @param huart uart handle * @retval None */void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)&#123; uint32_t isrflags = READ_REG(huart-&gt;Instance-&gt;ISR); uint32_t cr1its = READ_REG(huart-&gt;Instance-&gt;CR1); uint32_t cr3its = READ_REG(huart-&gt;Instance-&gt;CR3); uint32_t errorflags; /* If no error occurs */ errorflags = (isrflags &amp; (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE)); if (errorflags == RESET) &#123; /* UART in mode Receiver ---------------------------------------------------*/ if(((isrflags &amp; USART_ISR_RXNE) != RESET) &amp;&amp; ((cr1its &amp; USART_CR1_RXNEIE) != RESET)) &#123; UART_Receive_IT(huart); return; &#125; &#125; /* If some errors occur */ if( (errorflags != RESET) &amp;&amp; ( ((cr3its &amp; USART_CR3_EIE) != RESET) || ((cr1its &amp; (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)) ) &#123; /* UART parity error interrupt occurred -------------------------------------*/ if(((isrflags &amp; USART_ISR_PE) != RESET) &amp;&amp; ((cr1its &amp; USART_CR1_PEIE) != RESET)) &#123; __HAL_UART_CLEAR_IT(huart, UART_CLEAR_PEF); huart-&gt;ErrorCode |= HAL_UART_ERROR_PE; &#125; /* UART frame error interrupt occurred --------------------------------------*/ if(((isrflags &amp; USART_ISR_FE) != RESET) &amp;&amp; ((cr3its &amp; USART_CR3_EIE) != RESET)) &#123; __HAL_UART_CLEAR_IT(huart, UART_CLEAR_FEF); huart-&gt;ErrorCode |= HAL_UART_ERROR_FE; &#125; /* UART noise error interrupt occurred --------------------------------------*/ if(((isrflags &amp; USART_ISR_NE) != RESET) &amp;&amp; ((cr3its &amp; USART_CR3_EIE) != RESET)) &#123; __HAL_UART_CLEAR_IT(huart, UART_CLEAR_NEF); huart-&gt;ErrorCode |= HAL_UART_ERROR_NE; &#125; /* UART Over-Run interrupt occurred -----------------------------------------*/ if(((isrflags &amp; USART_ISR_ORE) != RESET) &amp;&amp; (((cr1its &amp; USART_CR1_RXNEIE) != RESET) || ((cr3its &amp; USART_CR3_EIE) != RESET))) &#123; __HAL_UART_CLEAR_IT(huart, UART_CLEAR_OREF); huart-&gt;ErrorCode |= HAL_UART_ERROR_ORE; &#125; /* Call UART Error Call back function if need be --------------------------*/ if(huart-&gt;ErrorCode != HAL_UART_ERROR_NONE) &#123; /* UART in mode Receiver ---------------------------------------------------*/ if(((isrflags &amp; USART_ISR_RXNE) != RESET) &amp;&amp; ((cr1its &amp; USART_CR1_RXNEIE) != RESET)) &#123; UART_Receive_IT(huart); &#125; /* If Overrun error occurs, or if any error occurs in DMA mode reception, consider error as blocking */ if (((huart-&gt;ErrorCode &amp; HAL_UART_ERROR_ORE) != RESET) || (HAL_IS_BIT_SET(huart-&gt;Instance-&gt;CR3, USART_CR3_DMAR))) &#123; /* Blocking error : transfer is aborted Set the UART state ready to be able to start again the process, Disable Rx Interrupts, and disable Rx DMA request, if ongoing */ UART_EndRxTransfer(huart); /* Disable the UART DMA Rx request if enabled */ if (HAL_IS_BIT_SET(huart-&gt;Instance-&gt;CR3, USART_CR3_DMAR)) &#123; CLEAR_BIT(huart-&gt;Instance-&gt;CR3, USART_CR3_DMAR); /* Abort the UART DMA Rx channel */ if(huart-&gt;hdmarx != NULL) &#123; /* Set the UART DMA Abort callback : will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */ huart-&gt;hdmarx-&gt;XferAbortCallback = UART_DMAAbortOnError; /* Abort DMA RX */ if(HAL_DMA_Abort_IT(huart-&gt;hdmarx) != HAL_OK) &#123; /* Call Directly huart-&gt;hdmarx-&gt;XferAbortCallback function in case of error */ huart-&gt;hdmarx-&gt;XferAbortCallback(huart-&gt;hdmarx); &#125; &#125; else &#123; /* Call user error callback */ HAL_UART_ErrorCallback(huart); &#125; &#125; else &#123; /* Call user error callback */ HAL_UART_ErrorCallback(huart); &#125; &#125; else &#123; /* Non Blocking error : transfer could go on. Error is notified to user through user error callback */ HAL_UART_ErrorCallback(huart); huart-&gt;ErrorCode = HAL_UART_ERROR_NONE; &#125; &#125; return; &#125; /* End if some error occurs */ /* UART in mode Transmitter ------------------------------------------------*/ if(((isrflags &amp; USART_ISR_TXE) != RESET) &amp;&amp; ((cr1its &amp; USART_CR1_TXEIE) != RESET)) &#123; UART_Transmit_IT(huart); return; &#125; /* UART in mode Transmitter (transmission end) -----------------------------*/ if(((isrflags &amp; USART_ISR_TC) != RESET) &amp;&amp; ((cr1its &amp; USART_CR1_TCIE) != RESET)) &#123; UART_EndTransmit_IT(huart); return; &#125;&#125;/** * @brief Wrap up transmission in non-blocking mode. * @param huart pointer to a UART_HandleTypeDef structure that contains * the configuration information for the specified UART module. * @retval HAL status */static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)&#123; /* Disable the UART Transmit Complete Interrupt */ CLEAR_BIT(huart-&gt;Instance-&gt;CR1, USART_CR1_TCIE); /* Tx process is ended, restore huart-&gt;gState to Ready */ huart-&gt;gState = HAL_UART_STATE_READY; HAL_UART_TxCpltCallback(huart); return HAL_OK;&#125;/** * @brief Tx Transfer completed callbacks * @param huart uart handle * @retval None */extern uint8_t uartReady;void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)&#123; uartReady = 1;&#125; &emsp;这里主要关注中断传输完成中断： TC软件置位产生的中断传输完成中断中调用UART_EndTransmit_IT()函数； UART_EndTransmit_IT()函数复位USARTx_CR1寄存器TCIE位，禁止传输完成中断；继而调用HAL_UART_TxCpltCallback()函数； HAL_UART_TxCpltCallback()函数为自定义函数。 实验验证&emsp;验证程序设置如下： 12345678910111213141516uint8 sendStr[65535] = \"1234567890\";uint8 uartReady = 1;while (1)&#123; mainloop++; oled_putuint32(0, 2, mainloop); oled_putuint32(0, 3, __HAL_DMA_GET_COUNTER(&amp;hdma_usart1_tx)); if (uartReady == TRUE) &#123; uartReady = FALSE; test = HAL_UART_Transmit_DMA(&amp;huart1,sendStr,sizeof(sendStr)); &#125; &#125; &emsp;其基本原理为调用HAL_UART_Transmit_DMA()函数进行发送，同时通过__HAL_DMA_GET_COUNTER()获取DMA数据流传输中的剩余数据数目并实时显示。当DMA发送完成并通过TC为触发UART中断后，将uartReady置位，此时可以进行新一轮DMA传输。 &emsp;实验结果为：OLED显示器实时显示DMA数据流传输的剩余数据数目；串口接收软件可以接收到发送的数据(但是由于数据流速率过高，串口软件有时无法正常显示)。","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://jiaodi.tech/categories/嵌入式/"}],"tags":[{"name":"STM32F7","slug":"STM32F7","permalink":"http://jiaodi.tech/tags/STM32F7/"},{"name":"DMA","slug":"DMA","permalink":"http://jiaodi.tech/tags/DMA/"}]},{"title":"STM32F767 PWM的基本用法","slug":"stm32f767-pwm","date":"2018-05-07T12:18:11.000Z","updated":"2018-05-12T16:28:42.383Z","comments":true,"path":"2018/05/07/stm32f767-pwm/","link":"","permalink":"http://jiaodi.tech/2018/05/07/stm32f767-pwm/","excerpt":"&emsp;本文介绍STM32F767 PWM的基本用法。","text":"&emsp;本文介绍STM32F767 PWM的基本用法。 开发环境硬件环境 电脑：Windows 10 Home x64 Apollo STM32F767开发板(ST-LINK V2仿真器) 软件环境 Keil Version 5.24.1 (Pack Installer：Keil.STM32F7xx_DFP.2.9.0.pack) STM32CubeMX Version 4.25.0(Packages Manager：STM32CubeF7) TIM1主要特性&emsp;TIM1/TIM8为高级控制定时器，支持的PWM功能最为完善。本例将使用TIM1完成PWM实验：输出3对互补并带有死区的PWM。 系统框图 主要特性&emsp;本次主要列出PWM的相关特性。 多达6个独立通道，可以用于PWM生成(边沿与中心对齐模式)； 带可编程死区的互补输出； 2个断路输出，用于将定时器的输出信号置于用户可选的安全配置中。 PWM的基本用法PWM参数设置&emsp;PWM的初始化代码总体如下所示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/* TIM1 init function */void MX_TIM1_Init(void)&#123; TIM_ClockConfigTypeDef sClockSourceConfig; TIM_MasterConfigTypeDef sMasterConfig; TIM_OC_InitTypeDef sConfigOC; TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig; htim1.Instance = TIM1; htim1.Init.Prescaler = 216-1; htim1.Init.CounterMode = TIM_COUNTERMODE_UP; htim1.Init.Period = 100-1; htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1; htim1.Init.RepetitionCounter = 0; htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE; if (HAL_TIM_Base_Init(&amp;htim1) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL; if (HAL_TIM_ConfigClockSource(&amp;htim1, &amp;sClockSourceConfig) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; if (HAL_TIM_PWM_Init(&amp;htim1) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET; sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET; sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE; if (HAL_TIMEx_MasterConfigSynchronization(&amp;htim1, &amp;sMasterConfig) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; sConfigOC.OCMode = TIM_OCMODE_PWM1; sConfigOC.Pulse = 20; sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH; sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH; sConfigOC.OCFastMode = TIM_OCFAST_DISABLE; sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET; sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET; if (HAL_TIM_PWM_ConfigChannel(&amp;htim1, &amp;sConfigOC, TIM_CHANNEL_1) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; sConfigOC.Pulse = 30; if (HAL_TIM_PWM_ConfigChannel(&amp;htim1, &amp;sConfigOC, TIM_CHANNEL_2) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; sConfigOC.Pulse = 40; sConfigOC.OCPolarity = TIM_OCPOLARITY_LOW; sConfigOC.OCNPolarity = TIM_OCPOLARITY_LOW; if (HAL_TIM_PWM_ConfigChannel(&amp;htim1, &amp;sConfigOC, TIM_CHANNEL_3) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE; sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE; sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF; sBreakDeadTimeConfig.DeadTime = 100; sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE; sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH; sBreakDeadTimeConfig.BreakFilter = 0; sBreakDeadTimeConfig.Break2State = TIM_BREAK2_DISABLE; sBreakDeadTimeConfig.Break2Polarity = TIM_BREAK2POLARITY_HIGH; sBreakDeadTimeConfig.Break2Filter = 0; sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE; if (HAL_TIMEx_ConfigBreakDeadTime(&amp;htim1, &amp;sBreakDeadTimeConfig) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; HAL_TIM_MspPostInit(&amp;htim1);&#125; &emsp;以下将对代码进行分析。 时基初始化&emsp;时基初始化函数如下所示。 1234567891011htim1.Instance = TIM1;htim1.Init.Prescaler = 216-1;htim1.Init.CounterMode = TIM_COUNTERMODE_UP;htim1.Init.Period = 100-1;htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;htim1.Init.RepetitionCounter = 0;htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;if (HAL_TIM_Base_Init(&amp;htim1) != HAL_OK)&#123; _Error_Handler(__FILE__, __LINE__);&#125; &emsp;时基单元的初始化在timer实验中已经介绍，这里不再叙述，其功能如下： TIM1使用APB2时钟，本例中APB2时钟频率为216MHz； 定时器周期值为100-1，则一个周期内共计数100次； 定时器预分频器值为216-1，则时钟频率为1MHz； 定时器时钟频率为1MHz，计数值为100，则定时器周期/PWM频率为10kHz； TIMx_CR1寄存器CKD位为0，则死区时钟相对于TIM输入时钟不分频。 时钟源选择&emsp;时钟源的选择通过如下函数实现。本例中时钟选择为内部时钟，即将TIMx_SMCR寄存器SMS控制位设置为0000。 12345sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;if (HAL_TIM_ConfigClockSource(&amp;htim1, &amp;sClockSourceConfig) != HAL_OK)&#123; _Error_Handler(__FILE__, __LINE__);&#125; PWM初始化&emsp;PWM初始化代码如下所示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657if (HAL_TIM_PWM_Init(&amp;htim1) != HAL_OK)&#123; _Error_Handler(__FILE__, __LINE__);&#125;/** * @brief Initializes the TIM PWM Time Base according to the specified * parameters in the TIM_HandleTypeDef and create the associated handle. * @param htim pointer to a TIM_HandleTypeDef structure that contains * the configuration information for TIM module. * @retval HAL status */HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)&#123; /* Check the TIM handle allocation */ if(htim == NULL) &#123; return HAL_ERROR; &#125; /* Check the parameters */ assert_param(IS_TIM_INSTANCE(htim-&gt;Instance)); assert_param(IS_TIM_COUNTER_MODE(htim-&gt;Init.CounterMode)); assert_param(IS_TIM_CLOCKDIVISION_DIV(htim-&gt;Init.ClockDivision)); assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim-&gt;Init.AutoReloadPreload)); if(htim-&gt;State == HAL_TIM_STATE_RESET) &#123; /* Allocate lock resource and initialize it */ htim-&gt;Lock = HAL_UNLOCKED;#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1) /* Reset interrupt callbacks to legacy week callbacks */ TIM_ResetCallback(htim); if(htim-&gt;PWM_MspInitCallback == NULL) &#123; htim-&gt;PWM_MspInitCallback = HAL_TIM_PWM_MspInit; &#125; /* Init the low level hardware : GPIO, CLOCK, NVIC */ htim-&gt;PWM_MspInitCallback(htim);#else /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */ HAL_TIM_PWM_MspInit(htim);#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */ &#125; /* Set the TIM state */ htim-&gt;State= HAL_TIM_STATE_BUSY; /* Init the base time for the PWM */ TIM_Base_SetConfig(htim-&gt;Instance, &amp;htim-&gt;Init); /* Initialize the TIM state*/ htim-&gt;State= HAL_TIM_STATE_READY; return HAL_OK;&#125; &emsp;实际上该函数并无实际意义。 htim-&gt;State在TIM时基初始化中已经更改为HAL_TIM_STATE_READY，所以判定条件以内函数不执行； TIM_Base_SetConfig()函数已经在HAL_TIM_Base_Init()中首次调用，这里为二次调用，这期间时基配置并未进行任何更新。 主模式设置&emsp;主模式设置代码如下所示。 1234567sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;if (HAL_TIMEx_MasterConfigSynchronization(&amp;htim1, &amp;sMasterConfig) != HAL_OK)&#123; _Error_Handler(__FILE__, __LINE__);&#125; &emsp;TIM1的主模式输出均为RESET状态，即只能通过寄存器TIMx_EGR的UG位生成更新事件。TIM1不进行主从模式控制。 PWM通道配置&emsp;PWM通道配置代码如下所示，这里以channel1为例。 12345678910111213141516171819202122232425sConfigOC.OCMode = TIM_OCMODE_PWM1;sConfigOC.Pulse = 20;sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;if (HAL_TIM_PWM_ConfigChannel(&amp;htim1, &amp;sConfigOC, TIM_CHANNEL_1) != HAL_OK)&#123; _Error_Handler(__FILE__, __LINE__);&#125;sConfigOC.Pulse = 30;if (HAL_TIM_PWM_ConfigChannel(&amp;htim1, &amp;sConfigOC, TIM_CHANNEL_2) != HAL_OK)&#123; _Error_Handler(__FILE__, __LINE__);&#125;sConfigOC.Pulse = 40;sConfigOC.OCPolarity = TIM_OCPOLARITY_LOW;sConfigOC.OCNPolarity = TIM_OCPOLARITY_LOW;if (HAL_TIM_PWM_ConfigChannel(&amp;htim1, &amp;sConfigOC, TIM_CHANNEL_3) != HAL_OK)&#123; _Error_Handler(__FILE__, __LINE__);&#125; &emsp;初始化代码配置了PWM的基本参数： 模式为TIM_OCMODE_PWM1； 脉冲宽度为20，考虑到周期值为100，如果不考虑死区即占空比为20%； OC与OCN的极性均为高电平； 禁用FastMode； 空闲状态下为低电平。 &emsp;PWM参数的配置通过HAL_TIM_PWM_ConfigChannel()函数实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163/** * @brief Initializes the TIM PWM channels according to the specified * parameters in the TIM_OC_InitTypeDef. * @param htim pointer to a TIM_HandleTypeDef structure that contains * the configuration information for TIM module. * @param sConfig TIM PWM configuration structure * @param Channel TIM Channels to be enabled. * This parameter can be one of the following values: * @arg TIM_CHANNEL_1: TIM Channel 1 selected * @arg TIM_CHANNEL_2: TIM Channel 2 selected * @arg TIM_CHANNEL_3: TIM Channel 3 selected * @arg TIM_CHANNEL_4: TIM Channel 4 selected * @retval HAL status */__weak HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)&#123; __HAL_LOCK(htim); /* Check the parameters */ assert_param(IS_TIM_CHANNELS(Channel)); assert_param(IS_TIM_PWM_MODE(sConfig-&gt;OCMode)); assert_param(IS_TIM_OC_POLARITY(sConfig-&gt;OCPolarity)); assert_param(IS_TIM_FAST_STATE(sConfig-&gt;OCFastMode)); htim-&gt;State = HAL_TIM_STATE_BUSY; switch (Channel) &#123; case TIM_CHANNEL_1: &#123; assert_param(IS_TIM_CC1_INSTANCE(htim-&gt;Instance)); /* Configure the Channel 1 in PWM mode */ TIM_OC1_SetConfig(htim-&gt;Instance, sConfig); /* Set the Preload enable bit for channel1 */ htim-&gt;Instance-&gt;CCMR1 |= TIM_CCMR1_OC1PE; /* Configure the Output Fast mode */ htim-&gt;Instance-&gt;CCMR1 &amp;= ~TIM_CCMR1_OC1FE; htim-&gt;Instance-&gt;CCMR1 |= sConfig-&gt;OCFastMode; &#125; break; case TIM_CHANNEL_2: &#123; assert_param(IS_TIM_CC2_INSTANCE(htim-&gt;Instance)); /* Configure the Channel 2 in PWM mode */ TIM_OC2_SetConfig(htim-&gt;Instance, sConfig); /* Set the Preload enable bit for channel2 */ htim-&gt;Instance-&gt;CCMR1 |= TIM_CCMR1_OC2PE; /* Configure the Output Fast mode */ htim-&gt;Instance-&gt;CCMR1 &amp;= ~TIM_CCMR1_OC2FE; htim-&gt;Instance-&gt;CCMR1 |= sConfig-&gt;OCFastMode &lt;&lt; 8; &#125; break; case TIM_CHANNEL_3: &#123; assert_param(IS_TIM_CC3_INSTANCE(htim-&gt;Instance)); /* Configure the Channel 3 in PWM mode */ TIM_OC3_SetConfig(htim-&gt;Instance, sConfig); /* Set the Preload enable bit for channel3 */ htim-&gt;Instance-&gt;CCMR2 |= TIM_CCMR2_OC3PE; /* Configure the Output Fast mode */ htim-&gt;Instance-&gt;CCMR2 &amp;= ~TIM_CCMR2_OC3FE; htim-&gt;Instance-&gt;CCMR2 |= sConfig-&gt;OCFastMode; &#125; break; case TIM_CHANNEL_4: &#123; assert_param(IS_TIM_CC4_INSTANCE(htim-&gt;Instance)); /* Configure the Channel 4 in PWM mode */ TIM_OC4_SetConfig(htim-&gt;Instance, sConfig); /* Set the Preload enable bit for channel4 */ htim-&gt;Instance-&gt;CCMR2 |= TIM_CCMR2_OC4PE; /* Configure the Output Fast mode */ htim-&gt;Instance-&gt;CCMR2 &amp;= ~TIM_CCMR2_OC4FE; htim-&gt;Instance-&gt;CCMR2 |= sConfig-&gt;OCFastMode &lt;&lt; 8; &#125; break; default: break; &#125; htim-&gt;State = HAL_TIM_STATE_READY; __HAL_UNLOCK(htim); return HAL_OK;&#125;/** * @brief Time Output Compare 1 configuration * @param TIMx to select the TIM peripheral * @param OC_Config The output configuration structure * @retval None */void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)&#123; uint32_t tmpccmrx = 0; uint32_t tmpccer = 0; uint32_t tmpcr2 = 0; /* Disable the Channel 1: Reset the CC1E Bit */ TIMx-&gt;CCER &amp;= ~TIM_CCER_CC1E; /* Get the TIMx CCER register value */ tmpccer = TIMx-&gt;CCER; /* Get the TIMx CR2 register value */ tmpcr2 = TIMx-&gt;CR2; /* Get the TIMx CCMR1 register value */ tmpccmrx = TIMx-&gt;CCMR1; /* Reset the Output Compare Mode Bits */ tmpccmrx &amp;= ~TIM_CCMR1_OC1M; tmpccmrx &amp;= ~TIM_CCMR1_CC1S; /* Select the Output Compare Mode */ tmpccmrx |= OC_Config-&gt;OCMode; /* Reset the Output Polarity level */ tmpccer &amp;= ~TIM_CCER_CC1P; /* Set the Output Compare Polarity */ tmpccer |= OC_Config-&gt;OCPolarity; if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET) &#123; /* Reset the Output N Polarity level */ tmpccer &amp;= ~TIM_CCER_CC1NP; /* Set the Output N Polarity */ tmpccer |= OC_Config-&gt;OCNPolarity; /* Reset the Output N State */ tmpccer &amp;= ~TIM_CCER_CC1NE; /* Reset the Output Compare and Output Compare N IDLE State */ tmpcr2 &amp;= ~TIM_CR2_OIS1; tmpcr2 &amp;= ~TIM_CR2_OIS1N; /* Set the Output Idle state */ tmpcr2 |= OC_Config-&gt;OCIdleState; /* Set the Output N Idle state */ tmpcr2 |= OC_Config-&gt;OCNIdleState; &#125; /* Write to TIMx CR2 */ TIMx-&gt;CR2 = tmpcr2; /* Write to TIMx CCMR1 */ TIMx-&gt;CCMR1 = tmpccmrx; /* Set the Capture Compare Register value */ TIMx-&gt;CCR1 = OC_Config-&gt;Pulse; /* Write to TIMx CCER */ TIMx-&gt;CCER = tmpccer; &#125; &emsp;代码功能如下： TIMx-&gt;CCER寄存器CC1E位复位，禁用OC1； tmpccer保存TIMx-&gt;CCER值，tmpcr2保存TIMx-&gt;CR2值，tmpccmrx保存TIMx-&gt;CCMR1值； tmpccmrx复位OC1M与CC1S位；CC1S被复位后，代表OC1通道被设置为输出模式； tmpccmrx写入OCMode，本例中OCMode配置为TIM_OCMODE_PWM1，即对应OC1M配置为0b0110，即为PWM模式1：当计数器处于增计数时，TIMx_CNT&lt;TIMx_CCR1时channel1为active； tmpccer复位CC1P，并写入active状态的电平，本例为active对应高电平； TIM1为高级控制定时器，可以输出互补PWM，则有tmpccer复位CC1NP位，并写入active状态的电平，本例为active对应高电平； tmpccer复位CC1NE位，则OC1N输出关闭； tmpcr2复位OIS1与OIS1N位，并写入OC输出空闲的状态，本例对应均为输出空闲状态为复位状态； TIMx-&gt;CR2寄存器写入tmpcr2值； TIMx-&gt;CCMR1寄存器写入tmpccmrx值； TIMx-&gt;CCR1寄存器写入脉宽值，决定了PWM的占空比； TIMx-&gt;CCER寄存器写入tmpccer值； TIMx-&gt;CCMR1寄存器置位OC1PE位，使能OC1预装载； TIMx-&gt;CCMR1寄存器复位OC1PE并写入OCFastMode值，本例为禁止fast模式。fast模式进对于输入比较有效，此处配置无意义； 注意channel1与channel2配置OC有效电平为高电平，channel3配置OC有效电平为低电平； Break与DeadTime配置&emsp;Break与DeadTime配置代码如下所示。其中最主要的设置为设置死区时间为100。 &emsp;在时基初始化中，PWM死区的时钟相对TIM输入时钟不进行分频，本例中即为216MHz(PWM死区的时钟周期定义为Tdts)。死区的设置通过TIMx_BDTR寄存器的DTG位实现： $DTG[7:5]=0xx$时，$DT=DTG[7:0] \\cdot Tdt$g，其中 $Tdtg=Tdts$，则等效可以设置的$Tdts$周期数为0~127； $DTG[7:5]=10x$时，$DT=(64+DTG[5:0]) \\cdot Tdtg$，其中$Tdtg=2 \\cdot Tdts$，则等效可以设置的$Tdts$周期数为128~254； $DTG[7:5]=11x$时，$DT=(32+DTG[ 4:0]) \\cdot Tdtg$，其中$Tdtg=8 \\cdot Tdts$，则等效可以设置的$Tdts$周期数为256~504； $DTG[7:5]=111$时，$DT=(32+DTG[ 4:0]) \\cdot Tdtg$，其中$Tdtg= 16 \\cdot Tdts$，则等效可以设置的$Tdts$周期数为512~1008； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;sBreakDeadTimeConfig.DeadTime = 100;sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;sBreakDeadTimeConfig.BreakFilter = 0;sBreakDeadTimeConfig.Break2State = TIM_BREAK2_DISABLE;sBreakDeadTimeConfig.Break2Polarity = TIM_BREAK2POLARITY_HIGH;sBreakDeadTimeConfig.Break2Filter = 0;sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;if (HAL_TIMEx_ConfigBreakDeadTime(&amp;htim1, &amp;sBreakDeadTimeConfig) != HAL_OK)&#123; _Error_Handler(__FILE__, __LINE__);&#125;/** * @brief Configures the Break feature, dead time, Lock level, OSSI/OSSR State * and the AOE(automatic output enable). * @param htim pointer to a TIM_HandleTypeDef structure that contains * the configuration information for TIM module. * @param sBreakDeadTimeConfig pointer to a TIM_ConfigBreakDeadConfig_TypeDef structure that * contains the BDTR Register configuration information for the TIM peripheral. * @retval HAL status */ HAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim, TIM_BreakDeadTimeConfigTypeDef * sBreakDeadTimeConfig)&#123; uint32_t tmpbdtr = 0; /* Check the parameters */ assert_param(IS_TIM_BREAK_INSTANCE(htim-&gt;Instance)); assert_param(IS_TIM_OSSR_STATE(sBreakDeadTimeConfig-&gt;OffStateRunMode)); assert_param(IS_TIM_OSSI_STATE(sBreakDeadTimeConfig-&gt;OffStateIDLEMode)); assert_param(IS_TIM_LOCK_LEVEL(sBreakDeadTimeConfig-&gt;LockLevel)); assert_param(IS_TIM_DEADTIME(sBreakDeadTimeConfig-&gt;DeadTime)); assert_param(IS_TIM_BREAK_STATE(sBreakDeadTimeConfig-&gt;BreakState)); assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig-&gt;BreakPolarity)); assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig-&gt;BreakFilter)); assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig-&gt;AutomaticOutput)); assert_param(IS_TIM_BREAK2_STATE(sBreakDeadTimeConfig-&gt;Break2State)); assert_param(IS_TIM_BREAK2_POLARITY(sBreakDeadTimeConfig-&gt;Break2Polarity)); assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig-&gt;Break2Filter)); /* Check input state */ __HAL_LOCK(htim); /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State, the OSSI State, the dead time value and the Automatic Output Enable Bit */ /* Set the BDTR bits */ MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig-&gt;DeadTime); MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig-&gt;LockLevel); MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig-&gt;OffStateIDLEMode); MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig-&gt;OffStateRunMode); MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig-&gt;BreakState); MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig-&gt;BreakPolarity); MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig-&gt;AutomaticOutput); MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, sBreakDeadTimeConfig-&gt;AutomaticOutput); MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, (sBreakDeadTimeConfig-&gt;BreakFilter &lt;&lt; BDTR_BKF_SHIFT)); if (IS_TIM_BKIN2_INSTANCE(htim-&gt;Instance)) &#123; assert_param(IS_TIM_BREAK2_STATE(sBreakDeadTimeConfig-&gt;Break2State)); assert_param(IS_TIM_BREAK2_POLARITY(sBreakDeadTimeConfig-&gt;Break2Polarity)); assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig-&gt;Break2Filter)); /* Set the BREAK2 input related BDTR bits */ MODIFY_REG(tmpbdtr, TIM_BDTR_BK2F, (sBreakDeadTimeConfig-&gt;Break2Filter &lt;&lt; BDTR_BK2F_SHIFT)); MODIFY_REG(tmpbdtr, TIM_BDTR_BK2E, sBreakDeadTimeConfig-&gt;Break2State); MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, sBreakDeadTimeConfig-&gt;Break2Polarity); &#125; /* Set TIMx_BDTR */ htim-&gt;Instance-&gt;BDTR = tmpbdtr; __HAL_UNLOCK(htim); return HAL_OK;&#125; &emsp;对代码的分析如下： 死区时间设置为100，即为0b0110 0100，所以对应的死区时间为100个$Tdts$周期数，即为463ns； 运行模式下与空闲模式下处于无效状态时，设置为禁止OC/OCN输出； 锁定配置不生效； Break功能本例不涉及，全部禁用状态。 硬件初始化&emsp;硬件初始化函数如下所示。硬件初始化即为对PWM IO的初始化，这里不再说明。 123456789101112131415161718192021222324252627282930313233343536373839404142434445void HAL_TIM_MspPostInit(TIM_HandleTypeDef* timHandle)&#123; GPIO_InitTypeDef GPIO_InitStruct; if(timHandle-&gt;Instance==TIM1) &#123; /* USER CODE BEGIN TIM1_MspPostInit 0 */ /* USER CODE END TIM1_MspPostInit 0 */ /**TIM1 GPIO Configuration PE11 ------&gt; TIM1_CH2 PE13 ------&gt; TIM1_CH3 PB13 ------&gt; TIM1_CH1N PB14 ------&gt; TIM1_CH2N PB15 ------&gt; TIM1_CH3N PA8 ------&gt; TIM1_CH1 */ GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_13; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; GPIO_InitStruct.Alternate = GPIO_AF1_TIM1; HAL_GPIO_Init(GPIOE, &amp;GPIO_InitStruct); GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; GPIO_InitStruct.Alternate = GPIO_AF1_TIM1; HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct); GPIO_InitStruct.Pin = GPIO_PIN_8; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; GPIO_InitStruct.Alternate = GPIO_AF1_TIM1; HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct); /* USER CODE BEGIN TIM1_MspPostInit 1 */ /* USER CODE END TIM1_MspPostInit 1 */ &#125;&#125; 使能PWM输出&emsp;使能PWM输出的函数如下所示。 12345678HAL_TIM_PWM_Start(&amp;htim1, TIM_CHANNEL_1);HAL_TIMEx_PWMN_Start(&amp;htim1, TIM_CHANNEL_1); // turn on complementary channel HAL_TIM_PWM_Start(&amp;htim1, TIM_CHANNEL_2);HAL_TIMEx_PWMN_Start(&amp;htim1, TIM_CHANNEL_2); // turn on complementary channel HAL_TIM_PWM_Start(&amp;htim1, TIM_CHANNEL_3);HAL_TIMEx_PWMN_Start(&amp;htim1, TIM_CHANNEL_3); // turn on complementary channel &emsp;以channel1为例，其具体实现如下。首先为PWM信号生成使能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * @brief Starts the PWM signal generation. * @param htim pointer to a TIM_HandleTypeDef structure that contains * the configuration information for TIM module. * @param Channel TIM Channels to be enabled. * This parameter can be one of the following values: * @arg TIM_CHANNEL_1: TIM Channel 1 selected * @arg TIM_CHANNEL_2: TIM Channel 2 selected * @arg TIM_CHANNEL_3: TIM Channel 3 selected * @arg TIM_CHANNEL_4: TIM Channel 4 selected * @retval HAL status */HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)&#123; /* Check the parameters */ assert_param(IS_TIM_CCX_INSTANCE(htim-&gt;Instance, Channel)); /* Enable the Capture compare channel */ TIM_CCxChannelCmd(htim-&gt;Instance, Channel, TIM_CCx_ENABLE); if(IS_TIM_ADVANCED_INSTANCE(htim-&gt;Instance) != RESET) &#123; /* Enable the main output */ __HAL_TIM_MOE_ENABLE(htim); &#125; /* Enable the Peripheral */ __HAL_TIM_ENABLE(htim); /* Return function status */ return HAL_OK;&#125; void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)&#123; uint32_t tmp = 0; /* Check the parameters */ assert_param(IS_TIM_CC1_INSTANCE(TIMx)); assert_param(IS_TIM_CHANNELS(Channel)); tmp = TIM_CCER_CC1E &lt;&lt; Channel; /* Reset the CCxE Bit */ TIMx-&gt;CCER &amp;= ~tmp; /* Set or reset the CCxE Bit */ TIMx-&gt;CCER |= (uint32_t)(ChannelState &lt;&lt; Channel);&#125;/** * @brief Enable the TIM main Output. * @param __HANDLE__ TIM handle * @retval None */#define __HAL_TIM_MOE_ENABLE(__HANDLE__) ((__HANDLE__)-&gt;Instance-&gt;BDTR|=(TIM_BDTR_MOE))/** * @brief Enable the TIM peripheral. * @param __HANDLE__ TIM handle * @retval None */#define __HAL_TIM_ENABLE(__HANDLE__) ((__HANDLE__)-&gt;Instance-&gt;CR1|=(TIM_CR1_CEN)) &emsp;代码功能主要为： TIMx_CCER寄存器CCxE位置位，代表OC开启，信号输出到对应引脚； TIMx_BDTR寄存器MOE位置位，主输出使能开启，当CCxE与CCxNE使能时，则使能OC与OCN； TIMx_CR1寄存器CEN置位，使能计数器； &emsp;PWM的互补对使能如下。 12345678910111213141516171819202122232425262728/** * @brief Starts the PWM signal generation on the complementary output. * @param htim pointer to a TIM_HandleTypeDef structure that contains * the configuration information for TIM module. * @param Channel TIM Channel to be enabled. * This parameter can be one of the following values: * @arg TIM_CHANNEL_1: TIM Channel 1 selected * @arg TIM_CHANNEL_2: TIM Channel 2 selected * @arg TIM_CHANNEL_3: TIM Channel 3 selected * @retval HAL status */HAL_StatusTypeDef HAL_TIMEx_PWMN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)&#123; /* Check the parameters */ assert_param(IS_TIM_CCXN_INSTANCE(htim-&gt;Instance, Channel)); /* Enable the complementary PWM output */ TIM_CCxNChannelCmd(htim-&gt;Instance, Channel, TIM_CCxN_ENABLE); /* Enable the Main Output */ __HAL_TIM_MOE_ENABLE(htim); /* Enable the Peripheral */ __HAL_TIM_ENABLE(htim); /* Return function status */ return HAL_OK;&#125; &emsp;代码功能主要为： TIMx_CCER寄存器CCxNE位置位，代表OCN开启，信号输出到对应引脚； 与PWM主信号一致，使能MOE位并使能定时器。 测试程序&emsp;按照上述配置进行测试，得到的波形信息如下。 其中占空比分别接近20%、30%、60%(channel3为反相)； 死区时间约为460ns，与理论值接近。","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://jiaodi.tech/categories/嵌入式/"}],"tags":[{"name":"STM32F7","slug":"STM32F7","permalink":"http://jiaodi.tech/tags/STM32F7/"},{"name":"PWM","slug":"PWM","permalink":"http://jiaodi.tech/tags/PWM/"}]},{"title":"优化前馈电容改善DCDC的瞬态响应(未完成)","slug":"feedforward-cap","date":"2018-04-28T11:53:05.000Z","updated":"2018-05-07T12:22:06.764Z","comments":true,"path":"2018/04/28/feedforward-cap/","link":"","permalink":"http://jiaodi.tech/2018/04/28/feedforward-cap/","excerpt":"&emsp;本文介绍如何利用前馈电容优化DCDC的瞬态响应能力。","text":"&emsp;本文介绍如何利用前馈电容优化DCDC的瞬态响应能力。 简介&emsp;按照控制对象区分，DCDC变换器通常可以分为电压型与电流型控制。目前常见的集成型DCDC变换器通常在内部完成补偿回路，以便于用户直接使用；但由于补偿回路无法自行修改，也相知了用户对变换器瞬态响应进行调节的能力。 &emsp;考虑到可调输出DCDC变换器需要设置分压反馈网络，反馈网络中的前馈电容可以影响系统环路稳定性。本文将简要介绍通过优化前馈电容改善DCDC瞬态响应的方法。 控制框图&emsp;典型的DCDC变换器控制框图如下所示，共分为modulator(调制器)、filter(滤波器)与compensator(补偿器)三部分。","categories":[{"name":"电源","slug":"电源","permalink":"http://jiaodi.tech/categories/电源/"}],"tags":[{"name":"DCDC","slug":"DCDC","permalink":"http://jiaodi.tech/tags/DCDC/"},{"name":"前馈电容","slug":"前馈电容","permalink":"http://jiaodi.tech/tags/前馈电容/"},{"name":"动态响应","slug":"动态响应","permalink":"http://jiaodi.tech/tags/动态响应/"}]},{"title":"STM32F767 WWDG的基本用法","slug":"stm32f767-wwdg","date":"2018-04-25T12:55:35.000Z","updated":"2018-05-07T12:16:18.757Z","comments":true,"path":"2018/04/25/stm32f767-wwdg/","link":"","permalink":"http://jiaodi.tech/2018/04/25/stm32f767-wwdg/","excerpt":"&emsp;本文介绍STM32F767 WWDG(System window watchdog)的基本用法。","text":"&emsp;本文介绍STM32F767 WWDG(System window watchdog)的基本用法。 开发环境硬件环境 电脑：Windows 10 Home x64 Apollo STM32F767开发板(ST-LINK V2仿真器) 软件环境 Keil Version 5.24.1 (Pack Installer：Keil.STM32F7xx_DFP.2.9.0.pack) STM32CubeMX Version 4.25.0(Packages Manager：STM32CubeF7) WWDG主要特性系统框图 主要特性 自由计数递减计数器 时钟源为APB1时钟 复位条件 递减计数器值小于0x40时(看门狗激活状态下) 递减计数器在窗口之外时被重载(看门狗激活状态下) 提前唤醒中断(EWI)：当递减计数器等于0x40时触发(如已使能且看门狗激活状态下) WWDG溢出时间计算&emsp;WWDG使用APB1作为时钟源，经过4096与WWDG_CFR寄存器的WDGTB位控制的共2次分频。本例中APB1的时钟频率为54MHz，则WWDG的时钟周期计算如下： $$T{WWDG}=T{APB1}\\cdot 4096\\cdot 2^{WDGTB}$$ 举例计算，设定WDGTB为3，则WWDG的时钟周期约为0.6068ms。 递减计数器值小于0x40(等于0x39)时WWDG复位； 设定WWDG_CFR寄存器中W[6:0]窗口值为0x50； 设定WWDG_CR寄存器中T[6:0]计数器值为0x60； &emsp;则WWDG的允许刷新时间位于计数器值在窗口值与0x40之间，在窗口之外或者计数值小于0x40时都将引起复位。由以上约束时间，则在WWDG计数器启动之后，计数值从0x60到0x50之间禁止刷新看门狗，计数值在0x50到0x39之间允许刷新看门狗，在计数器到达0x39时将引起看门狗复位。对应地，在9.71~20.02ms内刷新均可以重载看门狗，在此时间窗以外刷新IWDG都已经无法避免系统复位。 WWDG的基本用法WWDG参数设置&emsp;WWDG的初始化代码如下所示。 1234567891011121314151617WWDG_HandleTypeDef hwwdg;/* WWDG init function */void MX_WWDG_Init(void)&#123; hwwdg.Instance = WWDG; hwwdg.Init.Prescaler = WWDG_PRESCALER_8; hwwdg.Init.Window = 0x50; hwwdg.Init.Counter = 0x60; hwwdg.Init.EWIMode = WWDG_EWI_DISABLE; if (HAL_WWDG_Init(&amp;hwwdg) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125;&#125; &emsp;其参数设置如下： 预分频系数设置为8，窗口值设置为0x50，计数器值设置为0x60； 禁止EWI中断。 WWDG初始化&emsp;WWDG初始化代码如下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * @brief Initialize the WWDG according to the specified. * parameters in the WWDG_InitTypeDef of associated handle. * @param hwwdg pointer to a WWDG_HandleTypeDef structure that contains * the configuration information for the specified WWDG module. * @retval HAL status */HAL_StatusTypeDef HAL_WWDG_Init(WWDG_HandleTypeDef *hwwdg)&#123; /* Check the WWDG handle allocation */ if(hwwdg == NULL) &#123; return HAL_ERROR; &#125; /* Check the parameters */ assert_param(IS_WWDG_ALL_INSTANCE(hwwdg-&gt;Instance)); assert_param(IS_WWDG_PRESCALER(hwwdg-&gt;Init.Prescaler)); assert_param(IS_WWDG_WINDOW(hwwdg-&gt;Init.Window)); assert_param(IS_WWDG_COUNTER(hwwdg-&gt;Init.Counter)); assert_param(IS_WWDG_EWI_MODE(hwwdg-&gt;Init.EWIMode)); /* Init the low level hardware */ HAL_WWDG_MspInit(hwwdg); /* Set WWDG Counter */ WRITE_REG(hwwdg-&gt;Instance-&gt;CR, (WWDG_CR_WDGA | hwwdg-&gt;Init.Counter)); /* Set WWDG Prescaler and Window */ WRITE_REG(hwwdg-&gt;Instance-&gt;CFR, (hwwdg-&gt;Init.EWIMode | hwwdg-&gt;Init.Prescaler | hwwdg-&gt;Init.Window)); /* Return function status */ return HAL_OK;&#125;void HAL_WWDG_MspInit(WWDG_HandleTypeDef* wwdgHandle)&#123; if(wwdgHandle-&gt;Instance==WWDG) &#123; /* USER CODE BEGIN WWDG_MspInit 0 */ /* USER CODE END WWDG_MspInit 0 */ /* WWDG clock enable */ __HAL_RCC_WWDG_CLK_ENABLE(); /* USER CODE BEGIN WWDG_MspInit 1 */ /* USER CODE END WWDG_MspInit 1 */ &#125;&#125; &emsp;WWDG初始化流程如下： 使能WWDG时钟； 设置WWDG_CR寄存器WDGA位为1，使能看门狗；向T[6:0]位写入计数器值； 设置WWDG_CFR寄存器EWI位为0，禁止EWI功能；向WDGTB[1:0]位写入预分频值；向W[6:0]位写入窗口值。 刷新WWDG函数&emsp;刷新WWDG函数如下所示。 1234567891011121314/** * @brief Refresh the WWDG. * @param hwwdg pointer to a WWDG_HandleTypeDef structure that contains * the configuration information for the specified WWDG module. * @retval HAL status */HAL_StatusTypeDef HAL_WWDG_Refresh(WWDG_HandleTypeDef *hwwdg)&#123; /* Write to WWDG CR the WWDG Counter value to refresh with */ WRITE_REG(hwwdg-&gt;Instance-&gt;CR, (hwwdg-&gt;Init.Counter)); /* Return function status */ return HAL_OK;&#125; 测试程序&emsp;在主程序中测试WWDG，程序设置如下： 1234567while (1)&#123; mainloop++; //oled_putuint32(0, 2, mainloop); SYS_Delay_US(9.7*1000); HAL_WWDG_Refresh(&amp;hwwdg); &#125; &emsp;实验结果如下所示： delay时间为9.6ms，系统复位，符合预期； delay时间为9.8ms，系统正常，符合预期； delay时间为19.9ms，系统复位，不符合预期； delay时间为20.1ms，系统复位，符合预期； &emsp;实验结果与预期不符合，降低delay时间继续进行验证： delay时间设置为19.5ms，系统复位； delay时间设置为19.4ms，系统正常。 由此可见，实验结果表示与理论值有较大误差。具体已经联系ST进行解决。","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://jiaodi.tech/categories/嵌入式/"}],"tags":[{"name":"STM32F7","slug":"STM32F7","permalink":"http://jiaodi.tech/tags/STM32F7/"},{"name":"WWDG","slug":"WWDG","permalink":"http://jiaodi.tech/tags/WWDG/"}]},{"title":"STM32F767 IWDG的基本用法","slug":"stm32f767-iwdg","date":"2018-04-21T10:15:04.000Z","updated":"2018-04-27T15:02:39.769Z","comments":true,"path":"2018/04/21/stm32f767-iwdg/","link":"","permalink":"http://jiaodi.tech/2018/04/21/stm32f767-iwdg/","excerpt":"&emsp;本文介绍STM32F767 IWDG(Independent watchdog)的基本用法。","text":"&emsp;本文介绍STM32F767 IWDG(Independent watchdog)的基本用法。 开发环境硬件环境 电脑：Windows 10 Home x64 Apollo STM32F767开发板(ST-LINK V2仿真器) 软件环境 Keil Version 5.24.1 (Pack Installer：Keil.STM32F7xx_DFP.2.9.0.pack) STM32CubeMX Version 4.25.0(Packages Manager：STM32CubeF7) IWDG的基本特性系统框图&emsp;IWDG的系统框图如下所示。 主要特性 自由计数递减计数器 时钟源为独立LSI RC振荡器(可以在待机与停止模式下运行) 复位条件 递减计数器值小于0x000时(看门狗激活状态下) 递减计数器在窗口之外时被重载(看门狗激活状态下) LSI特性&emsp;IWDG使用LSI作为时钟源，LSI的基本特性如下所示。 &emsp;由LSI参数可以，其时钟频率并不准确。因此其作为时钟源时必须充分考虑其参数范围，计算出IWDG复位的最短时间，并在此时间内进行重载操作。 IWDG溢出时间计算&emsp;独立看门狗的溢出时间计算公式如下所示： $$T_{overflow}=\\frac{1}{f_{IWDG}}\\cdot Period=\\frac{1}{\\frac{f_{LSI}}{Prescaler}}\\cdot Period$$ &emsp;即为： $$T_{overflow}=\\frac{Prescaler}{f_{LSI}}\\cdot Period$$ &emsp;举例来说，假定LSI时钟频率为32kHz，设置预分频值为64，Period值为500，则IWDG周期为1s；如果LSI时钟频率为17kHz，则IWDG周期为1.882s；如果LSI时钟频率为47kHz，则IWDG周期为0.681s。 &emsp;考虑到必须取最小溢出时间，则需要在0.681m内完成喂狗操作。 IWDG的基本用法IWDG参数设置&emsp;IWDG的初始化代码如下所示。 12345678910111213141516IWDG_HandleTypeDef hiwdg;/* IWDG init function */void MX_IWDG_Init(void)&#123; hiwdg.Instance = IWDG; hiwdg.Init.Prescaler = IWDG_PRESCALER_64; hiwdg.Init.Window = IWDG_WINDOW_DISABLE; hiwdg.Init.Reload = 500; if (HAL_IWDG_Init(&amp;hiwdg) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125;&#125; &emsp;其参数设置如下： 预分频系数设置为64，周期值设置为500，则IWDG溢出时间为0.681~1.882s； 窗口值设置为0xfff，则等效于禁用看门狗窗口功能。 IWDG初始化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * @brief Initialize the IWDG according to the specified parameters in the * IWDG_InitTypeDef and start watchdog. Before exiting function, * watchdog is refreshed in order to have correct time base. * @param hiwdg pointer to a IWDG_HandleTypeDef structure that contains * the configuration information for the specified IWDG module. * @retval HAL status */HAL_StatusTypeDef HAL_IWDG_Init(IWDG_HandleTypeDef *hiwdg)&#123; uint32_t tickstart; /* Check the IWDG handle allocation */ if(hiwdg == NULL) &#123; return HAL_ERROR; &#125; /* Check the parameters */ assert_param(IS_IWDG_ALL_INSTANCE(hiwdg-&gt;Instance)); assert_param(IS_IWDG_PRESCALER(hiwdg-&gt;Init.Prescaler)); assert_param(IS_IWDG_RELOAD(hiwdg-&gt;Init.Reload)); assert_param(IS_IWDG_WINDOW(hiwdg-&gt;Init.Window)); /* Enable IWDG. LSI is turned on automaticaly */ __HAL_IWDG_START(hiwdg); /* Enable write access to IWDG_PR, IWDG_RLR and IWDG_WINR registers by writing 0x5555 in KR */ IWDG_ENABLE_WRITE_ACCESS(hiwdg); /* Write to IWDG registers the Prescaler &amp; Reload values to work with */ hiwdg-&gt;Instance-&gt;PR = hiwdg-&gt;Init.Prescaler; hiwdg-&gt;Instance-&gt;RLR = hiwdg-&gt;Init.Reload; /* Check pending flag, if previous update not done, return timeout */ tickstart = HAL_GetTick(); /* Wait for register to be updated */ while(hiwdg-&gt;Instance-&gt;SR != RESET) &#123; if((HAL_GetTick() - tickstart ) &gt; HAL_IWDG_DEFAULT_TIMEOUT) &#123; return HAL_TIMEOUT; &#125; &#125; /* If window parameter is different than current value, modify window register */ if(hiwdg-&gt;Instance-&gt;WINR != hiwdg-&gt;Init.Window) &#123; /* Write to IWDG WINR the IWDG_Window value to compare with. In any case, even if window feature is disabled, Watchdog will be reloaded by writing windows register */ hiwdg-&gt;Instance-&gt;WINR = hiwdg-&gt;Init.Window; &#125; else &#123; /* Reload IWDG counter with value defined in the reload register */ __HAL_IWDG_RELOAD_COUNTER(hiwdg); &#125; /* Return function status */ return HAL_OK;&#125; * @brief Enable the IWDG peripheral. * @param __HANDLE__ IWDG handle * @retval None */#define __HAL_IWDG_START(__HANDLE__) WRITE_REG((__HANDLE__)-&gt;Instance-&gt;KR, IWDG_KEY_ENABLE) * @brief Enable write access to IWDG_PR, IWDG_RLR and IWDG_WINR registers. * @param __HANDLE__ IWDG handle * @retval None */#define IWDG_ENABLE_WRITE_ACCESS(__HANDLE__) WRITE_REG((__HANDLE__)-&gt;Instance-&gt;KR, IWDG_KEY_WRITE_ACCESS_ENABLE) * @brief Reload IWDG counter with value defined in the reload register * (write access to IWDG_PR, IWDG_RLR &amp; IWDG_WINR registers disabled). * @param __HANDLE__ IWDG handle * @retval None */#define __HAL_IWDG_RELOAD_COUNTER(__HANDLE__) WRITE_REG((__HANDLE__)-&gt;Instance-&gt;KR, IWDG_KEY_RELOAD) 1234567/** * @brief IWDG Key Register BitMask */#define IWDG_KEY_RELOAD 0x0000AAAAu /*!&lt; IWDG Reload Counter Enable */#define IWDG_KEY_ENABLE 0x0000CCCCu /*!&lt; IWDG Peripheral Enable */#define IWDG_KEY_WRITE_ACCESS_ENABLE 0x00005555u /*!&lt; IWDG KR Write Access Enable */#define IWDG_KEY_WRITE_ACCESS_DISABLE 0x00000000u /*!&lt; IWDG KR Write Access Disable */ &emsp;IWDG初始化流程如下： 向IWDG_KR寄存器写入IWDG_KEY_ENABLE(0x0000CCCCu)值，则启动IWDG，计数器开始从复位值0xfff递减技术； 向IWDG_KR寄存器写入IWDG_KEY_WRITE_ACCESS_ENABLE(0x00005555u)值，则使能寄存器访问； 向IWDG_PR寄存器写入Prescaler值； 向IWDG_RLR寄存器写入Period(Reload)值； 通过读取IWDG_SR寄存器值，等待寄存器更新完成； 向IWDG_KR寄存器写入IWDG_KEY_RELOAD(0x0000AAAAu)值，刷新IWDG计数器值。 刷新IWDG函数&emsp;刷新IWDG的函数如下，即通过向IWDG_KR寄存器写入IWDG_KEY_RELOAD(0x0000AAAAu)值，刷新IWDG计数器值。 12345678910111213141516171819202122/** * @brief Refresh the IWDG. * @param hiwdg pointer to a IWDG_HandleTypeDef structure that contains * the configuration information for the specified IWDG module. * @retval HAL status */HAL_StatusTypeDef HAL_IWDG_Refresh(IWDG_HandleTypeDef *hiwdg)&#123; /* Reload IWDG counter with value defined in the reload register */ __HAL_IWDG_RELOAD_COUNTER(hiwdg); /* Return function status */ return HAL_OK;&#125;/** * @brief Reload IWDG counter with value defined in the reload register * (write access to IWDG_PR, IWDG_RLR &amp; IWDG_WINR registers disabled). * @param __HANDLE__ IWDG handle * @retval None */#define __HAL_IWDG_RELOAD_COUNTER(__HANDLE__) WRITE_REG((__HANDLE__)-&gt;Instance-&gt;KR, IWDG_KEY_RELOAD) 测试程序&emsp;在主程序中测试IWDG，程序设计如下： 12345678910while (1)&#123; mainloop++; oled_putuint32(0, 2, mainloop); HAL_IWDG_Refresh(&amp;hiwdg); SYS_Delay_US(600*1000); &#125; Delay时间设置为600ms，运行测试程序，可以看到mainloop不断增加，程序正常运行。说明在IWDG计数值溢出前完成刷新，看门狗未导致系统复位； Delay时间设置为1900ms，运行测试程序，可以看到mainloop显示为1后系统复位，如此反复。说明未在IWDG计数值溢出前完成刷新，看门狗导致了系统复位。","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://jiaodi.tech/categories/嵌入式/"}],"tags":[{"name":"STM32F7","slug":"STM32F7","permalink":"http://jiaodi.tech/tags/STM32F7/"},{"name":"IWDG","slug":"IWDG","permalink":"http://jiaodi.tech/tags/IWDG/"}]},{"title":"STM32F767 Timer中断的基本用法","slug":"stm32f767-timer","date":"2018-04-16T14:52:17.000Z","updated":"2018-05-09T14:58:23.164Z","comments":true,"path":"2018/04/16/stm32f767-timer/","link":"","permalink":"http://jiaodi.tech/2018/04/16/stm32f767-timer/","excerpt":"&emsp;本文介绍STM32F767 Timer中断的基本用法。","text":"&emsp;本文介绍STM32F767 Timer中断的基本用法。 开发环境硬件环境 电脑：Windows 10 Home x64 Apollo STM32F767开发板(ST-LINK V2仿真器) 软件环境 Keil Version 5.24.1 (Pack Installer：Keil.STM32F7xx_DFP.2.9.0.pack) STM32CubeMX Version 4.25.0(Packages Manager：STM32CubeF7) TIM的基本特性TIM分类&emsp;在STM32F767中，TIM定时器共分为3类：基本定时器、基本通用定时器、通用定时器、高级控制定时器与低功耗定时器。 基本定时器&emsp;TIM6/TIM7为基本定时器，具备的功能有： 16 位自动重载递增计数器 16 位可编程预分频器，用于对计数器时钟频率进行分频（可在运行时修改），分频系数介于 1 和 65536 之间 用于触发 DAC 的同步电路 发生如下更新事件时会生成中断/DMA 请求：计数器上溢 基本通用定时器&emsp;TIM9/TIM10/TIM11/TIM12/TIM13/TIM14为基本通用定时器，具备的功能有： 16 位自动重载递增计数器 16 位可编程预分频器，用于对计数器时钟频率进行分频（可在运行时修改），分频系数介于 1 和 65536 之间 多达 2 个独立通道，可用于：输入捕获、输出比较、PWM生成(边沿对齐)、单脉冲模式输出 使用外部信号控制定时器且可实现多个定时器互连的同步电路 发生如下事件时生成中断：更新(计数器上溢、计数器初始化(通过软件或内部触发))、触发事件(计数器启动、停止、初始化或者由内部触发计数)、输入捕获、输出比较 通用定时器&emsp;TIM2/TIM3/TIM4/TIM5为通用定时器，具备的功能有： 16 位（TIM3 和 TIM4）或 32 位（TIM2 和 TIM5）递增、递减和递增/递减自动重载计数器 16 位可编程预分频器，用于对计数器时钟频率进行分频(可在运行时修改)，分频系数介于 1 到 65535 之间 多达 4 个独立通道，可用于：输入捕获、输出比较、PWM生成(边沿和中心对齐)、单脉冲模式输出 使用外部信号控制定时器且可实现多个定时器互连的同步电路 发生如下事件时生成中断：更新(计数器上溢/下溢、计数器初始化(通过软件或内部/外部触发))、触发事件(计数器启动、停止、初始化或者由内部/外部触发计数)、输入捕获、输出比较 支持定位用增量（正交）编码器和霍尔传感器电路 触发输入作为外部时钟或者逐周期电流管理 高级控制定时器&emsp;TIM1/TIM8为高级控制定时器，具备的功能有： 16 位递增、递减、递增/递减自动重载计数器 16 位可编程预分频器，用于对计数器时钟频率进行分频(可在运行时修改)，分频系数介于 1 到 65536 之间 多达 6 个独立通道，可用于：输入捕获(但通道 5 和通道 6 除外)、输出比较、PWM生成(边沿和中心对齐)、单脉冲模式输出 带可编程死区的互补输出 使用外部信号控制定时器且可实现多个定时器互连的同步电路 重复计数器，用于仅在给定数目的计数器周期后更新定时器寄存器 具有2 个断路输入，用于将定时器的输出信号置于用户可选的安全配置中 发生如下事件时生成中断/DMA 请求：更新(计数器上溢/下溢、计数器初始化(通过软件或内部/外部触发))、触发事件(计数器启动、停止、初始化或者由内部/外部触发计数)、输入捕获、输出比较 支持定位用增量（正交）编码器和霍尔传感器电路 触发输入作为外部时钟或者逐周期电流管理 TIM2基本特性&emsp;本例中，使用TIM2定时器完成实验。TIM2的基本特性如下： 为通用定时器； 32 位递增、递减和递增/递减自动重载计数器； 时钟源为APB1，频率为108MHz。 基于TIM2的timer中断基本用法系统框图&emsp;通用定时器的系统框图如图所示。本次进行定时器中断实验只需要用到计数以及中断部分。 Timer代码设置代码概述&emsp;Timer的初始化代码如下所示。其初始化主要由3个函数完成，以下将对这3个函数进行简要说明。 123456789101112131415161718192021222324252627282930313233TIM_HandleTypeDef htim2;/* TIM2 init function */void MX_TIM2_Init(void)&#123; TIM_ClockConfigTypeDef sClockSourceConfig; TIM_MasterConfigTypeDef sMasterConfig; htim2.Instance = TIM2; htim2.Init.Prescaler = 10800 - 1; htim2.Init.CounterMode = TIM_COUNTERMODE_UP; htim2.Init.Period = 5000 - 1; htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1; htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE; if (HAL_TIM_Base_Init(&amp;htim2) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL; if (HAL_TIM_ConfigClockSource(&amp;htim2, &amp;sClockSourceConfig) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE; sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE; if (HAL_TIMEx_MasterConfigSynchronization(&amp;htim2, &amp;sMasterConfig) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125;&#125; 时基单元初始化&emsp;时基单元初始化通过HAL_TIM_Base_Init()函数实现，具体如下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * @brief Initializes the TIM Time base Unit according to the specified * parameters in the TIM_HandleTypeDef and create the associated handle. * @param htim pointer to a TIM_HandleTypeDef structure that contains * the configuration information for TIM module. * @retval HAL status */HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)&#123; /* Check the TIM handle allocation */ if(htim == NULL) &#123; return HAL_ERROR; &#125; /* Check the parameters */ assert_param(IS_TIM_INSTANCE(htim-&gt;Instance)); assert_param(IS_TIM_COUNTER_MODE(htim-&gt;Init.CounterMode)); assert_param(IS_TIM_CLOCKDIVISION_DIV(htim-&gt;Init.ClockDivision)); assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim-&gt;Init.AutoReloadPreload)); if(htim-&gt;State == HAL_TIM_STATE_RESET) &#123; /* Allocate lock resource and initialize it */ htim-&gt;Lock = HAL_UNLOCKED;#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1) /* Reset interrupt callbacks to legacy week callbacks */ TIM_ResetCallback(htim); if(htim-&gt;Base_MspInitCallback == NULL) &#123; htim-&gt;Base_MspInitCallback = HAL_TIM_Base_MspInit; &#125; /* Init the low level hardware : GPIO, CLOCK, NVIC */ htim-&gt;Base_MspInitCallback(htim);#else /* Init the low level hardware : GPIO, CLOCK, NVIC */ HAL_TIM_Base_MspInit(htim);#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */ &#125; /* Set the TIM state */ htim-&gt;State= HAL_TIM_STATE_BUSY; /* Set the Time Base configuration */ TIM_Base_SetConfig(htim-&gt;Instance, &amp;htim-&gt;Init); /* Initialize the TIM state*/ htim-&gt;State= HAL_TIM_STATE_READY; return HAL_OK;&#125; &emsp;程序中调用了HAL_TIM_Base_MspInit()函数，该函数完成TIM2 RCC时钟的使能、NVIC的使能以及优先级设置。 12345678910111213141516171819void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* tim_baseHandle)&#123; if(tim_baseHandle-&gt;Instance==TIM2) &#123; /* USER CODE BEGIN TIM2_MspInit 0 */ /* USER CODE END TIM2_MspInit 0 */ /* TIM2 clock enable */ __HAL_RCC_TIM2_CLK_ENABLE(); /* TIM2 interrupt Init */ HAL_NVIC_SetPriority(TIM2_IRQn, 1, 1); HAL_NVIC_EnableIRQ(TIM2_IRQn); /* USER CODE BEGIN TIM2_MspInit 1 */ /* USER CODE END TIM2_MspInit 1 */ &#125;&#125; &emsp;程序中之后调用的TIM_Base_SetConfig()函数为时基单元的设置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * @brief Time Base configuration * @param TIMx TIM peripheral * @param Structure pointer on TIM Time Base required parameters * @retval None */void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)&#123; uint32_t tmpcr1 = 0; tmpcr1 = TIMx-&gt;CR1; /* Set TIM Time Base Unit parameters ---------------------------------------*/ if(IS_TIM_CC3_INSTANCE(TIMx) != RESET) &#123; /* Select the Counter Mode */ tmpcr1 &amp;= ~(TIM_CR1_DIR | TIM_CR1_CMS); tmpcr1 |= Structure-&gt;CounterMode; &#125; if(IS_TIM_CC1_INSTANCE(TIMx) != RESET) &#123; /* Set the clock division */ tmpcr1 &amp;= ~TIM_CR1_CKD; tmpcr1 |= (uint32_t)Structure-&gt;ClockDivision; &#125; /* Set the auto-reload preload */ MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure-&gt;AutoReloadPreload); TIMx-&gt;CR1 = tmpcr1; /* Set the Auto-reload value */ TIMx-&gt;ARR = (uint32_t)Structure-&gt;Period ; /* Set the Prescaler value */ TIMx-&gt;PSC = (uint32_t)Structure-&gt;Prescaler; if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET) &#123; /* Set the Repetition Counter value */ TIMx-&gt;RCR = Structure-&gt;RepetitionCounter; &#125; /* Generate an update event to reload the Prescaler and the repetition counter(only for TIM1 and TIM8) value immediately */ TIMx-&gt;EGR = TIM_EGR_UG;&#125; &emsp;该函数的功能简介如下： tmpcr1为TIMx-&gt;CR1寄存器的待写入值，该值首先保存TIMx-&gt;CR1寄存器当前值； 经过IS_TIM_CC3_INSTANCE实例检测后，tmpcr1设置计数器模式，本例为增计数； 经过IS_TIM_CC1_INSTANCE实例检测后，tmpcr1设置计时器中频率与数字滤波器所用时钟ETR、TIx的分频比，本例为不分频； MODIFY_REG()函数设置tmpcr1的ARPE位，本例为TIMx_ARR 寄存器不进行缓冲； 将tmpcr1写入到TIMx-&gt;CR1寄存器； TIMx-&gt;ARR写入定时器周期值，本例写入值为5000-1，考虑到计数值从0开始，所以一个周期内共计数5000次； TIMx-&gt;PSC写入定时器预分频器值，计数器时钟频率 CK_CNT 等于 $f_{CK_PSC} / (PSC[15:0] + 1)$。本例写入值为10800 - 1，则时钟频率为108MHz/10800=10kHz； 定时器时钟为10kHz，计数值为5000，则定时器周期为500ms； 向TIMx-&gt;EGR寄存器UG位写入1，生成更新事件，更新计数器值以及预分频计数器。 时钟源设置&emsp;时钟源的选择通过如下函数实现。本例中时钟选择为内部时钟，即将TIMx_SMCR寄存器SMS控制位设置为0000。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;if (HAL_TIM_ConfigClockSource(&amp;htim2, &amp;sClockSourceConfig) != HAL_OK)&#123; _Error_Handler(__FILE__, __LINE__);&#125;/** * @brief Configures the clock source to be used * @param htim pointer to a TIM_HandleTypeDef structure that contains * the configuration information for TIM module. * @param sClockSourceConfig pointer to a TIM_ClockConfigTypeDef structure that * contains the clock source information for the TIM peripheral. * @retval HAL status */ HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig) &#123; uint32_t tmpsmcr = 0; /* Process Locked */ __HAL_LOCK(htim); htim-&gt;State = HAL_TIM_STATE_BUSY; /* Check the parameters */ assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig-&gt;ClockSource)); /* Reset the SMS, TS, ECE, ETPS and ETRF bits */ tmpsmcr = htim-&gt;Instance-&gt;SMCR; tmpsmcr &amp;= ~(TIM_SMCR_SMS | TIM_SMCR_TS); tmpsmcr &amp;= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP); htim-&gt;Instance-&gt;SMCR = tmpsmcr; switch (sClockSourceConfig-&gt;ClockSource) &#123; case TIM_CLOCKSOURCE_INTERNAL: &#123; assert_param(IS_TIM_INSTANCE(htim-&gt;Instance)); /* Disable slave mode to clock the prescaler directly with the internal clock */ htim-&gt;Instance-&gt;SMCR &amp;= ~TIM_SMCR_SMS; &#125; break; case TIM_CLOCKSOURCE_ETRMODE1: &#123; assert_param(IS_TIM_ETR_INSTANCE(htim-&gt;Instance)); assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig-&gt;ClockPolarity)); assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig-&gt;ClockPrescaler)); assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig-&gt;ClockFilter)); /* Configure the ETR Clock source */ TIM_ETR_SetConfig(htim-&gt;Instance, sClockSourceConfig-&gt;ClockPrescaler, sClockSourceConfig-&gt;ClockPolarity, sClockSourceConfig-&gt;ClockFilter); /* Get the TIMx SMCR register value */ tmpsmcr = htim-&gt;Instance-&gt;SMCR; /* Reset the SMS and TS Bits */ tmpsmcr &amp;= ~(TIM_SMCR_SMS | TIM_SMCR_TS); /* Select the External clock mode1 and the ETRF trigger */ tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1); /* Write to TIMx SMCR */ htim-&gt;Instance-&gt;SMCR = tmpsmcr; &#125; break; case TIM_CLOCKSOURCE_ETRMODE2: &#123; assert_param(IS_TIM_ETR_INSTANCE(htim-&gt;Instance)); assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig-&gt;ClockPolarity)); assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig-&gt;ClockPrescaler)); assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig-&gt;ClockFilter)); /* Configure the ETR Clock source */ TIM_ETR_SetConfig(htim-&gt;Instance, sClockSourceConfig-&gt;ClockPrescaler, sClockSourceConfig-&gt;ClockPolarity, sClockSourceConfig-&gt;ClockFilter); /* Enable the External clock mode2 */ htim-&gt;Instance-&gt;SMCR |= TIM_SMCR_ECE; &#125; break; case TIM_CLOCKSOURCE_TI1: &#123; assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim-&gt;Instance)); /* Check TI1 input conditioning related parameters */ assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig-&gt;ClockPolarity)); assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig-&gt;ClockFilter)); TIM_TI1_ConfigInputStage(htim-&gt;Instance, sClockSourceConfig-&gt;ClockPolarity, sClockSourceConfig-&gt;ClockFilter); TIM_ITRx_SetConfig(htim-&gt;Instance, TIM_CLOCKSOURCE_TI1); &#125; break; case TIM_CLOCKSOURCE_TI2: &#123; assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim-&gt;Instance)); /* Check TI1 input conditioning related parameters */ assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig-&gt;ClockPolarity)); assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig-&gt;ClockFilter)); TIM_TI2_ConfigInputStage(htim-&gt;Instance, sClockSourceConfig-&gt;ClockPolarity, sClockSourceConfig-&gt;ClockFilter); TIM_ITRx_SetConfig(htim-&gt;Instance, TIM_CLOCKSOURCE_TI2); &#125; break; case TIM_CLOCKSOURCE_TI1ED: &#123; assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim-&gt;Instance)); /* Check TI1 input conditioning related parameters */ assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig-&gt;ClockPolarity)); assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig-&gt;ClockFilter)); TIM_TI1_ConfigInputStage(htim-&gt;Instance, sClockSourceConfig-&gt;ClockPolarity, sClockSourceConfig-&gt;ClockFilter); TIM_ITRx_SetConfig(htim-&gt;Instance, TIM_CLOCKSOURCE_TI1ED); &#125; break; case TIM_CLOCKSOURCE_ITR0: &#123; assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim-&gt;Instance)); TIM_ITRx_SetConfig(htim-&gt;Instance, TIM_CLOCKSOURCE_ITR0); &#125; break; case TIM_CLOCKSOURCE_ITR1: &#123; assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim-&gt;Instance)); TIM_ITRx_SetConfig(htim-&gt;Instance, TIM_CLOCKSOURCE_ITR1); &#125; break; case TIM_CLOCKSOURCE_ITR2: &#123; assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim-&gt;Instance)); TIM_ITRx_SetConfig(htim-&gt;Instance, TIM_CLOCKSOURCE_ITR2); &#125; break; case TIM_CLOCKSOURCE_ITR3: &#123; assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim-&gt;Instance)); TIM_ITRx_SetConfig(htim-&gt;Instance, TIM_CLOCKSOURCE_ITR3); &#125; break; default: break; &#125; htim-&gt;State = HAL_TIM_STATE_READY; __HAL_UNLOCK(htim); return HAL_OK;&#125; 主模式设置&emsp;设置时钟主模式的设置通过如下代码实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;if (HAL_TIMEx_MasterConfigSynchronization(&amp;htim2, &amp;sMasterConfig) != HAL_OK)&#123; _Error_Handler(__FILE__, __LINE__);&#125;/** * @brief Configures the TIM in master mode. * @param htim pointer to a TIM_HandleTypeDef structure that contains * the configuration information for TIM module. * @param sMasterConfig pointer to a TIM_MasterConfigTypeDef structure that * contains the selected trigger output (TRGO) and the Master/Slave * mode. * @retval HAL status */HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim, TIM_MasterConfigTypeDef * sMasterConfig)&#123; uint32_t tmpcr2; uint32_t tmpsmcr; /* Check the parameters */ assert_param(IS_TIM_SYNCHRO_INSTANCE(htim-&gt;Instance)); assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig-&gt;MasterOutputTrigger)); assert_param(IS_TIM_MSM_STATE(sMasterConfig-&gt;MasterSlaveMode)); /* Check input state */ __HAL_LOCK(htim); /* Get the TIMx CR2 register value */ tmpcr2 = htim-&gt;Instance-&gt;CR2; /* Get the TIMx SMCR register value */ tmpsmcr = htim-&gt;Instance-&gt;SMCR; /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */ if (IS_TIM_TRGO2_INSTANCE(htim-&gt;Instance)) &#123; /* Check the parameters */ assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig-&gt;MasterOutputTrigger2)); /* Clear the MMS2 bits */ tmpcr2 &amp;= ~TIM_CR2_MMS2; /* Select the TRGO2 source*/ tmpcr2 |= sMasterConfig-&gt;MasterOutputTrigger2; &#125; /* Reset the MMS Bits */ tmpcr2 &amp;= ~TIM_CR2_MMS; /* Select the TRGO source */ tmpcr2 |= sMasterConfig-&gt;MasterOutputTrigger; /* Reset the MSM Bit */ tmpsmcr &amp;= ~TIM_SMCR_MSM; /* Set master mode */ tmpsmcr |= sMasterConfig-&gt;MasterSlaveMode; /* Update TIMx CR2 */ htim-&gt;Instance-&gt;CR2 = tmpcr2; /* Update TIMx SMCR */ htim-&gt;Instance-&gt;SMCR = tmpsmcr; __HAL_UNLOCK(htim); return HAL_OK;&#125; &emsp;该函数的功能简介如下： tmpcr2首先读取了TIMx_CR2寄存器值，清空MMS值并写入2，即以更新时间作为触发输出(TRGO)； tmpsmcr首先读取了TIMx_SMCR寄存器值，清空MSM值并写入0，代表主从模式不执行任何操作。 将tmpcr2与tmpsmcr分别写入到TIMx_CR2、TIMx_SMCR寄存器。 Timer中断设置&emsp;在定时器中断中设置翻转GPIOB PIN1。 1234567891011121314151617/** * @brief Period elapsed callback in non blocking mode * @param htim pointer to a TIM_HandleTypeDef structure that contains * the configuration information for TIM module. * @retval None */__weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)&#123; /* Prevent unused argument(s) compilation warning */ UNUSED(htim); HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1); /* NOTE : This function Should not be modified, when the callback is needed, the __HAL_TIM_PeriodElapsedCallback could be implemented in the user file */ &#125; 启动定时器&emsp;启动定时器的程序如下。 1234567891011121314151617181920212223242526HAL_TIM_Base_Start_IT(&amp;htim2);/** * @brief Starts the TIM Base generation in interrupt mode. * @param htim pointer to a TIM_HandleTypeDef structure that contains * the configuration information for TIM module. * @retval HAL status */HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)&#123; /* Check the parameters */ assert_param(IS_TIM_INSTANCE(htim-&gt;Instance)); /* Enable the TIM Update interrupt */ __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE); /* Enable the Peripheral */ __HAL_TIM_ENABLE(htim); /* Return function status */ return HAL_OK;&#125;#define __HAL_TIM_ENABLE_IT(__HANDLE__, __INTERRUPT__) ((__HANDLE__)-&gt;Instance-&gt;DIER |= (__INTERRUPT__))#define __HAL_TIM_ENABLE(__HANDLE__) ((__HANDLE__)-&gt;Instance-&gt;CR1|=(TIM_CR1_CEN)) &emsp;该程序向TIMx_DIER寄存器UIE写入1，使能更新中断；向TIMx_CR1寄存器CEN位写入1，使能计数器。至此，则定时器启动。 运行程序&emsp;运行程序，可以看到GPIOB PIN1翻转，高电平与低电平持续时间均为500ms。 时基单元的准确性确认&emsp;为了确认时基单元准确性，对定时器分频器与周期进行不同设置并测量周期时长。 Prescaler TIM时钟频率 TIM时钟周期 Period TIM理论周期 TIM实测周期 说明 10800 - 1 10kHz 0.1ms 10 - 1 1ms 1.00025ms 误差远低于TIM时钟周期，故Period设置方法无误。 10-1 10.8MHz 1/10.8us 10800-1 1ms 1.00024ms 误差远低于TIM理论周期，故Prescaler设置无误。 108 - 1 1MHz 1us 2-1 2us 2.005us 误差低于1%，确认无误。","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://jiaodi.tech/categories/嵌入式/"}],"tags":[{"name":"STM32F7","slug":"STM32F7","permalink":"http://jiaodi.tech/tags/STM32F7/"},{"name":"interrupt","slug":"interrupt","permalink":"http://jiaodi.tech/tags/interrupt/"},{"name":"Timer","slug":"Timer","permalink":"http://jiaodi.tech/tags/Timer/"}]},{"title":"STM32F767 GPIO中断的基本用法","slug":"stm32f767-gpio-it","date":"2018-04-08T15:28:48.000Z","updated":"2018-04-16T14:50:51.951Z","comments":true,"path":"2018/04/08/stm32f767-gpio-it/","link":"","permalink":"http://jiaodi.tech/2018/04/08/stm32f767-gpio-it/","excerpt":"&emsp;本文介绍STM32F767 GPIO中断的基本用法，同时借此对EXTI(Extended interrupts and events controller)进行简要介绍。","text":"&emsp;本文介绍STM32F767 GPIO中断的基本用法，同时借此对EXTI(Extended interrupts and events controller)进行简要介绍。 开发环境硬件环境 电脑：Windows 10 Home x64 Apollo STM32F767开发板(ST-LINK V2仿真器) 软件环境 Keil Version 5.24.1 (Pack Installer：Keil.STM32F7xx_DFP.2.9.0.pack) STM32CubeMX Version 4.25.0(Packages Manager：STM32CubeF7) 中断优先级设置Interrupt priority group简介&emsp;STM32中优先级分为group priority以及sub priority。group priority即为抢占优先级(preempt priority)，抢占优先级高的中断可以打断正在执行的中断；sub priority为次要优先级，当两个抢占优先级相同的中断同时pending时，首先执行sub priority优先级高的中断。 注意中断的优先级数值设置越小代表优先级越高。 &emsp;ARM Cortex-M7内核标准中，通过AIRCR(Application Interrupt and Reset Control Register)寄存器中PRIGROUP位控制Interrupt priority group设置，具体如下。 &emsp;可知PRIGROUP共有3个bit，共8中组合方法，将group priority以及sub priority的控制位依次划分。例如PRIGROUP设置为0b100时，PRI_N[7:1]中[7:5]位为group priority控制位，[4:0]为sub priority控制位，分别对应8与32个优先级设置在。 &emsp;系统中通常抢占优先级更为常用，因此group priority以及sub priority设置中通常更倾向于给予group priority更多控制位。 &emsp;需要注意的是，ARM Cortex-M7内核标准中PRIGROUP的部分设置是optical，也就是可以由厂商自行选用的。事实上SMT32F767内核即对此进行了精简。具体参照HAL_NVIC_SetPriorityGrouping()函数，如下。其NVIC_PRIORITYGROUP共分为5组，NVIC-&gt;IP为group priority以及sub priority寄存器，仅高4位用于设置优先级。 123456789101112131415161718192021222324252627/** * @brief Sets the priority grouping field (preemption priority and subpriority) * using the required unlock sequence. * @param PriorityGroup The priority grouping bits length. * This parameter can be one of the following values: * @arg NVIC_PRIORITYGROUP_0: 0 bits for preemption priority * 4 bits for subpriority * @arg NVIC_PRIORITYGROUP_1: 1 bits for preemption priority * 3 bits for subpriority * @arg NVIC_PRIORITYGROUP_2: 2 bits for preemption priority * 2 bits for subpriority * @arg NVIC_PRIORITYGROUP_3: 3 bits for preemption priority * 1 bits for subpriority * @arg NVIC_PRIORITYGROUP_4: 4 bits for preemption priority * 0 bits for subpriority * @note When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. * The pending IRQ priority will be managed only by the subpriority. * @retval None */void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)&#123; /* Check the parameters */ assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup)); /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */ NVIC_SetPriorityGrouping(PriorityGroup);&#125; &emsp;NVIC_SetPriorityGrouping()的具体实现如下。注意写入到SCB AIRCR寄存器时必须保证VECTKEY位写入0x5FA，否则写入不生效。 123456789101112131415161718192021/** \\brief Set Priority Grouping \\details Sets the priority grouping field using the required unlock sequence. The parameter PriorityGroup is assigned to the field SCB-&gt;AIRCR [10:8] PRIGROUP field. Only values from 0..7 are used. In case of a conflict between priority grouping and available priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set. \\param [in] PriorityGroup Priority grouping field. */__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)&#123; uint32_t reg_value; uint32_t PriorityGroupTmp = (PriorityGroup &amp; (uint32_t)0x07UL); /* only values 0..7 are used */ reg_value = SCB-&gt;AIRCR; /* read old register configuration */ reg_value &amp;= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change */ reg_value = (reg_value | ((uint32_t)0x5FAUL &lt;&lt; SCB_AIRCR_VECTKEY_Pos) | (PriorityGroupTmp &lt;&lt; 8U) ); /* Insert write key and priorty group */ SCB-&gt;AIRCR = reg_value;&#125; Interrupt priority group设置&emsp;在本例中，Interrupt priority group设置如下，同时设置了系统重要中断的优先级。HAL_MspInit()函数在HAL_Init()中调用。设置NVIC_PRIORITYGROUP_2为2，则group priority以及sub priority各有2bit控制位，各自有4个优先级。 12345678910111213141516171819202122232425/** * @brief Initializes the Global MSP. * @param None * @retval None */void HAL_MspInit(void)&#123; HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_2); /* System interrupt init*/ /* MemoryManagement_IRQn interrupt configuration */ HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0); /* BusFault_IRQn interrupt configuration */ HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0); /* UsageFault_IRQn interrupt configuration */ HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0); /* SVCall_IRQn interrupt configuration */ HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0); /* DebugMonitor_IRQn interrupt configuration */ HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0); /* PendSV_IRQn interrupt configuration */ HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0); /* SysTick_IRQn interrupt configuration */ HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);&#125; IO中断设置EXTI框图&emsp;EXTI(Extended interrupts and events controller)的控制框图如下所示。 &emsp;根据框图可知，中断信号如果要进入NVIC(Nested vectored interrupt controller)中，需要如下条件： 边沿选择寄存器相应位使能； 中断mask寄存器相应位使能。 External interrupt/event line mapping&emsp;STM32F767的中断线映射方法如下图所示。 &emsp;例如对于EXTI0，可以选择PA0~PK0等IO作为中断信号源，可以通过SYSCFG_EXTICRx寄存器选择中断线对应地IO端口。 GPIO初始化&emsp;基于HAL库对GPIO中断的初始化非常简明，代码如下。配置Port C PIN13为中断源，上拉处理，下降沿触发中断。 1234GPIO_InitStruct.Pin = GPIO_PIN_13;GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;GPIO_InitStruct.Pull = GPIO_PULLUP;HAL_GPIO_Init(GPIOC, &amp;GPIO_InitStruct); &emsp;重点说明一下HAL_GPIO_Init()函数中关于IO中断的配置部分，代码如下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*--------------------- EXTI Mode Configuration ------------------------*//* Configure the External Interrupt or event for the current IO */if((GPIO_Init-&gt;Mode &amp; EXTI_MODE) == EXTI_MODE)&#123; /* Enable SYSCFG Clock */ __HAL_RCC_SYSCFG_CLK_ENABLE(); temp = SYSCFG-&gt;EXTICR[position &gt;&gt; 2]; temp &amp;= ~(((uint32_t)0x0F) &lt;&lt; (4 * (position &amp; 0x03))); temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) &lt;&lt; (4 * (position &amp; 0x03))); SYSCFG-&gt;EXTICR[position &gt;&gt; 2] = temp; /* Clear EXTI line configuration */ temp = EXTI-&gt;IMR; temp &amp;= ~((uint32_t)iocurrent); if((GPIO_Init-&gt;Mode &amp; GPIO_MODE_IT) == GPIO_MODE_IT) &#123; temp |= iocurrent; &#125; EXTI-&gt;IMR = temp; temp = EXTI-&gt;EMR; temp &amp;= ~((uint32_t)iocurrent); if((GPIO_Init-&gt;Mode &amp; GPIO_MODE_EVT) == GPIO_MODE_EVT) &#123; temp |= iocurrent; &#125; EXTI-&gt;EMR = temp; /* Clear Rising Falling edge configuration */ temp = EXTI-&gt;RTSR; temp &amp;= ~((uint32_t)iocurrent); if((GPIO_Init-&gt;Mode &amp; RISING_EDGE) == RISING_EDGE) &#123; temp |= iocurrent; &#125; EXTI-&gt;RTSR = temp; temp = EXTI-&gt;FTSR; temp &amp;= ~((uint32_t)iocurrent); if((GPIO_Init-&gt;Mode &amp; FALLING_EDGE) == FALLING_EDGE) &#123; temp |= iocurrent; &#125; EXTI-&gt;FTSR = temp; &#125; &emsp;GPIO_MODE_IT_FALLING的值为0x10210 000U，EXTI_MODE的值为0x1000 0000U，所以将进入中断/事件配置函数。 使能SYSCFG时钟； position代表IO的PIN脚值，为0~15，对应SYSCFG_EXTICR0~SYSCFG_EXTICR3，右移2位则可以对应到SYSCFG_EXTICRx寄存器号； temp首先读取SYSCFG_EXTICRx寄存器的值； 将temp中对应的EXTI x配置值清空并写入新的值； 将temp值写入到SYSCFG_EXTICRx寄存器； 使能EXTI-&gt;IMR或者EXTI-&gt;EMR寄存器对应位； 使能EXTI-&gt;RTSR或者EXTI-&gt;FTSR寄存器对应位。 设置中断优先级&emsp;设置GPIO中断的group priority以及sub priority均为2。 123/* EXTI interrupt init*/HAL_NVIC_SetPriority(EXTI15_10_IRQn, 2, 2);HAL_NVIC_EnableIRQ(EXTI15_10_IRQn); &emsp;设置优先级通过向NVIC-&gt;IP写入生效。在STM32F767中，NVIC-&gt;IP的高4位用于设置group priority以及sub priority。以下函数的功能为首先确定系统中断设置有效位，计算得到优先级写入值，再将其写入到NVIC-&gt;IP寄存器中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * @brief Sets the priority of an interrupt. * @param IRQn External interrupt number. * This parameter can be an enumerator of IRQn_Type enumeration * (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h)) * @param PreemptPriority The preemption priority for the IRQn channel. * This parameter can be a value between 0 and 15 * A lower priority value indicates a higher priority * @param SubPriority the subpriority level for the IRQ channel. * This parameter can be a value between 0 and 15 * A lower priority value indicates a higher priority. * @retval None */void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)&#123; uint32_t prioritygroup = 0x00; /* Check the parameters */ assert_param(IS_NVIC_SUB_PRIORITY(SubPriority)); assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority)); prioritygroup = NVIC_GetPriorityGrouping(); NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));&#125;/** \\brief Encode Priority \\details Encodes the priority for an interrupt with the given priority group, preemptive priority value, and subpriority value. In case of a conflict between priority grouping and available priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set. \\param [in] PriorityGroup Used priority group. \\param [in] PreemptPriority Preemptive priority value (starting from 0). \\param [in] SubPriority Subpriority value (starting from 0). \\return Encoded priority. Value can be used in the function \\ref NVIC_SetPriority(). */__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)&#123; uint32_t PriorityGroupTmp = (PriorityGroup &amp; (uint32_t)0x07UL); /* only values 0..7 are used */ uint32_t PreemptPriorityBits; uint32_t SubPriorityBits; PreemptPriorityBits = ((7UL - PriorityGroupTmp) &gt; (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp); SubPriorityBits = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) &lt; (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS)); return ( ((PreemptPriority &amp; (uint32_t)((1UL &lt;&lt; (PreemptPriorityBits)) - 1UL)) &lt;&lt; SubPriorityBits) | ((SubPriority &amp; (uint32_t)((1UL &lt;&lt; (SubPriorityBits )) - 1UL))) );&#125;/** \\brief Set Interrupt Priority \\details Sets the priority of an interrupt. \\note The priority cannot be set for every core interrupt. \\param [in] IRQn Interrupt number. \\param [in] priority Priority to set. */__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)&#123; if ((int32_t)(IRQn) &lt; 0) &#123; SCB-&gt;SHPR[(((uint32_t)(int32_t)IRQn) &amp; 0xFUL)-4UL] = (uint8_t)((priority &lt;&lt; (8U - __NVIC_PRIO_BITS)) &amp; (uint32_t)0xFFUL); &#125; else &#123; NVIC-&gt;IP[((uint32_t)(int32_t)IRQn)] = (uint8_t)((priority &lt;&lt; (8U - __NVIC_PRIO_BITS)) &amp; (uint32_t)0xFFUL); &#125;&#125; &emsp;使能中断通过向NVIC-&gt;ISERx寄存器写入生效。 123456789101112131415161718192021222324252627/** * @brief Enables a device specific interrupt in the NVIC interrupt controller. * @note To configure interrupts priority correctly, the NVIC_PriorityGroupConfig() * function should be called before. * @param IRQn External interrupt number. * This parameter can be an enumerator of IRQn_Type enumeration * (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h)) * @retval None */void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)&#123; /* Check the parameters */ assert_param(IS_NVIC_DEVICE_IRQ(IRQn)); /* Enable interrupt */ NVIC_EnableIRQ(IRQn);&#125;/** \\brief Enable External Interrupt \\details Enables a device-specific interrupt in the NVIC interrupt controller. \\param [in] IRQn External interrupt number. Value cannot be negative. */__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)&#123; NVIC-&gt;ISER[(((uint32_t)(int32_t)IRQn) &gt;&gt; 5UL)] = (uint32_t)(1UL &lt;&lt; (((uint32_t)(int32_t)IRQn) &amp; 0x1FUL));&#125; 设置中断服务函数&emsp;GPIO的中断服务函数如下，其中EXTI15~EXIT10共用同一入口。当进入中断服务函数后，读取EXTI-&gt;PR寄存器确认中断状态，并清除中断标志位。最后，程序调用回调函数HAL_GPIO_EXTI_Callback()。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*** @brief This function handles EXTI line[15:10] interrupts.*/void EXTI15_10_IRQHandler(void)&#123; /* USER CODE BEGIN EXTI15_10_IRQn 0 */ /* USER CODE END EXTI15_10_IRQn 0 */ HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_13); /* USER CODE BEGIN EXTI15_10_IRQn 1 */ /* USER CODE END EXTI15_10_IRQn 1 */&#125;/** * @brief This function handles EXTI interrupt request. * @param GPIO_Pin Specifies the pins connected EXTI line * @retval None */void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)&#123; /* EXTI line interrupt detected */ if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET) &#123; __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin); HAL_GPIO_EXTI_Callback(GPIO_Pin); &#125;&#125;/** * @brief Checks whether the specified EXTI line is asserted or not. * @param __EXTI_LINE__ specifies the EXTI line to check. * This parameter can be GPIO_PIN_x where x can be(0..15) * @retval The new state of __EXTI_LINE__ (SET or RESET). */#define __HAL_GPIO_EXTI_GET_IT(__EXTI_LINE__) (EXTI-&gt;PR &amp; (__EXTI_LINE__))/** * @brief Clears the EXTI's line pending bits. * @param __EXTI_LINE__ specifies the EXTI lines to clear. * This parameter can be any combination of GPIO_PIN_x where x can be (0..15) * @retval None */#define __HAL_GPIO_EXTI_CLEAR_IT(__EXTI_LINE__) (EXTI-&gt;PR = (__EXTI_LINE__)) &emsp;中断回调函数设置如下。 12345678910111213141516/** * @brief EXTI line detection callbacks. * @param GPIO_Pin Specifies the pins connected EXTI line * @retval None */uint16_t keyPressCounter =0;__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)&#123; /* Prevent unused argument(s) compilation warning */ UNUSED(GPIO_Pin); keyPressCounter++; /* NOTE: This function Should not be modified, when the callback is needed, the HAL_GPIO_EXTI_Callback could be implemented in the user file */&#125; &emsp;执行程序，当Port C PIN13被按下(出现下降沿)后，则keyPressCounter增加。注意IO需要进行去抖处理，通常使用一个10~100nF电容完成硬件去抖。","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://jiaodi.tech/categories/嵌入式/"}],"tags":[{"name":"GPIO","slug":"GPIO","permalink":"http://jiaodi.tech/tags/GPIO/"},{"name":"STM32F7","slug":"STM32F7","permalink":"http://jiaodi.tech/tags/STM32F7/"},{"name":"interrupt","slug":"interrupt","permalink":"http://jiaodi.tech/tags/interrupt/"}]},{"title":"STM32F767 GPIO与UART的基本用法","slug":"stm32f767-GPIO-UART","date":"2018-04-05T10:05:01.000Z","updated":"2018-04-15T15:12:33.666Z","comments":true,"path":"2018/04/05/stm32f767-GPIO-UART/","link":"","permalink":"http://jiaodi.tech/2018/04/05/stm32f767-GPIO-UART/","excerpt":"&emsp;本文介绍STM32F767 GPIO与UART的基本用法。","text":"&emsp;本文介绍STM32F767 GPIO与UART的基本用法。 开发环境硬件环境 电脑：Windows 10 Home x64 Apollo STM32F767开发板(ST-LINK V2仿真器) 软件环境 Keil Version 5.24.1 (Pack Installer：Keil.STM32F7xx_DFP.2.9.0.pack) STM32CubeMX Version 4.25.0(Packages Manager：STM32CubeF7) GPIO基本用法&emsp;使用GPIO的基本流程为：使能GPIO对应端口时钟、配置IO参数、控制IO输出或者读取IO状态。 使能GPIO端口时钟&emsp;任何需要使用IO端口的外设使用前都必须使能对应地IO端口时钟。对于不考虑功耗的系统，可以直接将所有的IO端口时钟全部打开。 1234567891011121314void RCC_CLK_Enable(void)&#123; /* GPIO Ports Clock Enable */ __HAL_RCC_GPIOA_CLK_ENABLE(); __HAL_RCC_GPIOB_CLK_ENABLE(); __HAL_RCC_GPIOC_CLK_ENABLE(); __HAL_RCC_GPIOD_CLK_ENABLE(); __HAL_RCC_GPIOE_CLK_ENABLE(); __HAL_RCC_GPIOF_CLK_ENABLE(); __HAL_RCC_GPIOG_CLK_ENABLE(); __HAL_RCC_GPIOH_CLK_ENABLE(); __HAL_RCC_GPIOI_CLK_ENABLE(); &#125; 设置IO参数12345678910111213141516171819202122void MX_GPIO_Init(void)&#123; GPIO_InitTypeDef GPIO_InitStruct; /*Configure GPIO pin Output Level */ HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0|GPIO_PIN_1, GPIO_PIN_RESET); /*Configure GPIO pins : PB0 PB1 */ GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct); /*Configure GPIO pin : PH3 */ GPIO_InitStruct.Pin = GPIO_PIN_3; GPIO_InitStruct.Mode = GPIO_MODE_INPUT; GPIO_InitStruct.Pull = GPIO_PULLUP; HAL_GPIO_Init(GPIOH, &amp;GPIO_InitStruct);&#125; &emsp;IO的初始化参数通过GPIO_InitStruct结构体设置，对于输入IO，需要的设置如下： PIN脚号； IO模式：可以选择push pull或者open drain； IO上下拉设置：可以选择上拉、下拉或者不进行上拉下拉； IO速度：可以设置IO的翻转速度，具体可以参考器件的手册； 调用HAL_GPIO_Init()函数完成IO初始化。 &emsp;对于输入IO，与输出IO不同的设置如下： IO模式：选择input模式； IO速度：无需设置。 输出IO的控制&emsp;IO的输出通过HAL_GPIO_WritePin()/HAL_GPIO_TogglePin()实现，后文举例说明。 输入IO的读取&emsp;IO的输入数据通过HAL_GPIO_ReadPin()实现，后文举例说明。 GPIO使用示例&emsp;示例代码如下所示。 12345678910if (HAL_GPIO_ReadPin(GPIOH, GPIO_PIN_3) == GPIO_PIN_RESET)&#123; HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_SET); HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_0); while (HAL_GPIO_ReadPin(GPIOH, GPIO_PIN_3) == GPIO_PIN_RESET);&#125;else&#123; HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_RESET);&#125; &emsp;该代码的功能是检测到port H PIN3为低电平后，翻转port B PIN1，同时点亮port B PIN1。 OLED的使用&emsp;本文使用的OLED显示屏使用4个GPIO即可完成驱动。只需要移植底层IO代码，上层应用可以直接使用，底层代码实现如下。 12345678910111213141516171819void LCD_Hardware_Init()&#123; /*Configure GPIO pins : PC6 PC7 PC8 PC9 */ __HAL_RCC_GPIOE_CLK_ENABLE(); GPIO_InitTypeDef GPIO_InitStruct; GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_LOW; HAL_GPIO_Init(GPIOE, &amp;GPIO_InitStruct);&#125;#define oledSCL_1 HAL_GPIO_WritePin(GPIOE, GPIO_PIN_2, GPIO_PIN_SET)#define oledSCL_0 HAL_GPIO_WritePin(GPIOE, GPIO_PIN_2, GPIO_PIN_RESET)#define oledSDA_1 HAL_GPIO_WritePin(GPIOE, GPIO_PIN_3, GPIO_PIN_SET)#define oledSDA_0 HAL_GPIO_WritePin(GPIOE, GPIO_PIN_3, GPIO_PIN_RESET)#define oledRST_1 HAL_GPIO_WritePin(GPIOE, GPIO_PIN_4, GPIO_PIN_SET)#define oledRST_0 HAL_GPIO_WritePin(GPIOE, GPIO_PIN_4, GPIO_PIN_RESET)#define oledDC_1 HAL_GPIO_WritePin(GPIOE, GPIO_PIN_5, GPIO_PIN_SET)#define oledDC_0 HAL_GPIO_WritePin(GPIOE, GPIO_PIN_5, GPIO_PIN_RESET) &emsp;OLED显示屏可以进行字符串、数字以及简单图标的展示，便于系统调试。 UART基本用法&emsp;使用UART的基本流程为：初始化huart1结构体、调用HAL_UART_Init()函数完成初始化。 huart1结构体参数初始化&emsp;huart1结构体主要包含了串口参数，例如波特率、数据长度、停止位、奇偶校验位等。之后调用HAL_UART_Init()函数完成初始化。 12345678910111213141516171819202122UART_HandleTypeDef huart1;/* USART1 init function */void MX_USART1_UART_Init(void)&#123; huart1.Instance = USART1; huart1.Init.BaudRate = 115200; huart1.Init.WordLength = UART_WORDLENGTH_8B; huart1.Init.StopBits = UART_STOPBITS_1; huart1.Init.Parity = UART_PARITY_NONE; huart1.Init.Mode = UART_MODE_TX_RX; huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart1.Init.OverSampling = UART_OVERSAMPLING_16; huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE; huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT; if (HAL_UART_Init(&amp;huart1) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125;&#125; HAL_UART_Init()的功能&emsp;HAL_UART_Init()函数的内容如下所示。除参数合理性检测之外，将调用HAL_UART_MspInit()完成硬件IO的初始化、调用UART_SetConfig()完成UART参数的初始化。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/** * @brief Initializes the UART mode according to the specified * parameters in the UART_InitTypeDef and creates the associated handle . * @param huart uart handle * @retval HAL status */HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)&#123; /* Check the UART handle allocation */ if(huart == NULL) &#123; return HAL_ERROR; &#125; if(huart-&gt;Init.HwFlowCtl != UART_HWCONTROL_NONE) &#123; /* Check the parameters */ assert_param(IS_UART_HWFLOW_INSTANCE(huart-&gt;Instance)); &#125; else &#123; /* Check the parameters */ assert_param(IS_UART_INSTANCE(huart-&gt;Instance)); &#125; if(huart-&gt;gState == HAL_UART_STATE_RESET) &#123; /* Allocate lock resource and initialize it */ huart-&gt;Lock = HAL_UNLOCKED; /* Init the low level hardware : GPIO, CLOCK */ HAL_UART_MspInit(huart); &#125; huart-&gt;gState = HAL_UART_STATE_BUSY; /* Disable the Peripheral */ __HAL_UART_DISABLE(huart); /* Set the UART Communication parameters */ if (UART_SetConfig(huart) == HAL_ERROR) &#123; return HAL_ERROR; &#125; if (huart-&gt;AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT) &#123; UART_AdvFeatureConfig(huart); &#125; /* In asynchronous mode, the following bits must be kept cleared: - LINEN and CLKEN bits in the USART_CR2 register, - SCEN, HDSEL and IREN bits in the USART_CR3 register.*/ CLEAR_BIT(huart-&gt;Instance-&gt;CR2, (USART_CR2_LINEN | USART_CR2_CLKEN)); CLEAR_BIT(huart-&gt;Instance-&gt;CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN)); /* Enable the Peripheral */ __HAL_UART_ENABLE(huart); /* TEACK and/or REACK to check before moving huart-&gt;gState and huart-&gt;RxState to Ready */ return (UART_CheckIdleState(huart));&#125;void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)&#123; GPIO_InitTypeDef GPIO_InitStruct; if(uartHandle-&gt;Instance==USART1) &#123; /* USER CODE BEGIN USART1_MspInit 0 */ /* USER CODE END USART1_MspInit 0 */ /* USART1 clock enable */ __HAL_RCC_USART1_CLK_ENABLE(); /**USART1 GPIO Configuration PA9 ------&gt; USART1_TX PA10 ------&gt; USART1_RX */ GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH; GPIO_InitStruct.Alternate = GPIO_AF7_USART1; HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct); /* USER CODE BEGIN USART1_MspInit 1 */ /* USER CODE END USART1_MspInit 1 */ &#125;&#125; UART的发送与接收&emsp;UART的发送与接收通过HAL_UART_Transmit()/HAL_UART_Receive()实现，示例如下。 123456if (__HAL_UART_GET_FLAG(&amp;huart1,UART_FLAG_RXNE)==SET)&#123; HAL_UART_Receive(&amp;huart1, usart1_rx, 1, 1000); HAL_UART_Transmit(&amp;huart1,(uint8 *)\"\\nYou send: \",11,1000); HAL_UART_Transmit(&amp;huart1,usart1_rx, 1,1000);&#125; &emsp;当检测到串口RXNE标志位为1时，表示此时串口接收到信息，即调用HAL_UART_Receive()函数进行读取。读取后通过HAL_UART_Transmit()发送提示信息与接收到的信息。事实上可以直接调用HAL_UART_Receive()函数轮询串口，当返回值为HAL_TIMEOUT时即表示没有接收到信息。 UART发送函数的简化&emsp;读取HAL_UART_Transmit()的实现流程，其相对复杂。对于通常用到的场景来说，可以进行简化，即采用寄存器方式操作。具体实现如下。 123456// Transmit a character from the SCIvoid scia_xmit(int ch)&#123; while ((USART1-&gt;ISR &amp; USART_ISR_TC_Msk) == FALSE); USART1-&gt;TDR = (uint8)(ch &amp; 0xFF);&#125; &emsp;该函数实现了单个字符的发送，注意对字符与0xff的&amp;操作表示发送的数据位为8位。 &emsp;基于该函数还可以封装诸如发送字符串、数字、不同进制数的相关函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include \"uart.h\"// Test 1,SCIA DLB, 8-bit word, baud rate 0x000F, default, 1 STOP bit, no parity// Transmit a character from the SCIvoid scia_xmit(int ch)&#123; while ((USART1-&gt;ISR &amp; USART_ISR_TC_Msk) == FALSE); USART1-&gt;TDR = (uint8)(ch &amp; 0xFF);&#125;void scia_msg(char * msg)&#123; int i; i = 0; while(msg[i] != '\\0') &#123; scia_xmit(msg[i]); i++; &#125;&#125;void uart_printf(char * msg)&#123; int i; i = 0; while(msg[i] != '\\0') &#123; scia_xmit(msg[i]); i++; &#125;&#125;void uart_print_data(int32 data)&#123; int i = 0; char temp[7]; if (data &lt; 0) &#123; data = - data; temp[0] = '-'; &#125; else temp[0] = ' '; temp[1] = data / 10000 + '0'; temp[2] = (data % 10000) /1000 + '0'; temp[3] = (data % 1000 ) /100 + '0'; temp[4] = (data % 100 ) /10 + '0'; temp[5] = (data % 10 ) /1 + '0'; temp[6] = '\\0'; while(temp[i] != '\\0') &#123; scia_xmit(temp[i]); i++; &#125;&#125;void uart_print_info(char * msg, int32 data)&#123; uart_printf(msg); uart_printf(\": \"); uart_print_data(data); uart_printf(\"\\n\");&#125;void printNumber(unsigned long n, uint8 base) &#123; char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte. char *str = &amp;buf[sizeof(buf) - 1]; *str = '\\0'; // prevent crash if called with base == 1 if (base &lt; 2) base = 10; do &#123; unsigned long m = n; n /= base; char c = m - base * n; *--str = c &lt; 10 ? c + '0' : c + 'A' - 10; &#125; while(n); uart_printf(str);&#125;// Receive a character from the SCIuint8 scia_recv(void)&#123; uint8 ch; while ((USART1-&gt;ISR &amp; UART_FLAG_RXNE) == FALSE); ch = USART1-&gt;RDR &amp; 0xFF; return ch;&#125; UART接收函数的简化&emsp;同理，HAL_UART_Receive()函数的实现也相对复杂，这里进行一个简单简化。 12345678// Receive a character from the SCIuint8 scia_recv(void)&#123; uint8 ch; while ((USART1-&gt;ISR &amp; UART_FLAG_RXNE) == FALSE); ch = USART1-&gt;RDR &amp; 0xFF; return ch;&#125; &emsp;该函数实现了阻塞等待方式读取一个接收字符。 简化的UART发送接收&emsp;示例代码如下，其实现的功能与基于HAL的发送接收函数一致，但是得到了明显简化。 123456if ((USART1-&gt;ISR &amp; USART_ISR_RXNE_Msk) != FALSE)&#123; usart1_rx[0] = USART1-&gt;RDR &amp; 0xFF; uart_printf(\"\\nYou send: \"); scia_xmit(usart1_rx[0]);&#125;","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://jiaodi.tech/categories/嵌入式/"}],"tags":[{"name":"GPIO","slug":"GPIO","permalink":"http://jiaodi.tech/tags/GPIO/"},{"name":"STM32F7","slug":"STM32F7","permalink":"http://jiaodi.tech/tags/STM32F7/"},{"name":"UART","slug":"UART","permalink":"http://jiaodi.tech/tags/UART/"}]},{"title":"STM32F767 delay函数的HAL库实现与优化","slug":"stm32f767-delay","date":"2018-03-29T11:48:22.000Z","updated":"2018-04-05T10:07:31.523Z","comments":true,"path":"2018/03/29/stm32f767-delay/","link":"","permalink":"http://jiaodi.tech/2018/03/29/stm32f767-delay/","excerpt":"&emsp;本文介绍STM32F767 delay函数的HAL库实现与优化。","text":"&emsp;本文介绍STM32F767 delay函数的HAL库实现与优化。 开发环境硬件环境 电脑：Windows 10 Home x64 Apollo STM32F767开发板(ST-LINK V2仿真器) 软件环境 Keil Version 5.24.1 (Pack Installer：Keil.STM32F7xx_DFP.2.9.0.pack) STM32CubeMX Version 4.25.0(Packages Manager：STM32CubeF7) HAL库实现方式&emsp;首先了解HAL库中delay的实现方式。 SYSTICK初始化&emsp;初始化函数如下所示。 12345678910 /**Configure the Systick interrupt time */HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000); /**Configure the Systick */HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);/* SysTick_IRQn interrupt configuration */HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0); &emsp;初始化函数中将SYSTICK时钟源设置为HCLK，同时将SYSTICK中断周期设置为1ms。 SYSTICK中断函数&emsp;中断函数如下所示。 123456789101112131415161718192021222324/** * @brief This function handles SysTick Handler. * @param None * @retval None */void SysTick_Handler(void)&#123; HAL_IncTick();&#125;__weak void HAL_IncTick(void)&#123; uwTick += uwTickFreq;&#125;HAL_TickFreqTypeDef uwTickFreq = HAL_TICK_FREQ_DEFAULT; /* 1KHz */typedef enum&#123; HAL_TICK_FREQ_10HZ = 100U, HAL_TICK_FREQ_100HZ = 10U, HAL_TICK_FREQ_1KHZ = 1U, HAL_TICK_FREQ_DEFAULT = HAL_TICK_FREQ_1KHZ&#125; HAL_TickFreqTypeDef; &emsp;中断服务函数的最终功能是对uwTick进行加1操作，即1ms中断则uwTick增加1。 delay函数&emsp;函数实现如下所示。 1234567891011121314151617181920__weak void HAL_Delay(uint32_t Delay)&#123; uint32_t tickstart = HAL_GetTick(); uint32_t wait = Delay; /* Add a freq to guarantee minimum wait */ if (wait &lt; HAL_MAX_DELAY) &#123; wait += (uint32_t)(uwTickFreq); &#125; while ((HAL_GetTick() - tickstart) &lt; wait) &#123; &#125;&#125;__weak uint32_t HAL_GetTick(void)&#123; return uwTick;&#125; &emsp;delay函数的实现比较清晰，首先利用tickstart存储uwTick当前值，wait值为所需延时ms数，程序将轮询检测uwTick当前值与tickstart差值是否小于wait，直到达到所需延迟数则跳出循环。 delay函数的缺陷&emsp;HAL库给出的delay函数实现了ms级别的延时，但是有2点严重不足。 延时准确性难以保证：uwTick在SYSTICK中断中增加，但是SYSTICK本身的中断可能被更高优先级的中断打断，这将导致uwTick延迟增加。当前程序设置中SYSTICK的中断优先级设置到最高，但是实际系统中中断优先级需要根据任务的重要性来设置，通常SYSTICK不会是最高优先级的中断； 延时分辨率不够：delay函数只能实现ms级别的延时，更短时间的延时无法实现。 &emsp;基于以上考虑，需要对delay函数进行优化。 Delay函数的优化SYSTICK初始化&emsp;初始化函数如下所示。 1234567891011121314151617181920212223#define SYSTICK_Frequency 1000 //in Hzstatic uint32 systick_load = 0; // SysTick load value, period 1000/SYSTICK_Frequency msstatic uint32 systick_per_us = 0; // SysTick delta value per usuint32 delay_us_max = 0; //max value in Delay_US/**Configure the Systick interrupt time*/systick_load = HAL_RCC_GetHCLKFreq()/SYSTICK_Frequency; HAL_SYSTICK_Config(systick_load); systick_per_us = systick_load * SYSTICK_Frequency / 1000 / 1000;//systick_per_us = HAL_RCC_GetHCLKFreq() / 1000 / 1000; delay_us_max = UINT32_MAX / systick_per_us; /**Configure the Systick*/HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);/* SysTick_IRQn interrupt configuration */HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0); &emsp;针对各个变量的说明见下图。 变量 说明 SYSTICK_Frequency SYSTICK中断频率，单位为Hz。 systick_load SYSTICK reload值，reload等于SYSTICK时钟频率/SYSTICK_Frequency，使得中断频率为SYSTICK_Frequency。 1000/SYSTICK_Frequency SYSTICK中断周期，单位为ms。 systick_load * SYSTICK_Frequency / 1000 1ms SYSTICK计数器的变化值。 systick_per_us 1us SYSTICK计数器的变化值。 delay_us_max SYS_Delay_US()函数允许的最大延时us数，由UINT32_MAX与systick_per_us决定。 最后得到的delay_us_max值为：19884107，即延时最大周期不超过19884107us，约19.8s。 delay函数&emsp;函数如下所示。 12345678910111213141516171819202122232425262728293031void SYS_Delay_US(uint32_t delay_us)&#123; uint32 systick_pre = SysTick-&gt;VAL; uint32 systick_now = 0; uint32 delay_total = 0; uint32 delay_sum = 0; if (delay_us &gt; delay_us_max) &#123; while (1); &#125; delay_total = systick_per_us * delay_us; while (delay_total &gt; delay_sum) &#123; systick_now = SysTick-&gt;VAL; if (systick_now &lt; systick_pre) &#123; delay_sum += systick_pre - systick_now; systick_pre = systick_now; &#125; else if (systick_now &gt; systick_pre) &#123; delay_sum += systick_load - (systick_now - systick_pre); systick_pre = systick_now; &#125; &#125;&#125; &emsp;程序的逻辑比较简明，核心思想为不断获取SysTick计数值的改变量，对改变量进行累加以推算延时时间；当延时时间达到预期则跳出循环。简单介绍如下。 进入程序后立即保存当前SysTick计数值，便于后续比较； 检测delay_us值是否超限，超限则停止运行告警； delay_total为延时需要的SysTick计数值改变量； 使用systick_now获取当前SysTick计数值，与systick_pre进行对比。SysTick-&gt;VAL为递减计数器，如果未发生reload，则改变值为systick_pre - systick_now；如果发生了reload，则改变值为systick_load - (systick_now - systick_pre)； delay_sum为SysTick总的改变量，当大于delay_total则跳出循环。 &emsp;注意，该函数成立的前提有一个基本假设，即2次使用systick_now获取当前SysTick计数值之间最多发生一次reload，如果发生2次及以上以上程序无法分辨，则只会计数一次，则延时值不准确。事实上SysTick的中断一般为ms级别，同时STM32F7的运算速度很高，systick_now获取当前SysTick计数值的实时性很高，不会出现假设中描述的异常。 实验验证&emsp;main函数中对SYS_Delay_US()函数进行测试，程序如下。 1234567while (1) &#123; mainloop++; HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_0); HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1); SYS_Delay_US(100); &#125; &emsp;使用逻辑分析仪检测PB1电平变化，与预期一致。","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://jiaodi.tech/categories/嵌入式/"}],"tags":[{"name":"STM32F7","slug":"STM32F7","permalink":"http://jiaodi.tech/tags/STM32F7/"},{"name":"STM32CubeMX","slug":"STM32CubeMX","permalink":"http://jiaodi.tech/tags/STM32CubeMX/"},{"name":"Systick","slug":"Systick","permalink":"http://jiaodi.tech/tags/Systick/"}]},{"title":"STM32F767系统内核与时钟设置","slug":"stm32f767-system","date":"2018-03-23T12:48:14.000Z","updated":"2018-03-27T13:00:30.785Z","comments":true,"path":"2018/03/23/stm32f767-system/","link":"","permalink":"http://jiaodi.tech/2018/03/23/stm32f767-system/","excerpt":"&emsp;本文介绍如何对STM32F767的系统内核与时钟进行设置。","text":"&emsp;本文介绍如何对STM32F767的系统内核与时钟进行设置。 开发环境硬件环境 电脑：Windows 10 Home x64 Apollo STM32F767开发板(ST-LINK V2仿真器) 软件环境 Keil Version 5.24.1 (Pack Installer：Keil.STM32F7xx_DFP.2.9.0.pack) STM32CubeMX Version 4.25.0(Packages Manager：STM32CubeF7) 系统设置&emsp;STM32F767基于强大的Cortex-M7内核，其许多系统特性需要进行设置以发挥最高性能。 设置Flash Interface&emsp;STM32F767的flash支持TCM与AXI接口，而Chrom-Art Accelerator与Instruction Prefetch仅支持在TCM模式下使用。因此，需要首先将flash配置为TCM接口。TCM接口的选择通过BOOT引脚以及Flash选项控制寄存器FLASH_OPTCR1进行设置。 &emsp;当BOOT pin=0时，FLASH_OPTCR1寄存器关于BOOT的选项如下所示。 &emsp;默认状态下，BOOT_ADD0的值为0x80，即默认以TCM接口启动。 &emsp;可以通过读取Flash默认配置以确认Flash接口，程序如下所示。 123FLASH_OBProgramInitTypeDef Flash_InitStruct;HAL_FLASHEx_OBGetConfig(&amp;Flash_InitStruct); &emsp;可以看到系统默认状态下BOOT_ADD0的值为0x80。 使能Chrom-Art Accelerator与Instruction Prefetch&emsp;Chrom-Art Accelerator™ (DMA2D) 是专用于图像处理的专业 DMA，将其开启有利于提升图像相关处理速度。Instruction Prefetch即为指令预读取，ST对其的解释是： 每个 flash 读操作可读取 256 位，可以是 8 行 32 位指令，也可以是 16 行 16 位指令，具体取决于烧写在 Flash 中的程序。因此对于顺序执行的代码，至少需要 8 个 CPU 周期来执行前一指令行的读取操作。在 CPU 对当前指令行进行操作请求时，可使用 ITCM 总线的预取操作读取 Flash 中的下一个连续存放的指令行。可通过将 FLASH_ACR 寄存器中的 PRFTEN位置 1 来使能预取功能。当访问 Flash 至少需要一个等待周期时，此功能非常有用。处理非顺序执行的代码（有分支）时，指令可能并不存在于当前使用的指令行以及预取的指令行中。在这种情况下，CPU 延迟周期数至少等于等待周期数。 &emsp;Art Accelerator与Instruction Prefetch的启动在HAL_Init()函数中完成。HAL_Init()函数如下所示。 123456789101112131415161718192021222324HAL_StatusTypeDef HAL_Init(void)&#123; /* Configure Instruction cache through ART accelerator */ #if (ART_ACCLERATOR_ENABLE != 0) __HAL_FLASH_ART_ENABLE();#endif /* ART_ACCLERATOR_ENABLE */ /* Configure Flash prefetch */#if (PREFETCH_ENABLE != 0U) __HAL_FLASH_PREFETCH_BUFFER_ENABLE();#endif /* PREFETCH_ENABLE */ /* Set Interrupt Group Priority */ HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4); /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */ HAL_InitTick(TICK_INT_PRIORITY); /* Init the low level hardware */ HAL_MspInit(); /* Return function status */ return HAL_OK;&#125; &emsp;注意到ART_ACCLERATOR_ENABLE与PREFETCH_ENABLE为控制关键字，其定义在stm32f7xx_hal_conf.h文件中，将其设置为1即表示ART Accelerator与Prefetch启用。 123456789/* ########################### System Configuration ######################### *//** * @brief This is the HAL system configuration section */ #define VDD_VALUE ((uint32_t)3300U) /*!&lt; Value of VDD in mv */#define TICK_INT_PRIORITY ((uint32_t)0x0FU) /*!&lt; tick interrupt priority */#define USE_RTOS 0U#define PREFETCH_ENABLE 1U#define ART_ACCLERATOR_ENABLE 1U /* To enable instruction cache and prefetch */ 使能I Cache与D Cache&emsp;I Cache为指令Cache，D Cache为数据Cache。Cache位于Core与SRAM或者外部RAM之间，Cache的速率较RAM更高，只要保证Cache有足够高的命中率，则可以进一步提高Core与SRAM或者外部RAM之间的数据交互速率，进而提高性能。 &emsp;在system.c文件中建立如下函数。 1234567891011//enable CPU L1-Cachevoid Cache_Enable(void)&#123; SCB_InvalidateICache();//enable I Cache. SCB_EnableICache(); SCB_InvalidateDCache();//enable D Cache. SCB_EnableDCache(); SCB-&gt;CACR|=1&lt;&lt;2; //Enables Force Write-Through. All Cacheable memory regions are treated as Write-Through.&#125; &emsp;关于Cache的函数说明在Keil官网中CMSIS-Core (Cortex-M)部分，同时安装STM32CubeMX 后CMSIS文件夹下也有相关文档，与官网一致。 &emsp;注意到在I/D Cache使能前均使用Invalidate相关函数无效化了Cache中的数据，官网中明确提出系统复位后，必须在Enable函数前首先应用Invalidate函数。可以理解在系统复位后，Cache中的指令\\数据是无效的，为了避免dirty指令\\数据影响系统运行，则首先将其无效化。 &emsp;再有一个重要操作是对SCB-&gt;CACR寄存器FORCEWT进行使能，进行强制Write-Through。这里主要是为了解决Cache的一致性问题。关于Cache的一致性问题可以参考文档AN4839: Level 1 cache on STM32F7 Series and STM32H7 Series。根据STM32F7 MPU Cache浅析一文，一致性问题的主要发生在两种情形： 第一种情况是当有写物理内存的指令时，core会先去更新相应的cache-line(Write-back策略)，在没有clean的情况下，会导致其对应的实际物理内存中的数据并没有被更新，如果这个时候有其它的Host（如DMA）访问这段内存时，就会出现问题（由于实际物理内存并未被更新，和D-cache中的不一致），这就是所谓的cache一致性的问题！ 第二种情况是DMA更新了某段物理内存（DMA和cache直接没有直接通道），而这个时候Core再读取这段内存的时候，由于相对应地址的cache-line没有被invalidate，导致Core读到的是cache-line中的数据，而非被DMA更新过的实际物理内存的数据！ &emsp;针对Cache一致性问题，以上提到的两篇文章也给出了相应的解决方法。 MPU配置的代码，将属性改为MPU_ACCESS_BUFFERABLE，即使用write-though策略而非默认的write-back策略； 通过Cache控制寄存器SCB-&gt;CACR，将所有cacheable的空间全部强制write-though； 在对cacheable内存区域写数据时，进行cache maintenance操作，即CleanCache操作，将dirty data更新到真实的物理地址中； 修改MPU SRAM1区域到共享区域，可以避免默认状态下SRAM1可被D Cache缓存。 &emsp;当前程序中使用第2种方法，实际上这对性能是有损失的，后续将尝试使用更高效方法。直觉上方法1与方法2都一定程序抑制了Cache的性能，方法4则直接将SRAM1设置为不缓存，方法3应该是对性能影响最低但是操作需要异常小心的方法。 时钟设置时钟树&emsp;STM32F767的时钟系统比较复杂，时钟树总体如图所示。 时钟源&emsp;STM32F767的时钟源有5个，分别列举说明如下。 LSI：Low Speed Internal，内部低速时钟，为RC振荡器构成，频率约为32KHz； LSE：Low Speed External，外部低速时钟，由外部晶体提供，当前硬件此时钟为32.768kHz； HSI：High Speed Internal，内部高速时钟，为RC振荡器构成，频率约为16MHz； HSE：High Speed External，外部高速时钟，由外部晶体提供，当前硬件此时钟为25MHz； PLLCLK：锁相环输出时钟。 SYSCLK设置&emsp;SYSCLK时钟的设置可以基于STM32CubeMX 生成代码，STM32CubeMX 的设置原理如下图所示。 &emsp;使用STM32CubeMX 设置时钟非常方便，图中基本的设置为：启用HSE时钟，时钟为25MHz，将其作为PLL时钟源。PLLM=25，PLLN=432，PLLP=2，最后得到的PLLCLK为： $$PLLCLK=HSE\\cdot \\frac{1}{25}\\cdot 432\\cdot \\frac{1}{2}=216MHz$$ &emsp;SYSCLK的时钟源选择PLLCLK，即为216MHz，这是系统允许的最高时钟。 &emsp;当SYSCLK设置完毕后，分别设置SYSTICK，APB1与APB2分频系数，可以得到如图所示的各自时钟频率。 RTC时钟设置&emsp;RTC时钟需要精准的时钟源，而外部时钟的精度通常高于内部时钟，因此RTC时钟源需要选择外部晶体。RTC的使用需要额外设置，后续章节再进行详细介绍。 代码实现&emsp;时钟初始化的代码实现如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * @brief System Clock Configuration * @retval None */void SystemClock_Config(void)&#123; RCC_OscInitTypeDef RCC_OscInitStruct; RCC_ClkInitTypeDef RCC_ClkInitStruct; /**Configure the main internal regulator output voltage */ __HAL_RCC_PWR_CLK_ENABLE(); __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1); /**Initializes the CPU, AHB and APB busses clocks */ RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 25; RCC_OscInitStruct.PLL.PLLN = 432; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 2; if (HAL_RCC_OscConfig(&amp;RCC_OscInitStruct) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; /**Activate the Over-Drive mode */ if (HAL_PWREx_EnableOverDrive() != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; /**Initializes the CPU, AHB and APB busses clocks */ RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2; if (HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; /**Configure the Systick interrupt time */ HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000); /**Configure the Systick */ HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK); /* SysTick_IRQn interrupt configuration */ HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);&#125; &emsp;对代码的几个重点进行补充说明。 __HAL_RCC_PWR_CLK_ENABLE()&emsp;该函数用于使能APB1电源接口时钟。 __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1)&emsp;该函数用于设置内部调压器输出电压输出电压，即调节PWR_CR1寄存器VOS位，设置为SCALE1即为同时打开HAL_PWREx_EnableOverDrive()才能将HCLK设置为216MHz。具体说明参见SMT32F767用户手册3.3.3节。 时钟初始化&emsp;对时钟的初始化为常规调用，参数与本文说明吻合，不再继续说明。 HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_7)&emsp;该函数为flash延迟设置，当系统供电电压与HCLK明确后，按照下表设置flash延迟数。 SYSTICK初始化&emsp;SYSTICK初始化将其周期设置为1ms，时钟源为HCLK，同时设置为最高优先级。","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://jiaodi.tech/categories/嵌入式/"}],"tags":[{"name":"STM32F7","slug":"STM32F7","permalink":"http://jiaodi.tech/tags/STM32F7/"},{"name":"STM32CubeMX","slug":"STM32CubeMX","permalink":"http://jiaodi.tech/tags/STM32CubeMX/"},{"name":"Keil","slug":"Keil","permalink":"http://jiaodi.tech/tags/Keil/"}]},{"title":"新建一个STM32F767工程(基于HAL库)","slug":"stm32f767newpro","date":"2018-03-18T12:51:20.000Z","updated":"2018-03-23T13:19:52.322Z","comments":true,"path":"2018/03/18/stm32f767newpro/","link":"","permalink":"http://jiaodi.tech/2018/03/18/stm32f767newpro/","excerpt":"&emsp;使用STM32CubeMX可以生成一个直接可用的Keil工程，但为了加深对程序框架的理解与把控，从零开始新建一个工程也是有必要的，本文将简述这一过程。","text":"&emsp;使用STM32CubeMX可以生成一个直接可用的Keil工程，但为了加深对程序框架的理解与把控，从零开始新建一个工程也是有必要的，本文将简述这一过程。 开发环境硬件环境 电脑：Windows 10 Home x64 Apollo STM32F767开发板(ST-LINK V2仿真器) 软件环境 Keil Version 5.24.1 (Pack Installer：Keil.STM32F7xx_DFP.2.9.0.pack) STM32CubeMX Version 4.25.0(Packages Manager：STM32CubeF7) 文件准备参照库&emsp;工程的建立基于ST官方的库函数，即STM32CubeF7固件库中的相关文件。库文件如图所示，当前使用的固件库版本为V1.11.0。 建立工程文件夹&emsp;选择创建工程的目录，在该目录下新建demo文件夹存储工程。在demo文件夹下，建立Drivers、Inc、MDK-ARM、Src四个子文件夹，同时依照如下方法在子文件夹中增加相应文件。 增加Drivers文件夹及相关文件&emsp;在demo文件夹下新建Drivers文件夹，并按照如下方式增加相应文件。 Drivers\\CMSIS\\Include&emsp;建立Drivers\\CMSIS\\Include文件夹，将STM32CubeF7固件库中Drivers\\CMSIS\\Include下如下头文件复制到文件夹中。 cmsis_armcc.h core_cm7.h core_cmFunc.h core_cmInstr.h core_cmSimd.h &emsp;以上文件均为CMSIS Cortex内核支持相关头文件。CMSIS(Cortex Microcontroller Software Interface Standard)即为ARM Cortex微处理器软件接口标准，其结构如图所示。 Drivers\\CMSIS\\STM32F7xx\\Include&emsp;建立Drivers\\CMSIS\\STM32F7xx\\Include文件夹，将STM32CubeF7固件库中Drivers\\CMSIS\\Device\\ST\\STM32F7xx\\Include中如下头文件复制到文件夹中。 文件 说明 stm32f7xx.h 外设访问层头文件，确立stm32f767xx.h被include。 stm32f767xx.h 外设访问层头文件，进行寄存器操作结构体以及掩码等相关定义。 system_stm32f7xx.h 系统相关头文件，进行系统、时钟等初始化。 Drivers\\CMSIS\\STM32F7xx\\Source&emsp;建立Drivers\\CMSIS\\STM32F7xx\\Source文件夹，将STM32CubeF7固件库中Drivers\\CMSIS\\Device\\ST\\STM32F7xx\\Source\\Templates中如下头文件复制到文件夹中。 文件 说明 system_stm32f7xx.c 与system_stm32f7xx.h对应，进行系统、时钟等初始化。 Drivers\\STM32F7xx_HAL_Driver\\Inc&emsp;建立Drivers\\STM32F7xx_HAL_Driver\\Inc文件夹，将STM32CubeF7固件库中Drivers\\STM32F7xx_HAL_Driver\\Inc中如下头文件复制到文件夹中。 文件 说明 stm32f7xx_hal.h HAL通用外设头文件 stm32f7xx_hal_cortex.h Cortex内核通用外设头文件 stm32f7xx_hal_def.h HAL通用define等头文件 stm32f7xx_hal_flash.h/stm32f7xx_hal_flash_ex.h HAL Flash以及拓展头文件 stm32f7xx_hal_gpio.h/stm32f7xx_hal_gpio_ex.h HAL GPIO以及拓展头文件 stm32f7xx_hal_pwr.h/stm32f7xx_hal_pwr_ex.h HAL PWR以及拓展头文件 stm32f7xx_hal_rcc.h/stm32f7xx_hal_rcc_ex.h HAL RCC以及拓展头文件 Drivers\\STM32F7xx_HAL_Driver\\Inc\\Legacy&emsp;建立Drivers\\STM32F7xx_HAL_Driver\\Inc\\Legacy文件夹，将STM32CubeF7固件库中Drivers\\STM32F7xx_HAL_Driver\\Inc\\Legacy中stm32_hal_legacy.h复制到文件夹中，该文件为hal库的遗留头文件。 Drivers\\STM32F7xx_HAL_Driver\\Src&emsp;建立Drivers\\STM32F7xx_HAL_Driver\\Src文件夹，将STM32CubeF7固件库中Drivers\\STM32F7xx_HAL_Driver\\Src中如下源文件复制到文件夹中。源文件与Drivers\\STM32F7xx_HAL_Driver\\Inc中头文件对应，这里不再说明。 增加Inc文件夹及相关文件&emsp;在demo文件夹下新建Inc文件夹，将STM32CubeF7固件库中Projects\\STM32F767ZI-Nucleo\\Templates\\Inc中如下头文件复制到文件夹中。 文件 说明 stm32f7xx_hal_conf.h HAL配置文件头文件 stm32f7xx_it.h HAL中断头文件 &emsp;注意，在stm32f7xx_hal_conf.h中，从第51行开始定义使能的外设，本程序的目的在于设置一个最精简工程，因此只使能必需的外设，即HAL_MODULE_ENABLED、HAL_GPIO_MODULE_ENABLED、HAL_RCC_MODULE_ENABLED、HAL_FLASH_MODULE_ENABLED、HAL_PWR_MODULE_ENABLED、HAL_CORTEX_MODULE_ENABLED使能，其余均注释掉。这里与包含的头文件源文件均是对应的。 &emsp;在Inc文件夹下新建main.h头文件，并加入代码如下。 123456#ifndef __MAIN_H#define __MAIN_H#include \"stm32f7xx_hal.h\"#endif /* __MAIN_H */ &emsp;该头文件将被include到main函数中。 增加MDK-ARM文件夹及相关文件&emsp;在demo文件夹下新建MDK-ARM文件夹，将STM32CubeF7固件库中Drivers\\CMSIS\\Device\\ST\\STM32F7xx\\Source\\Templates\\arm中startup_stm32f767xx.s头文件复制到文件夹中。该文件为处理器的启动文件。 增加Src文件夹及相关文件&emsp;在demo文件夹下新建Src文件夹，将STM32CubeF7固件库中Projects\\STM32F767ZI-Nucleo\\Templates\\Src中如下头文件复制到文件夹中。 文件 说明 stm32f7xx_hal_msp.c MCU support package源文件 stm32f7xx_it.c HAL中断源文件 &emsp;在Inc文件夹下新建main.c源文件，并加入代码如下。 1234567891011121314#include \"main.h\"uint32_t mainloop = 0;int main(void)&#123; HAL_Init(); while (1) &#123; mainloop++; &#125;&#125; &emsp;至此，文件准备完毕。 建立工程 打开keil新建工程，芯片选择STM32767IGTx，将工程文件命名为demo并保存在MDK-ARM目录下。 选中demo工程，右键打开Manage Project Items，将Targets修改为demo，按照下图依次增加Groups与其中的Files。 打开Options for Target ‘demo’-&gt;C/C++，Define中加入加入USE_HAL_DRIVER,STM32F767xx定义，该定义将引导相关头文件确定该型号芯片的相关设置。 打开Options for Target ‘demo’-&gt;C/C++，选择下方Include Paths，加入如下包含路径。这样Keil可以搜索到所需要的头文件。 打开Options for Target ‘demo’-&gt;Debug，设置仿真器为ST-Link。 打开Options for Target ‘demo’-&gt;Utilities，设置Flash算法并勾选Reset and Run，这样程序下载完毕后将自动复位运行。 编译运行程序&emsp;编译程序，采用debug方式进行烧录，同时观察mainloop变量，可以看到该变量随着执行循环而不断增加。 &emsp;至此，工程建立与测试完成。 程序结构的优化&emsp;程序完成基本功能之后，可以进行进一步的程序结构优化，具体如下。 设立mytype.h数据类型头文件&emsp;对于不同的处理器与编译器，数据类型的命名方式有所不同，为了便于程序的编写与移植，可以用typedef对数据类型进行重新定义。打开Keil_v5\\ARM\\ARMCC\\include路径下stdint.h文件，以此为参考设置自己的数据类型对照。建立mytype.h并放在demo文件夹下Inc文件夹，该文件具体内容如下。该文件应当被所有用户源文件使用。 1234567891011121314151617181920212223242526272829303132333435363738/* * mytype.h * * Created on: 2018-3-19 * Author: Di */#ifndef MYTYPE_H_#define MYTYPE_H_#include \"stdint.h\"typedef int8_t int8;typedef int16_t int16;typedef int32_t int32;typedef int64_t int64;typedef uint8_t uint8;typedef uint16_t uint16;typedef uint32_t uint32;typedef uint64_t uint64;typedef volatile int8 vint8;typedef volatile uint8 vuint8;typedef volatile int16 vint16;typedef volatile uint16 vuint16;typedef volatile int32 vint32;typedef volatile uint32 vuint32;typedef volatile int64 vint64;typedef volatile uint64 vuint64;typedef float float32;typedef double float64;#endif /* MYTYPE_H_ */ 设立commom.h通用头文件&emsp;对于不同的处理器，所有的硬件外设都需要调用库函数的通用外设头文件，以及设立的mytype.h数据类型头文件。可以建立一个commom.h通用头文件，创立新的用户文件直接将其include即可。建立commom.h并放在demo文件夹下Inc文件夹，该文件具体内容如下。 12345678910111213141516171819202122/* * common.h * * Created on: 2018-3-19 * Author: Di */#ifndef COMMON_H_#define COMMON_H_#define TRUE 1#define FALSE 0#define HIGH 1#define LOW 0#include \"stm32f7xx_hal.h\"#include \"mytype.h\"#endif /* COMMON_H_ */ 设立includes.h总包含头文件&emsp;main函数中，需要包含所有的控制文件，可以单独建立一个includes.h总包含头文件，将需要包含的头文件统一管理即可。建立includes.h并放在demo文件夹下Inc文件夹，该文件具体内容如下。 12345678910111213/* * includes.h * * Created on: 2018-3-19 * Author: Di */ #ifndef INCLUDES_H_#define INCLUDES_H_#include \"common.h\"#endif /* INCLUDES_H_ */ main.c修改&emsp;有了includes.h总包含头文件，可以将main.c函数的include中仅仅设置为includes.h一项。 一个示例工程&emsp;工程模板建立后，举例展示如何使用模板。这里添加GPIO控制相关文件。 增加gpio.h文件&emsp;建立gpio.h并放在demo文件夹下Inc文件夹，该文件具体内容如下。 1234567891011121314151617/* * gpio.h * * Created on: 2018-3-19 * Author: Di */#ifndef GPIO_H_#define GPIO_H_#include \"common.h\"void MX_GPIO_Init(void);#endif /* GPIO_H_ */ 增加gpio.c文件&emsp;建立gpio.c并放在demo文件夹下Src文件夹，该文件具体内容如下。 12345678910111213141516171819202122232425262728/* * gpio.c * * Created on: 2018年3月19日 * Author: jiaod */#include \"gpio.h\"void MX_GPIO_Init(void)&#123; GPIO_InitTypeDef GPIO_InitStruct; /* GPIO Ports Clock Enable */ __HAL_RCC_GPIOB_CLK_ENABLE(); /*Configure GPIO pin Output Level */ HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0|GPIO_PIN_1, GPIO_PIN_RESET); /*Configure GPIO pins : PB0 PB1 */ GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);&#125; includes.h中包含gpio.h&emsp;在includes.h中include gpio.h文件。在工程中Manage Project Items中Application\\User下加入gpio.c文件。 &emsp;此时，main函数中以及可以调用gpio.h/gpio.c中有关GPIO的函数。main.c文件修改如下。 1234567891011121314151617181920#include \"includes.h\"uint32_t mainloop = 0;int main(void)&#123; HAL_Init(); MX_GPIO_Init(); while (1) &#123; mainloop++; HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_0); HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1); HAL_Delay(500); &#125;&#125; &emsp;这样，就完成了程序结构的优化。","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://jiaodi.tech/categories/嵌入式/"}],"tags":[{"name":"STM32F7","slug":"STM32F7","permalink":"http://jiaodi.tech/tags/STM32F7/"},{"name":"STM32CubeMX","slug":"STM32CubeMX","permalink":"http://jiaodi.tech/tags/STM32CubeMX/"},{"name":"Keil","slug":"Keil","permalink":"http://jiaodi.tech/tags/Keil/"}]},{"title":"使用STM32CubeMX新建STM32F7工程","slug":"stm32f767-start","date":"2018-03-17T09:25:48.000Z","updated":"2018-03-17T10:52:52.116Z","comments":true,"path":"2018/03/17/stm32f767-start/","link":"","permalink":"http://jiaodi.tech/2018/03/17/stm32f767-start/","excerpt":"&emsp;本文记录STM32F7的开发环境配置与STM32CubeMX的安装配置。","text":"&emsp;本文记录STM32F7的开发环境配置与STM32CubeMX的安装配置。 &emsp;STM32F7系列是ST公司Cortex M7内核的高性能处理器。从本文开始，将逐步记录学习该处理器的心得体会。 硬件环境 电脑：Windows 10 Home x64 Apollo STM32F767开发板(ST-LINK V2仿真器) Keil的安装与配置 Keil Version 5.24.1 Pack Installer：Keil.STM32F7xx_DFP.2.9.0.pack STM32CubeMX的安装与配置 STM32CubeMX Version 4.25.0 Packages Manager：STM32CubeF7 生成LED闪烁工程新建工程&emsp;打开STM32CubeMX，选择所用的芯片型号，本次为STM32F767IGT6。 配置IO&emsp;在Pinout页面中选择所用的IO，设置为GPIO Output； &emsp;在Configuration中对IO进一步设置，例如初始化电平、输出模式、上拉下拉、输出速度等； 生成代码&emsp;选择Project-Settings，输入工程名与保存路径，选择开发工具。 &emsp;注意在Code Generator中勾选如下选项，这样初始化代码会分成独立的源文件与头文件保存在工程中。同时，第一个选项中可以选择copy only the necessary library files，这样可以降低工程文件大小。 添加执行代码&emsp;STM32CubeMX已经完成了系统以及GPIO的初始化代码，在main中添加如下代码可以控制IO翻转进而使LED闪烁。 12345678910111213while (1)&#123;/* USER CODE END WHILE *//* USER CODE BEGIN 3 */HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_0);HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1);HAL_Delay(500);loop++;&#125;/* USER CODE END 3 */ 烧录程序&emsp;编译并烧录程序，可以观察到IO对应的LED闪烁。","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://jiaodi.tech/categories/嵌入式/"}],"tags":[{"name":"STM32F7","slug":"STM32F7","permalink":"http://jiaodi.tech/tags/STM32F7/"},{"name":"STM32CubeMX","slug":"STM32CubeMX","permalink":"http://jiaodi.tech/tags/STM32CubeMX/"},{"name":"Keil","slug":"Keil","permalink":"http://jiaodi.tech/tags/Keil/"}]},{"title":"电源应用中MLCC啸叫问题的分析与解决","slug":"mlcc-noise","date":"2018-03-12T13:56:56.000Z","updated":"2018-03-14T15:52:32.155Z","comments":true,"path":"2018/03/12/mlcc-noise/","link":"","permalink":"http://jiaodi.tech/2018/03/12/mlcc-noise/","excerpt":"&emsp;本文分析电源应用中MLCC啸叫产生的机理与抑制手段。","text":"&emsp;本文分析电源应用中MLCC啸叫产生的机理与抑制手段。 &emsp;本文根据以下文章整理综合： 啸叫对策事例 (动画) How to reduce acoustic noise of MLCCs in power applications Reducing MLCCs’ piezoelectric effects and audible noise MLCC啸叫现象 &emsp;MLCC在电源应用中具有广泛的用途，其优点主要在于： 高密度容值 低寄生电阻(ESR) 低寄生电感(ESL) 高频阻抗低 无极性，易于安装制造 相比于钽电容与铝电解电容可靠性更高 低成本 &emsp;通常情况下，MLCC并不会产生噪声。但在某些特殊场合下，MLCC会引发啸叫现象。MLCC的形态如下图所示： &emsp;由于陶瓷材料的压电效应(piezoelectric effect)，当外加交流电压时其将进行收缩，如下图所示。 &emsp;当电容器收缩时，将牵引PCB震动，如下图所示。注意图中“电解的施加方向”标注错误，应为“电场的施加方向”。芯片以及电路板的振幅仅为1pm~1nm。当电路板的振动周期在人耳可以听到的频率带(20~20kHz)是，则声音可以被人耳识别。 影响啸叫的因素&emsp;影响啸叫的因素主要有以下几点，啸叫程度可以用声压级(SPL:Sound Pressure Level)衡量： 交流电压的频率是否在可闻频率带(20~20kHz) 交流电压的幅值：幅值增大则SPL增加 直流偏置电压：直流偏置电压越大，则SPL增加 电容的介电常数：介电常数越大则压电效应越强 电容的层数：电容的层数越少，产生的形变小，则SPL降低 抑制啸叫的手段降低交流电压幅值&emsp;降低纹波幅值可以通过增大电容值来实现。更重要的是，需要侧重降低可闻频率带的纹波幅值。可以测量纹波噪声的频率，针对该频带设置合理类型与容值的电容进行滤波。 使用耐压更高的电容&emsp;直流偏置电压越高SPL越大(本人猜想这与电容的容值-直流偏置电压特性有关，直流偏置电压增加，则容值降低，则纹波幅值增加，则SPL增加)。相对地，如果提高电容的耐压值，则可以降低啸叫水平。 优化PCB布局&emsp;电容器牵引PCB引起噪声。增加PCB板的厚度有助于降低牵引影响，可以降低噪声；同时，如果将电容器对称放置在PCB两侧，则理想状态下牵引力抵消，则PCB不会发生形变。 使用低噪声电容&emsp;目前村田等已经有低噪声产品推出，主要有两种降噪思路： 使用独特的陶瓷材料抑制电容器的震动； 使用支架等结构降低电容震动引起的应力。","categories":[{"name":"Hardware","slug":"Hardware","permalink":"http://jiaodi.tech/categories/Hardware/"}],"tags":[{"name":"MLCC","slug":"MLCC","permalink":"http://jiaodi.tech/tags/MLCC/"},{"name":"Noise","slug":"Noise","permalink":"http://jiaodi.tech/tags/Noise/"},{"name":"PCB","slug":"PCB","permalink":"http://jiaodi.tech/tags/PCB/"}]},{"title":"Pierce振荡器的原理与设计方法","slug":"pierce-oscillator","date":"2018-02-04T07:33:59.000Z","updated":"2018-02-10T11:30:15.215Z","comments":true,"path":"2018/02/04/pierce-oscillator/","link":"","permalink":"http://jiaodi.tech/2018/02/04/pierce-oscillator/","excerpt":"&emsp;本文介绍皮尔斯振荡器(Pierce Oscillator)的原理与设计方法。","text":"&emsp;本文介绍皮尔斯振荡器(Pierce Oscillator)的原理与设计方法。 &emsp;晶体电路是硬件设计中一个重要环节，其电路的稳定可靠直接关系到产品的使用寿命。皮尔斯振荡器(Pierce Oscillator)在硬件电路中应用广泛，本文对该电路进行学习总结。 基本原理&emsp;皮尔斯振荡器的简化框图如下：可以看作一个放大器与一个反馈网络构成。放大器的电压增益为a，相位差为$\\alpha $；反馈网络的增益为f，相位差为$\\beta $ 。 &emsp;皮尔斯振荡器是一个典型的反馈电路，其环路增益是： $$\\left | a \\right |\\cdot \\left | f \\right |\\cdot e^{j(\\alpha +\\beta )}$$ &emsp;振荡器的起振条件包含幅值与相位要求如下： $$\\left | a \\right |\\cdot \\left | f \\right |\\geqslant 1$$ $$\\alpha +\\beta = 2\\cdot n\\cdot \\pi $$ &emsp;该条件即为振荡器的巴克豪森稳定性准则(Barkhausen stability criterion)。在振荡器的环路中，运放可以提供高增益与180°的相位差；此时反馈网络将产生额外的180°相位差。当运放的相位差存在误差时，反馈网络也将自适应地调节自身相位差，以使得环路总相位差为360°。 晶体等效电路&emsp;晶体等效电路如图所示。 其中$C_{0}$为静态电容，与晶体封装以及外部电路有关，一般为若干个pF； $C_{m}$为动态等效电容，一般为若干fF； $L_{m}$为动态等效电感，一般为几十mH； $R_{s}$为动态串联等效电阻，一般为几十Ω； 注意到$C_{0}$远大于$C_{m}$，同时$C_{0}$与晶体封装有关。 等效模型阻抗表达式&emsp;晶体等效电路的阻抗表达式如下： $$Z(s)=\\frac{1}{s\\cdot C_{0}}//(s\\cdot L_{m}+R_{s}+\\frac{1}{s\\cdot C_{1}})$$ $$Z(s)=\\frac{1}{\\frac{1}{\\frac{1}{s\\cdot C_{0}}}+\\frac{1}{s\\cdot L_{m}+R_{s}+\\frac{1}{s\\cdot C_{1}}}}$$ &emsp;注意到$R_{s}$的阻抗远低于$L_{m}$与$C_{m}$，将$R_{s}$忽略以简化得到： $$Z(s)=\\frac{1}{\\frac{1}{\\frac{1}{s\\cdot C_{0}}}+\\frac{1}{s\\cdot L_{m}+\\frac{1}{s\\cdot C_{1}}}}$$ &emsp;即得到： $$Z(s)=\\frac{s^{2}\\cdot L_{m}\\cdot C_{1}+1}{s\\cdot (s^{2}\\cdot L_{m}\\cdot C_{0}\\cdot C_{1}+C_{0}+C_{1})}$$ 串联谐振频率与并联谐振频率&emsp;令上式等于0，可以得到电路的串联谐振频率$f_{ser}$: $$f_{ser}=\\frac{s_{ser}}{j\\cdot 2\\cdot \\pi }=\\frac{1}{2\\cdot \\pi\\cdot \\sqrt{L_{m}\\cdot C_{1}}}$$ &emsp;令上式等于无穷，可以得到电路地串联谐振频率$f_{par}$: $$f_{par}=\\frac{s_{par}}{j\\cdot 2\\cdot \\pi }=\\frac{1}{2\\cdot \\pi\\cdot \\sqrt{L_{m}\\cdot C_{1}}}\\cdot \\sqrt{1+\\frac{C_{1}}{C_{0}}}$$ $$f_{par}=f_{ser}\\cdot \\sqrt{1+\\frac{C_{1}}{C_{0}}}$$ &emsp;从结果上看，在并联谐振频率$f_{par}$的表达式中引入了$C_{0}$参数，$C_{0}$与晶体封装设计有关，无法保证足够的精度，因此使得并联谐振频率$f_{par}$的稳定性低于串联谐振频率$f_{ser}$ 。但是当等效电路处于串联谐振状态时，其阻抗近似等于动态串联等效电阻$R_{s}$，而芯片晶体输入管脚一般为CMOS类型，其具有高输入阻抗，这将形成严重的不匹配。 &emsp;当等效电路处于并联谐振状态时，其阻抗很高，具体阻抗值后续有推导。为了提高并联谐振频率的稳定性，可以通过增加负载电容$C_{L}$的方式降低$C_{0}$对谐振频率的影响。如下图所示： &emsp;当增加负载电容$C_{L}$时，并联谐振频率的表达式如下所示： $$f_{par}=\\frac{s_{par}}{j\\cdot 2\\cdot \\pi }=\\frac{1}{2\\cdot \\pi\\cdot \\sqrt{L_{m}\\cdot C_{1}}}\\cdot \\sqrt{1+\\frac{C_{1}}{C_{0}+C_{L}}}$$ &emsp;注意到$C_{L}$通常为数十pF，其远大于$C_{1}$，最终提高了$f_{par}$的频率稳定性，并使得$f_{par}$趋向于$f_{ser}$ 。 &emsp;典型应用中，通常在晶体两端分别设置$C_{L1}$与$C_{L2}$构成负载电容$C_{L}$，如下图所示。需要注意的是，实际电路中$C_{L}$的计算应当包含芯片管脚与PCB走线的寄生电容，这里将寄生电容记为$C_{T1}$与$C_{T2}$。 &emsp;$C_{L}$的表达式如下所示： $$C_{L}=\\frac{(C_{L1}+C_{T1})\\cdot (C_{L2}+C_{T2})}{C_{L1}+C_{T1}+C_{L2}+C_{T2}}$$ 负载电容反馈比&emsp;注意到$C_{L1}$与$C_{L2}$决定了反馈回路的分压比，反馈比例为： $$K=\\frac{C_{L2}}{C_{L1}}$$ &emsp;为了保证反馈回路的增益，在设计过程中应当尽可能提高K值。 负载电容敏感度&emsp;当晶体负载电容变化时，晶体的并联谐振频率也将发生变化。晶体的负载电容敏感度(Trim Sensitivity)定义如下： $$S=\\frac{\\frac{\\mathrm{d} f_{par}}{\\mathrm{d} C_{L}}}{f_{par}}$$ $$S=-\\frac{1}{2}\\cdot \\frac{C_{1}}{(1+\\frac{C_{1}}{C_{0}+C_{L}})\\cdot (C_{0}+C_{L})^{2}}$$ &emsp;考虑到$C_{0}$与$C_{L}$远大于$C_{1}$，上式可以近似化得： $$S\\approx -\\frac{1}{2}\\cdot \\frac{C_{1}}{(C_{0}+C_{L})^{2}}$$ $$S\\approx -\\frac{1}{2}\\cdot \\frac{C_{1}}{(C_{0}+C_{L})^{2}}\\cdot 10^{6}ppm/pF$$ &emsp;典型应用中，芯片通过调节管脚的并联等效电容用于调节晶体频偏，例如在放大器输入端调节并联电容实现晶体频偏的校准，此时等效于调节$C_{L1}$。此时晶体的并联谐振频率表达式如下： $$f_{par}=\\frac{1}{2\\cdot \\pi\\cdot \\sqrt{L_{m}\\cdot C_{1}}}\\cdot \\sqrt{1+\\frac{C_{1}}{C_{0}+\\frac{(C_{L1}+C_{T1})\\cdot (C_{L2}+C_{T2})}{C_{L1}+C_{T1}+C_{L2}+C_{T2}}}}$$ &emsp;晶体相对于$C_{L1}$的负载电容灵敏度为： $$S=\\frac{\\frac{\\mathrm{d} f_{par}}{\\mathrm{d} C_{L1}}}{f_{par}}$$ $$S=-\\frac{1}{2}\\cdot \\frac{C_{1}\\cdot \\frac{(C_{L2}+C_{T2})^{2}}{(C_{L1}+C_{T1}+C_{L2}+C_{T2})^{2}}}{(1+\\frac{C_{1}}{C_{0}+\\frac{(C_{L1}+C_{T1})\\cdot (C_{L2}+C_{T2})}{C_{L1}+C_{T1}+C_{L2}+C_{T2}}})\\cdot (C_{0}+\\frac{(C_{L1}+C_{T1})\\cdot (C_{L2}+C_{T2})}{C_{L1}+C_{T1}+C_{L2}+C_{T2}})^{2}}$$ &emsp;考虑到$C_{0}$与$C_{L}$远大于$C_{1}$，上式可以近似化得： $$S\\approx -\\frac{1}{2}\\cdot \\frac{C_{1}\\cdot \\frac{(C_{L2}+C_{T2})^{2}}{(C_{L1}+C_{T1}+C_{L2}+C_{T2})^{2}}}{(C_{0}+\\frac{(C_{L1}+C_{T1})\\cdot (C_{L2}+C_{T2})}{C_{L1}+C_{T1}+C_{L2}+C_{T2}})^{2}}$$ $$S\\approx -\\frac{1}{2}\\cdot \\frac{C_{1}\\cdot \\frac{(C_{L2}+C_{T2})^{2}}{(C_{L1}+C_{T1}+C_{L2}+C_{T2})^{2}}}{(C_{0}+\\frac{(C_{L1}+C_{T1})\\cdot (C_{L2}+C_{T2})}{C_{L1}+C_{T1}+C_{L2}+C_{T2}})^{2}} \\cdot 10^{6}ppm/pF$$ 反馈电阻&emsp;当晶体的负载电容为$C_{L}$时，晶体的并联谐振阻抗为： $$R_{p}= \\frac{1-j\\cdot \\omega \\cdot R\\cdot (C_{0}+C_{L})}{R\\cdot \\omega ^{2}\\cdot (C_{0}+C_{L})^{2}}$$ $$R_{p}\\approx \\frac{1}{R\\cdot \\omega ^{2}\\cdot (C_{0}+C_{L})^{2}}$$ &emsp;当晶体的反馈电阻为$R_{F}$时，由于反相放大器的开环增益远大于1，其输入阻抗为： $$Z_{i}=\\frac{R_{F}}{a+1} \\approx \\frac{R_{F}}{a} $$ &emsp;令$Z_{i}=R_{p}$，有 $$R_{F}=a\\cdot \\frac{1}{R\\cdot \\omega ^{2}\\cdot (C_{0}+C_{L})^{2}}$$","categories":[{"name":"Hardware","slug":"Hardware","permalink":"http://jiaodi.tech/categories/Hardware/"}],"tags":[{"name":"Pierce","slug":"Pierce","permalink":"http://jiaodi.tech/tags/Pierce/"},{"name":"oscillator","slug":"oscillator","permalink":"http://jiaodi.tech/tags/oscillator/"},{"name":"crystal","slug":"crystal","permalink":"http://jiaodi.tech/tags/crystal/"}]},{"title":"F28379D新建工程","slug":"F28379D-new-pro-cpu1","date":"2018-01-28T08:17:50.000Z","updated":"2018-01-28T13:34:45.693Z","comments":true,"path":"2018/01/28/F28379D-new-pro-cpu1/","link":"","permalink":"http://jiaodi.tech/2018/01/28/F28379D-new-pro-cpu1/","excerpt":"&emsp;TMS320F28379D是德州仪器公司C2000系列中双核系列高性能微处理器。本文简述如何为CPU1与CPU2分别新建一个工程。随着学习的深入，本文将不断更新优化。","text":"&emsp;TMS320F28379D是德州仪器公司C2000系列中双核系列高性能微处理器。本文简述如何为CPU1与CPU2分别新建一个工程。随着学习的深入，本文将不断更新优化。 开发环境&emsp;本文中开发环境如下： 操作系统：Windows 10 Home x64 Code Composer Studio : 7.1.0.00016 controlSUITE : 3.4.7 开发板：LAUNCHXL-F28379D CPU1程序&emsp;新建工程的步骤与新建一个C2000工程类似，这里将介绍主要步骤。 新建一个空项目&emsp;如图所示，在CCS中新建一个F28379D空项目。 增加头文件&emsp;在工程中新建include文件夹，将controlSuite中下列文件复制到该文件夹下： controlSUITE\\device_support\\F2837xD\\v210\\F2837xD_headers\\include controlSUITE\\device_support\\F2837xD\\v210\\F2837xD_common\\include 增加源文件&emsp;在工程中新建source文件夹，将controlSuite中下列文件复制到该文件夹下： controlSUITE\\device_support\\F2837xD\\v210\\F2837xD_common\\source 增加位域结构体支持源文件&emsp;将如下文件复制到工程根目录下： controlSUITE\\device_support\\F2837xD\\v210\\F2837xD_headers\\source\\F2837xD_GlobalVariableDefs.c controlSUITE\\device_support\\F2837xD\\v210\\F2837xD_headers\\cmd\\F2837xD_Headers_nonBIOS_cpu1.cmd 设置RAM_lnk文件&emsp;在学习过程中建议控制程序在RAM中运行，有助于提高烧写速率并保护器件。将如下文件复制到工程根目录下，同时exclude原有2837x_FLASH_lnk_cpu1.cmd文件： controlSUITE\\device_support\\F2837xD\\v210\\F2837xD_common\\cmd\\2837xD_RAM_lnk_cpu1.cmd 设置包含选项&emsp;将include文件夹添加到包含路径。 设置Predefined Symbols&emsp;TI的库文件中使用宏定义形式设置一些初始化参数以及CPU指定，需要增加如下预定义： 使用新工程进行LED闪烁实验&emsp;新建项目中main为空函数。为了检验创建的工程是否可以正常使用，这里进行简单的测试。&emsp;在这里，将main.c文件内容替换为如下内容。 12345678910111213141516171819202122232425262728293031323334353637#include \"F28x_Project.h\"int main_loop = 0;void main(void)&#123; InitSysCtrl(); DINT; InitPieCtrl(); IER = 0x0000; IFR = 0x0000; InitPieVectTable(); EALLOW; GpioCtrlRegs.GPBGMUX1.bit.GPIO34 = 0; GpioCtrlRegs.GPBMUX1.bit.GPIO34 = 0; GpioCtrlRegs.GPBDIR.bit.GPIO34 = 1; GpioCtrlRegs.GPBCSEL1.bit.GPIO34 = 0; //CPU1 selected GpioCtrlRegs.GPAGMUX2.bit.GPIO31 = 0; GpioCtrlRegs.GPAMUX2.bit.GPIO31 = 0; GpioCtrlRegs.GPADIR.bit.GPIO31 = 1; GpioCtrlRegs.GPACSEL4.bit.GPIO31 = 2; //CPU2 selected EDIS; EINT; ERTM; for(;;) &#123; GpioDataRegs.GPBTOGGLE.bit.GPIO34 = 1; DELAY_US(500000); main_loop++; &#125;&#125; &emsp;编译程序，选择CPU1进行烧写，运行程序。可以看到板子上GPIO34控制的RED LED开始闪烁，闪烁频率约为1Hz。 CPU2程序&emsp;将CPU1的程序复制，在此基础上改为CPU2程序。 更新RAM_lnk文件&emsp;删除原有2837xD_RAM_lnk_cpu1.cmd文件，更换为： controlSUITE\\device_support\\F2837xD\\v210\\F2837xD_common\\cmd\\2837xD_RAM_lnk_cpu2.cmd 更新F2837xD_Headers_nonBIOS_cpu2文件&emsp;删除F2837xD_Headers_nonBIOS_cpu1.cmd，将如下文件复制到工程根目录下： controlSUITE\\device_support\\F2837xD\\v210\\F2837xD_headers\\cmd\\F2837xD_Headers_nonBIOS_cpu2.cmd 更新Predefined Symbols&emsp;将Predefined Symbols中CPU1改为CPU2。 删除部分不支持源文件&emsp;此时编译程序，会发现source中部分源文件报错。这是因为部分外设仅支持CPU1控制。需要删除的源文件包括： F2837xD_ECap.c F2837xD_EPwm.c F2837xD_EQep.c F2837xD_Spi.c F2837xD_TempSensorConv.c F2837xD_Upp.c 使用新工程进行LED闪烁实验&emsp;在这里，将main.c文件内容替换为如下内容。 12345678910111213141516171819202122232425#include \"F28x_Project.h\"int main_loop = 0;void main(void)&#123; InitSysCtrl(); DINT; InitPieCtrl(); IER = 0x0000; IFR = 0x0000; InitPieVectTable(); EINT; ERTM; for(;;) &#123; GpioDataRegs.GPATOGGLE.bit.GPIO31 = 1; DELAY_US(50000); main_loop++; &#125;&#125; 编译程序，选择CPU2进行烧写，运行程序。可以看到板子上GPIO31控制的BLUE LED开始闪烁，闪烁频率约为10Hz。 注意F28379D烧写程序必须按照CPU1先进行，CPU2后进行的顺序。 特别鸣谢JOJO同学在本实验中的大力帮助。😄","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://jiaodi.tech/categories/嵌入式/"}],"tags":[{"name":"C2000","slug":"C2000","permalink":"http://jiaodi.tech/tags/C2000/"},{"name":"F28379D","slug":"F28379D","permalink":"http://jiaodi.tech/tags/F28379D/"},{"name":"GPIO","slug":"GPIO","permalink":"http://jiaodi.tech/tags/GPIO/"}]},{"title":"PyInstaller基本用法","slug":"python-pyinstaller","date":"2018-01-23T14:51:58.000Z","updated":"2018-01-25T14:45:24.156Z","comments":true,"path":"2018/01/23/python-pyinstaller/","link":"","permalink":"http://jiaodi.tech/2018/01/23/python-pyinstaller/","excerpt":"&emsp;PyInstaller可以将Python程序打包为一个独立的可执行程序，适用于Windows、Linux与Mac OS X等。本文简述PyInstaller的安装与基本使用方法。","text":"&emsp;PyInstaller可以将Python程序打包为一个独立的可执行程序，适用于Windows、Linux与Mac OS X等。本文简述PyInstaller的安装与基本使用方法。 &emsp;Python用于开发一些小程序非常方便，但是使用的话一般需要安装开发环境。通过PyInstaller可以将Python程序转化为一个可执行文件，例如可以在Windows下直接执行的exe文件。 开发环境&emsp;本文中开发环境如下： 操作系统：Windows 10 Home x64 Python版本：2.7.13 x64 PyInstaller的安装安装PyInstaller1pip install pyinstaller 更新PyInstaller1pip install --upgrade pyinstaller 安装当前开发者版本1pip install https://github.com/pyinstaller/pyinstaller/tarball/develop PyInstaller的使用&emsp;PyInstaller命令的语法如下所示： 1pyinstaller [options] script [script …] | specfile &emsp;关于该语法的详细介绍见官网。这里只列举出一些相对常用的用法。 option选项&emsp;option中可以设置的参数较多，常用的列举如下。 Parameter Function 备注 -D, –onedir Create a one-folder bundle containing an executable (default) 生成一个包含程序的文件夹 -F, –onefile Create a one-file bundled executable. 生成一个独立程序 p DIR, –paths DIR A path to search for imports (like using PYTHONPATH). Multiple paths are allowed, separated by ‘:’, or use this option multiple times 设置import文件路径 c, –console, –nowindowed Open a console window for standard i/o (default) 使用控制台程序 -w, –windowed, –noconsole Windows and Mac OS X: do not provide a console window for standard i/o. On Mac OS X this also triggers building an OS X .app bundle. This option is ignored in *NIX systems. 使用非控制台程序 -i , –icon FILE.ico: apply that icon to a Windows executable. FILE.exe,ID, extract the icon with ID from an exe. FILE.icns: apply the icon to the .app bundle on Mac OS X 设置程序的icon -n NAME, –name NAME Name to assign to the bundled app and spec file (default: first script’s basename) 命名生成的程序 &emsp;使用一个简单的获取系统时间然后打印的程序，代码如下。 12345678#coding:UTF-8from datetime import datetimeimport timedef timer(n): while True: print(datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")) time.sleep(n)timer(1) &emsp;对PyInstaller的使用举例如下： 生成独立exe文件&emsp;首先将在CMD命令框定位到程序所在路径，输入如下命令即可： 12cd -d D:\\pythonpyinstaller -F timer.py &emsp;之后在该目录下dist文件夹下可以看到timer.exe文件，点击执行，会发现与运行python程序效果一致。 增加程序icon&emsp;命令修改如下： 1pyinstaller -F -i D:\\python\\qq.ico timer.py &emsp;之后在该目录下dist文件夹下可以看到timer.exe文件，此时程序使用了icon。 禁用控制台&emsp;对于窗体程序，可以禁用控制台。举例一个小程序：使用graphics绘制一个圆，鼠标点击后消失，同时在程序运行中输出一个start字符串。 12345678910111213from graphics import *win = GraphWin('shape')print (\"start\")center = Point(100,100)circ = Circle(center,30)circ.setFill('blue')circ.draw(win)win.getMouse()win.close() &emsp;当程序直接通过python运行时，将输出start并画圆。 &emsp;使用如下命令生成exe文件禁用控制台，则程序仅仅进行画圆。 1pyinstaller -F -w -i D:\\python\\qq.ico graph_1.py &emsp;PyInstaller的基本使用介绍完毕。😄","categories":[{"name":"Python","slug":"Python","permalink":"http://jiaodi.tech/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://jiaodi.tech/tags/Python/"},{"name":"PyInstaller","slug":"PyInstaller","permalink":"http://jiaodi.tech/tags/PyInstaller/"}]},{"title":"使用F28069驱动温湿度传感器HDC1010","slug":"HDC1010-C2000","date":"2018-01-14T12:50:21.000Z","updated":"2018-02-04T14:51:25.506Z","comments":true,"path":"2018/01/14/HDC1010-C2000/","link":"","permalink":"http://jiaodi.tech/2018/01/14/HDC1010-C2000/","excerpt":"&emsp;HDC1010是德州仪器公司的一款高精度数字温湿度传感器，本文将介绍如何使用C2000中F28069驱动该芯片。因为篇幅限制，本文给出重要但非完整实现过程，同时有一定优化空间。","text":"&emsp;HDC1010是德州仪器公司的一款高精度数字温湿度传感器，本文将介绍如何使用C2000中F28069驱动该芯片。因为篇幅限制，本文给出重要但非完整实现过程，同时有一定优化空间。 传感器主要特性&emsp;HDC1010是一款低功耗、高精度的数字温湿度传感器。该传感器的主要特性如下： 相对湿度精度为±2%，温度精度为±0.2度； 14位测量分辨率； 睡眠模式的电流为100nA； 电源电压为2.7V至5V； I2C接口； 物理连接HDC1010引脚&emsp;芯片的引脚图如下： ADR设置：ADR1与ADR0用于设置I2C地址，当2个引脚都下拉到GND时，HDC1010的7位地址为1000000； SCL与SDA：为I2C管脚的时钟线与数据线，为开漏输出； DRDYn：数据ready标志位，低电平有效，为开漏输出。 控制器硬件连接&emsp;HDC1010的物理连接如下所示： &emsp;本次使用的MCU为德州仪器公司的TMS320F28069，连接图如上图所示。HDC1010的SCL、SDA与DRDYn需要进行上拉。其中SCL与SDA使用F28069的硬件I2C-A，DRDYn使用一个GPIO输入端口即可。 初始化软件流程与底层配置&emsp;本节将按照初始化软件流程、硬件底层配置的流程介绍。 初始化软件流程&emsp;初始化流程代码如下所示： 12345678910111213//I2C-A initializeInitI2CGpio();I2CA_Init();//HDC DRDY PIN initializeHDC_DRDY_Pin_Init();ManufacturerID = HDC_GetData(Manufacturer_ID);DeviceID = HDC_GetData(Device_ID);HDC_GetConfig();DELAY_US(40);HDC_Config = HDC_GetData(ConfigADDR); &emsp;初始化代码主要功能如下： 初始化I2C-A：用于与HDC1010通讯； 初始化DRDY PIN：用于判断data ready； 读取ManufacturerID与DeviceID：用于判断I2C通讯是否成功； 配置HDC1010：按照需求配置HDC1010； I2C-A初始化 GPIO初始化：初始化I2C GPIO，尽管硬件上已经进行上拉操作，此处I2C IO依旧进行了上拉操作； 12345678910111213141516171819void InitI2CGpio()&#123; EALLOW;/* Enable internal pull-up for the selected pins */ GpioCtrlRegs.GPBPUD.bit.GPIO32 = 0; // Enable pull-up for GPIO32 (SDAA) GpioCtrlRegs.GPBPUD.bit.GPIO33 = 0; // Enable pull-up for GPIO33 (SCLA)/* Set qualification for selected pins to asynch only */ GpioCtrlRegs.GPBQSEL1.bit.GPIO32 = 3; // Asynch input GPIO32 (SDAA) GpioCtrlRegs.GPBQSEL1.bit.GPIO33 = 3; // Asynch input GPIO33 (SCLA)/* Configure I2C pins using GPIO regs*/ GpioCtrlRegs.GPBMUX1.bit.GPIO32 = 1; // Configure GPIO32 for SDAA operation GpioCtrlRegs.GPBMUX1.bit.GPIO33 = 1; // Configure GPIO33 for SCLA operation EDIS;&#125; 时钟设置：HDC1010支持的I2C最高时钟频率为400kHz，本次设置理论值为327kHz，具体计算过程请自行查阅F28069手册确定(也许我开心了就会写一篇介绍I2C的小文😄)； 1234567// Initialize I2CI2caRegs.I2CMDR.all = 0x0000;I2caRegs.I2CSAR = 0; // Slave addressI2caRegs.I2CPSC.all = 10; // Prescaler - need 7-12 Mhz on module clkI2caRegs.I2CCLKL = 10; // NOTE: must be non zeroI2caRegs.I2CCLKH = 5; // NOTE: must be non zero I2C中断设置：使能STOP与ARDY中断； 12345678//I2caRegs.I2CIER.all = 0x24; // Enable SCD &amp; ARDY interrupts 0010 0100I2caRegs.I2CIER.bit.AAS = 0; // Addressed as slave interrupt enable bitI2caRegs.I2CIER.bit.SCD = 1; // Stop condition detected interrupt enable bitI2caRegs.I2CIER.bit.XRDY = 0; // Transmit-data-ready interrupt enable bitI2caRegs.I2CIER.bit.XRDY = 0; // Receive-data-ready interrupt enable bitI2caRegs.I2CIER.bit.ARDY = 1; // Register-access-ready interrupt enable bitI2caRegs.I2CIER.bit.NACK = 0; // No-acknowledgment interrupt enable bitI2caRegs.I2CIER.bit.ARBL = 0; // Arbitration-lost interrupt enable bit 模式与FIFO设置：使能I2C模块，使能FIFO功能； 123456789101112131415161718192021222324252627//I2caRegs.I2CMDR.all = 0x0020; // Take I2C out of reset,Stop I2C when suspendedI2caRegs.I2CMDR.bit.NACKMOD = 0; // NACK mode bitI2caRegs.I2CMDR.bit.FREE = 0; // Stop I2C when suspendedI2caRegs.I2CMDR.bit.STT = 0; // START condition bitI2caRegs.I2CMDR.bit.STP = 0; // STOP condition bitI2caRegs.I2CMDR.bit.MST = 0; // Slave modeI2caRegs.I2CMDR.bit.TRX = 0; // Receiver modeI2caRegs.I2CMDR.bit.XA = 0; // 7-bit addressing modeI2caRegs.I2CMDR.bit.RM = 0; // Nonrepeat modeI2caRegs.I2CMDR.bit.DLB = 0; // Digital loopback mode is disabledI2caRegs.I2CMDR.bit.IRS = 1; // The I2C module is enabledI2caRegs.I2CMDR.bit.STB = 0; // The I2C module is not in the START byte modeI2caRegs.I2CMDR.bit.FDF = 0; // Free data format mode is disabledI2caRegs.I2CMDR.bit.BC = 0; // 8 bits per data byte//I2caRegs.I2CFFTX.all = 0x6000; // Enable FIFO mode and TXFIFOI2caRegs.I2CFFTX.bit.I2CFFEN = 1; // Enable the I2C FIFO modeI2caRegs.I2CFFTX.bit.TXFFRST = 1; // Enable the transmit FIFO operationI2caRegs.I2CFFTX.bit.TXFFINTCLR = 0; // Clear the TXFFINT flagI2caRegs.I2CFFTX.bit.TXFFIENA = 0; // TXFFINT flag does not generate an interrupt when setI2caRegs.I2CFFTX.bit.TXFFIL = 0; // Transmit FIFO interrupt level//I2caRegs.I2CFFRX.all = 0x2040; // Enable RXFIFO, clear RXFFINTI2caRegs.I2CFFRX.bit.RXFFRST = 1; // Enable the receive FIFO operationI2caRegs.I2CFFRX.bit.RXFFINTCLR = 1; // Clear the RXFFINT flagI2caRegs.I2CFFRX.bit.RXFFIENA = 0; // RXFFINT flag does generate an interrupt when setI2caRegs.I2CFFRX.bit.RXFFIL = 0; // Receive FIFO interrupt level DRDYn PIN初始化&emsp;设置一个GPIO输入端口。 123456789101112void HDC_DRDY_Pin_Init(void)&#123; EALLOW; GpioCtrlRegs.GPAMUX1.bit.GPIO12 = 0; GpioCtrlRegs.GPADIR.bit.GPIO12 = 0; EDIS;&#125;uint8 HDC_DRDY_Read(void)&#123; return GpioDataRegs.GPADAT.bit.GPIO12;&#125; 至此，底层初始化完成。 传感器信息读取设备信息读取&emsp;ManufacturerID与DeviceID为传感器的固有信息，可以读取该信息确认I2C通讯有效性。 &emsp;HDC1010手册提供了Configuration寄存器的读写操作，可以类推到ManufacturerID与DeviceID寄存器的读取方法，如下图所示。注意ManufacturerID与DeviceID寄存器均为只读寄存器。 I2C读取寄存器的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071uint16 HDC_GetData(char REG_Address)&#123; I2CA_ReadData(HDC1010_ADDR, REG_Address, 2, HDC_buffer); return (HDC_buffer[0]&lt;&lt;8) + HDC_buffer[1];&#125;void I2CA_ReadData(uint16 addr, uint16 reg, uint16 readCount, uint8 *buffer)&#123; uint16 i; I2caRegs.I2CMDR.bit.IRS = 1; // reset I2C // Make sure I2C is not busy and has stopped while (I2caRegs.I2CSTR.bit.BB == 1); // busy loop I2caRegs.I2CSTR.bit.SCD = 1; // Clear the SCD bit (stop condition bit) //while(I2caRegs.I2CMDR.bit.STP == 1); // stop bit loop I2caRegs.I2CSAR = addr; // I2C slave address while (I2caRegs.I2CSTR.bit.BB == 1); // still busy? I2caRegs.I2CMDR.all = 0x2620; // start, no stop bit, master, tx, reset I2C 00100110// I2caRegs.I2CMDR.bit.NACKMOD = 0; // 15:NACK mode bit// I2caRegs.I2CMDR.bit.FREE = 0; // 14:Stop I2C when suspended// I2caRegs.I2CMDR.bit.STT = 1; // 13:START condition bit// I2caRegs.I2CMDR.bit.STP = 0; // 11:STOP condition bit// I2caRegs.I2CMDR.bit.MST = 1; // 10:Master mode// I2caRegs.I2CMDR.bit.TRX = 1; // 9:Transmitter mode// I2caRegs.I2CMDR.bit.XA = 0; // 8:7-bit addressing mode// I2caRegs.I2CMDR.bit.RM = 0; // 7:Nonrepeat mode// I2caRegs.I2CMDR.bit.DLB = 0; // 6:Digital loopback mode is disabled// I2caRegs.I2CMDR.bit.IRS = 1; // 5:The I2C module is enabled// I2caRegs.I2CMDR.bit.STB = 0; // 4:The I2C module is not in the START byte mode// I2caRegs.I2CMDR.bit.FDF = 0; // 3:Free data format mode is disabled// I2caRegs.I2CMDR.bit.BC = 0; // 2-0:8 bits per data byte I2caRegs.I2CCNT = 1; // assume register address is one byte I2caRegs.I2CDXR = reg; // register address of the sensor (1 byte) while(!I2caRegs.I2CSTR.bit.ARDY); // all ready? I2caRegs.I2CMDR.all = 0x2C20; // start, stop bit when CNT =0, master, rx, reset I2C 00101100// I2caRegs.I2CMDR.bit.NACKMOD = 0; // 15:NACK mode bit// I2caRegs.I2CMDR.bit.FREE = 0; // 14:Stop I2C when suspended// I2caRegs.I2CMDR.bit.STT = 1; // 13:START condition bit// I2caRegs.I2CMDR.bit.STP = 1; // 11:STOP condition bit// I2caRegs.I2CMDR.bit.MST = 1; // 10:Master mode// I2caRegs.I2CMDR.bit.TRX = 0; // 9:Transmitter mode// I2caRegs.I2CMDR.bit.XA = 0; // 8:7-bit addressing mode// I2caRegs.I2CMDR.bit.RM = 0; // 7:Nonrepeat mode// I2caRegs.I2CMDR.bit.DLB = 0; // 6:Digital loopback mode is disabled// I2caRegs.I2CMDR.bit.IRS = 1; // 5:The I2C module is enabled// I2caRegs.I2CMDR.bit.STB = 0; // 4:The I2C module is not in the START byte mode// I2caRegs.I2CMDR.bit.FDF = 0; // 3:Free data format mode is disabled// I2caRegs.I2CMDR.bit.BC = 0; // 2-0:8 bits per data byte I2caRegs.I2CCNT = readCount; // only read one byte data if(I2caRegs.I2CSTR.bit.NACK == 1) &#123; I2caRegs.I2CSTR.all = I2C_CLR_NACK_BIT; // 0x0002 &#125; I2caRegs.I2CMDR.bit.STP = 1; // stop bit when CNT=0 while(!I2caRegs.I2CSTR.bit.SCD); // stop bit detected? for (i = 0; i &lt; readCount; i++) &#123; buffer[i] = I2caRegs.I2CDRR; // read one byte data &#125;&#125; &emsp;以读取ManufacturerID与DeviceID为例，使用逻辑分析仪得到的时序图如下所示。 &emsp;可见ManufacturerID与DeviceID寄存器读取到的值分别为0x5449、0x1000，与数据手册描述一致，读取正确。 Configuration寄存器&emsp;对Configuration寄存器进行配置并读取确保写入已生效。Configuration寄存器的说明如下图所示。 &emsp;这里可以将Configuration设置为0x00，即关闭heater、温湿度独立读取、温湿度均为14位分辨率。 &emsp;逻辑分析仪得到的时序图如下图所示。 温湿度寄存器&emsp;HDC1010中温湿度数据获取流程如下：触发采样-等待采样结束-读取采样信息。当采样未结束时读取数据将获得到一个NACK。数据手册中时序图如下图所示。 &emsp;代码实现如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576uint16 HDC_GetTemperature(void)&#123; int32 temp; HDC_GetSensor(HDC1010_ADDR, TemperatureA, 2, temperature_buffer); //HDC_GetSensor(HDC1010_ADDR, TemperatureA, 2, humidity_buffer); temp = (temperature_buffer[0]&lt;&lt;8) + temperature_buffer[1]; return (temp * 1650&gt;&gt;16) - 400;&#125;uint16 HDC_GetHumidity(void)&#123; int32 humi; HDC_GetSensor(HDC1010_ADDR, HumidityA, 2, humidity_buffer); humi = (humidity_buffer[0]&lt;&lt;8) + humidity_buffer[1]; return humi * 1000 &gt;&gt; 16;&#125;void HDC_GetSensor(uint16 addr, uint16 reg, uint16 readCount, uint8 *buffer)&#123; uint16 i; I2caRegs.I2CMDR.bit.IRS = 1; // reset I2C // Make sure I2C is not busy and has stopped while (I2caRegs.I2CSTR.bit.BB == 1); // busy loop I2caRegs.I2CSTR.bit.SCD = 1; // Clear the SCD bit (stop condition bit) //while(I2caRegs.I2CMDR.bit.STP == 1); // stop bit loop I2caRegs.I2CSAR = addr; // I2C slave address while (I2caRegs.I2CSTR.bit.BB == 1); // still busy? I2caRegs.I2CMDR.all = 0x2620; // start, no stop bit, master, tx, reset I2C 00100110// I2caRegs.I2CMDR.bit.NACKMOD = 0; // 15:NACK mode bit// I2caRegs.I2CMDR.bit.FREE = 0; // 14:Stop I2C when suspended// I2caRegs.I2CMDR.bit.STT = 1; // 13:START condition bit// I2caRegs.I2CMDR.bit.STP = 0; // 11:STOP condition bit// I2caRegs.I2CMDR.bit.MST = 1; // 10:Master mode// I2caRegs.I2CMDR.bit.TRX = 1; // 9:Transmitter mode// I2caRegs.I2CMDR.bit.XA = 0; // 8:7-bit addressing mode// I2caRegs.I2CMDR.bit.RM = 0; // 7:Nonrepeat mode// I2caRegs.I2CMDR.bit.DLB = 0; // 6:Digital loopback mode is disabled// I2caRegs.I2CMDR.bit.IRS = 1; // 5:The I2C module is enabled// I2caRegs.I2CMDR.bit.STB = 0; // 4:The I2C module is not in the START byte mode// I2caRegs.I2CMDR.bit.FDF = 0; // 3:Free data format mode is disabled// I2caRegs.I2CMDR.bit.BC = 0; // 2-0:8 bits per data byte I2caRegs.I2CCNT = 1; // assume register address is one byte I2caRegs.I2CDXR = reg; // register address of the sensor (1 byte) while(!I2caRegs.I2CSTR.bit.ARDY); // all ready? //while (HDC_DRDY_Read() != HDC_Ready); // first read and should return a NACK I2caRegs.I2CMDR.all = 0x2C20; // start, stop bit when CNT =0, master, rx, reset I2C 00101100 I2caRegs.I2CCNT = readCount; // only read one byte data while (HDC_DRDY_Read() != HDC_Ready); I2caRegs.I2CMDR.all = 0x2C20; // start, stop bit when CNT =0, master, rx, reset I2C 00101100 I2caRegs.I2CCNT = readCount; // only read one byte data if(I2caRegs.I2CSTR.bit.NACK == 1) &#123; I2caRegs.I2CSTR.all = I2C_CLR_NACK_BIT; // 0x0002 &#125; I2caRegs.I2CMDR.bit.STP = 1; // stop bit when CNT=0 while(!I2caRegs.I2CSTR.bit.SCD); // stop bit detected? for (i = 0; i &lt; readCount; i++) &#123; buffer[i] = I2caRegs.I2CDRR; // read one byte data &#125;&#125; &emsp;使用逻辑分析仪获取的时序图分为2部分展示：1是触发采样，尝试读取结果得到一个NACK，同时DRDYn变为高电平，表示采样进行中；2是DRDYn出现下降沿代表采样完成，控制器读取采样结果。 总结&emsp;至此，初步说明了HDC1010传感器的基本使用原则。由于篇幅限制，其中例如寄存器原始数据转化为温湿度值等过程这里不再叙述。😄","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://jiaodi.tech/categories/嵌入式/"}],"tags":[{"name":"C2000","slug":"C2000","permalink":"http://jiaodi.tech/tags/C2000/"},{"name":"HDC1010","slug":"HDC1010","permalink":"http://jiaodi.tech/tags/HDC1010/"},{"name":"I2C","slug":"I2C","permalink":"http://jiaodi.tech/tags/I2C/"},{"name":"Sensor","slug":"Sensor","permalink":"http://jiaodi.tech/tags/Sensor/"}]},{"title":"IEEE Std 802.11a/g/n/ac","slug":"IEEEStd802-11","date":"2018-01-14T02:46:04.000Z","updated":"2018-01-14T14:21:08.023Z","comments":true,"path":"2018/01/14/IEEEStd802-11/","link":"","permalink":"http://jiaodi.tech/2018/01/14/IEEEStd802-11/","excerpt":"&emsp;本文记录IEEE 802.11中关于WLAN无线速率与接收灵敏度的相关标准。","text":"&emsp;本文记录IEEE 802.11中关于WLAN无线速率与接收灵敏度的相关标准。 Glossary ABBR ADSL Asymmetrical Digital Subscriber Loop BPSK Binary Phase Shift Keying CCA Clear Channel Assessment DMT Discrete Multi Tone DSSS Direct Sequence Spread Spectrum FEC Forward Error Correction FFT Fast Fourier Transform FHSS Frequency Hopping Spread Spectrum GI Guard Interval IFFT Inverse Fast Fourier Transform LAN Local Area Network MAC Medium Access Control Layer MIB Management Information Base MLME MAC Layer Management Entity MPDU MAC Protocol Data Units $N_{BPSC}$ Number of coded bits per subcarrier $N_{CBPS}$ Number of coded bits per OFDM symbol $N_{DBPS}$ Number of data bits per OFDM symbol OFDM Orthogonal Frequency Division Multiplexing PHY Physical Layer PLCP Physical Layer Convergence Procedure PLME Physical Layer Management Entity PMD Physical Medium Dependent PPDU PLCP Protocol Data Unit PSDU PHY Sublayer Service Data Units QAM Quadrature Amplitude Modulation QPSK Quadrature Phase Shift Keying SAP Service Access Point WLAN Wireless Local Area Network 802.11a/gRate-dependent parameters Markdown格式表格多列情况下在手机上预览效果不佳，故之后表格采用截图方式。 Timing-related parameters Transmitter constellation error&emsp;The relative constellation RMS error, averaged over subcarriers, OFDM frames, and packets, shall notexceed a data-rate dependent value according to the table below. Receiver minimum input level sensitivity&emsp;The packet error rate (PER) shall be less than 10% at a PSDU length of 1000 bytes for rate-dependent input levels shall be the numbers listed in the table below or less. The minimum input levels are measured at the antenna connector (NF of 10 dB and 5 dB implementation margins are assumed). 802.11nSymbols used in MCS parameter tables Rate-dependent parameters20 MHz, NSS = 1, NES = 1 20 MHz, NSS = 2, NES = 1, EQM 20 MHz, NSS = 3, NES = 1, EQM 20 MHz, NSS = 4, NES = 1, EQM 40 MHz, NSS = 1, NES = 1 40 MHz, NSS = 2, NES = 1, EQM 40 MHz, NSS = 3, NES = 1, EQM 40 MHz, NSS = 4, NES = 1, EQM Transmitter constellation error Receiver minimum input level sensitivity 802.11acRate-dependent parameters20 MHz, NSS = 1 40 MHz, NSS = 1 80 MHz, NSS = 1 160 MHz, NSS = 1 Transmitter constellation error Receiver minimum input level sensitivity","categories":[{"name":"802.11","slug":"802-11","permalink":"http://jiaodi.tech/categories/802-11/"}],"tags":[{"name":"802.11","slug":"802-11","permalink":"http://jiaodi.tech/tags/802-11/"},{"name":"MAC","slug":"MAC","permalink":"http://jiaodi.tech/tags/MAC/"},{"name":"PHY","slug":"PHY","permalink":"http://jiaodi.tech/tags/PHY/"}]},{"title":"加载C2000 XDS100仿真器的虚拟串口(VCP)","slug":"XDS100-VCP","date":"2018-01-08T14:16:59.000Z","updated":"2018-03-15T13:45:47.960Z","comments":true,"path":"2018/01/08/XDS100-VCP/","link":"","permalink":"http://jiaodi.tech/2018/01/08/XDS100-VCP/","excerpt":"&emsp;XDS100为C2000中常用的仿真器，其具有虚拟串口(VCP, virtual com port)功能。在某些情况下，仿真器的虚拟串口无法自动打开，本文将提供一种解决方法。","text":"&emsp;XDS100为C2000中常用的仿真器，其具有虚拟串口(VCP, virtual com port)功能。在某些情况下，仿真器的虚拟串口无法自动打开，本文将提供一种解决方法。 &emsp;本文中使用的板卡为TI的LAUNCHXL-F28069M。 Windows 10 打开设备管理器，打开XDS100 Class Auxiliary Port； 在设置中选择Advanced，勾选Load VCP，选择OK； 拔掉仿真器，重新插上稍等，可以看到虚拟串口出现。 Windows 8 打开设备管理器，找到TIXDS100 Channel B。右键TI XDS100 Channel B，选择属性选项； 在属性选项中，选择“高级”。勾选“加载VCP”的选项，并选择确定； 拔掉仿真器，重新插上稍等，可以看到虚拟串口出现。","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://jiaodi.tech/categories/嵌入式/"}],"tags":[{"name":"C2000","slug":"C2000","permalink":"http://jiaodi.tech/tags/C2000/"},{"name":"XDS100","slug":"XDS100","permalink":"http://jiaodi.tech/tags/XDS100/"},{"name":"串口","slug":"串口","permalink":"http://jiaodi.tech/tags/串口/"}]},{"title":"Markdown基本语法","slug":"MarkdownSyntax","date":"2018-01-06T14:25:37.000Z","updated":"2018-03-15T13:46:01.619Z","comments":true,"path":"2018/01/06/MarkdownSyntax/","link":"","permalink":"http://jiaodi.tech/2018/01/06/MarkdownSyntax/","excerpt":"&emsp;本文记录常用的Markdown语法。","text":"&emsp;本文记录常用的Markdown语法。 &emsp;本文根据以下文章整理综合： Markdown常用格式 markdown简明语法 Markdown语法说明（详解版） Markdown中写数学公式 &emsp;文章撰写所使用的Markdown编辑器为Typora，所有语法均基于该编辑器进行测试。 段落&emsp;段落由至少一行的连续文本构成。在Typora中，使用回车进行段落切换即可。 标题&emsp;文本前使用#指示标题，按照#个数分为1至6级标题，如下图所示： 引用&emsp;&gt;用于引用文本。 1&gt;饮水思源，爱国荣校。 即为： 饮水思源，爱国荣校。 列表&emsp;输入* 列表1创建一个无序列表，*可以用+或者-代替。注意*后必须加一个空格。 &emsp;输入1. 列表1创建一个有序列表。注意1.后必须加一个空格。 12345* 无序列表1* 无序列表21. 有序列表12. 有序列表 即为： 无序列表1 无序列表2 有序列表1 有序列表 任务列表&emsp;任务列表用法如下，使用- [ ] 标识。注意-后、[ ]中与]后必须加一个空格。 12- [ ] incomplete- [x] completed [ ] incomplete [x] completed 代码段输入```code```即可。在Typora中输入```后回车即可，同时在第一行```后可以指定代码语言。 即为： 12name = raw_input(\"please enter your name:\")print (\"input:\", name) 数学公式&emsp;Markdown中可以使用LaTeX数学表达式。在Typora中输入$$后回车即可。例如麦克斯韦方程组的微分与积分形式。 1234567891011Differential：$$\\nabla\\cdot\\vec&#123;B&#125;=0$$$$\\nabla\\cdot\\vec&#123;D&#125;=\\rho$$$$\\nabla\\times\\vec&#123;H&#125;=\\vec&#123;J&#125; + \\frac&#123;\\partial \\vec&#123;D&#125;&#125;&#123;\\partial t&#125;$$$$\\nabla\\times\\vec&#123;E&#125;=- \\frac&#123;\\partial \\vec&#123;B&#125;&#125;&#123;\\partial t&#125;$$Integral：$$\\oint\\_&#123;S&#125; \\vec&#123;B&#125;\\cdot\\mathrm&#123;d&#125;\\vec&#123;S&#125;=0$$$$\\oint\\_&#123;S&#125; \\vec&#123;B&#125;\\cdot\\mathrm&#123;d&#125;\\vec&#123;S&#125;=\\int\\_&#123;V&#125;\\rho \\mathrm&#123;d&#125;V$$$$\\oint\\_&#123;l&#125; \\vec&#123;H&#125;\\cdot \\mathrm&#123;d&#125;\\vec&#123;l&#125;=\\int\\_&#123;S&#125;(\\vec&#123;J&#125;+\\frac&#123;\\partial \\vec&#123;D&#125;&#125;&#123;\\partial t&#125;)\\cdot\\mathrm&#123;d&#125;\\vec&#123;S&#125;$$$$\\oint\\_&#123;l&#125; \\vec&#123;E&#125;\\cdot \\mathrm&#123;d&#125;\\vec&#123;l&#125;=-\\int\\_&#123;S&#125;\\frac&#123;\\partial \\vec&#123;B&#125;&#125;&#123;\\partial t&#125;\\cdot\\mathrm&#123;d&#125;\\vec&#123;S&#125;$$ 即为： &emsp;Differential： $$\\nabla\\cdot\\vec{B}=0$$$$\\nabla\\cdot\\vec{D}=\\rho$$$$\\nabla\\times\\vec{H}=\\vec{J} + \\frac{\\partial \\vec{D}}{\\partial t}$$$$\\nabla\\times\\vec{E}=- \\frac{\\partial \\vec{B}}{\\partial t}$$ &emsp;Integral： $$\\oint_{S} \\vec{B}\\cdot\\mathrm{d}\\vec{S}=0$$$$\\oint_{S} \\vec{B}\\cdot\\mathrm{d}\\vec{S}=\\int_{V}\\rho \\mathrm{d}V$$$$\\oint_{l} \\vec{H}\\cdot \\mathrm{d}\\vec{l}=\\int_{S}(\\vec{J}+\\frac{\\partial \\vec{D}}{\\partial t})\\cdot\\mathrm{d}\\vec{S}$$$$\\oint_{l} \\vec{E}\\cdot \\mathrm{d}\\vec{l}=-\\int_{S}\\frac{\\partial \\vec{B}}{\\partial t}\\cdot\\mathrm{d}\\vec{S}$$ 表格&emsp;表格的用法如下所示，其中第二行的:用于确定对齐方式。 12345| Left-Aligned | Center Aligned | Right Aligned || :------------ | :-------------: | ------------: || col 3 is | some wordy text | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 即为： Left-Aligned Center Aligned Right Aligned col 3 is some wordy text $1600 col 2 is centered $12 zebra stripes are neat $1 分割线 使用---或者***并回车将产生一条分割线。 12---*** 链接使用[文本](链接地址)语法即可。 1[上海交通大学](http://www.sjtu.edu.cn/) 即为： 上海交通大学 图片&emsp;使用![]()语法即可。 1![](http://omcg8fk23.bkt.clouddn.com/Jay.jpg) 文本强调斜体1*饮水思源，爱国荣校。* 饮水思源，爱国荣校。 粗体1**饮水思源，爱国荣校。** 饮水思源，爱国荣校。 代码1`饮水思源，爱国荣校。` 饮水思源，爱国荣校。 删除线1~~嗷嗷嗷~~ 嗷嗷嗷。 下划线1&lt;u&gt;饮水思源，爱国荣校。&lt;/u&gt; 饮水思源，爱国荣校。","categories":[{"name":"Markdown","slug":"Markdown","permalink":"http://jiaodi.tech/categories/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://jiaodi.tech/tags/Markdown/"}]},{"title":"Buck电路的功率部分设计","slug":"BuckPowerStage","date":"2017-11-21T13:49:52.000Z","updated":"2018-01-25T14:45:24.151Z","comments":true,"path":"2017/11/21/BuckPowerStage/","link":"","permalink":"http://jiaodi.tech/2017/11/21/BuckPowerStage/","excerpt":"&emsp;Buck电路是嵌入式系统中最常见的电源模块，本文将对Buck电路的功率部分设计进行简单总结。","text":"&emsp;Buck电路是嵌入式系统中最常见的电源模块，本文将对Buck电路的功率部分设计进行简单总结。 &emsp;本文的主要内容摘录总结自Basic Calculation of a Buck Converter’s Power Stage by RICHTEK，也可直接读取该文档。 Buck电路的基本原理 &emsp;Buck电路的基本原理是电感的伏秒平衡。伏秒平衡的含义在于一个开关周期内电感的电流变化量为零。上图为一个同步整流的Buck电路，设定输入电压为Vin，输出电压为Vout，开关周期为T，开关频率为$f_{sw}$，占空比为D，则伏秒平衡表示如下: $$(V_{in}-V_{out})\\cdot T\\cdot D= V_{out}\\cdot T\\cdot (1-D)$$ &emsp;即有：$$V_{in}\\cdot D= V_{out}$$ &emsp;主要的电流电压波形如下，这里不再详细说明： 反馈电阻&emsp;Buck电路需要利用反馈电阻进行分压，通过feedback管脚输入到内部误差放大器进行比较，进而进行输出补偿。分压电阻的电路如图所示： &emsp;其中$V_{out}$为输出电压，$R_{1}$与$R_{2}$为分压电阻，$I_{FB}$为反馈引脚的偏置电流，偏置执电流的值可以在数据手册中获取。反馈电阻的选取主要需要考虑以下几点。 输出电压精度&emsp;输出精度主要受3点影响。 IC本身误差&emsp;IC本身有精度范围，通常情况下输出精度为1%~2%，这由半导体厂商控制，无法通过设计弥补。 反馈电阻误差&emsp;电阻本身具有误差，例如1%与5%等，高精度电阻的误差可以低于0.01%。实际设计中电阻的误差直接影响分压比，使用两个1%精度的电阻则可能造成的最大误差约为2%。而高精度电阻成本会大幅提升。通常设计中取1%精度电阻即可。 反馈引脚偏置电流引起的误差&emsp;按照反馈电阻的电路图，设定反馈电压为$V_{FB}$，反馈引脚的偏置电流为$I_{FB}$，可以得到如下关系式： $$V_{out}=(\\frac{V_{FB}}{R_{2}}+I_{FB})\\cdot R_{1}+V_{FB}=V_{FB}\\cdot (\\frac{R_{1}}{R_{2}}+1+\\frac{I_{FB}\\cdot R_{1}}{V_{FB}})$$ &emsp;在上式中，可以控制$I_{FB}$引起的误差尽可能小而忽略不计，则可要求如下： $$\\frac{R_{1}}{R_{2}}+1\\gg \\frac{I_{FB}\\cdot R_{1}}{V_{FB}}$$ &emsp;等价于： $$\\frac{V_{FB}}{\\frac{R_{1}\\cdot R_{2}}{R_{1}+R_{2}}}\\gg I_{FB}$$ $$\\frac{V_{FB}}{R_{1}//R_{2}}\\gg I_{FB}$$ &emsp;由以上推导，可以看到忽略反馈引脚偏置电流误差的关键所在：按照叠加定理考虑，当电路中只考虑$V_{FB}$作用时，则$V_{FB}$在分压电阻上的电流应当远远大于反馈引脚偏置电流。通常要求达到100倍以上，可以控制偏置电流引起的误差在1%以内。 系统静态功耗&emsp;由于$V_{out}$作用在分压电阻上，分压电阻上会存在静态功耗；为了让静态功耗尽可能小，分压电阻的取值应当尽可能大。但是考虑到反馈引脚偏置电流误差中的分析，分压电阻的取值不可过大。所以这里应在满足偏置电流考量点后再尽可能取阻值较大的分压电阻。同时，需要关注分压电阻的封装是否满足功率要求。 环路稳定性&emsp;反馈电阻会影响系统的环路稳定性，这一部分将在后续环路稳定性相关分析中说明。😄 功率电感&emsp;功率电感的选型需要关注如下参数。 纹波电流限制&emsp;设定电源的输出电流为$I_{out}$，电感电流纹波系数为ICRR(inductor current ripple ratio)，有如下表达式： $$\\frac{V_{in}-V_{out}}{L}\\cdot D\\cdot T\\leqslant I_{out}\\cdot ICRR$$ 其中$\\frac{V_{in}-V_{out}}{L}\\cdot D\\cdot T$即为最大电感纹波电流。 &emsp;等价于 $$\\frac{V_{in}-V_{out}}{L}\\cdot \\frac{V_{out}}{V_{in}}\\cdot \\frac{1}{f_{sw}}\\leqslant I_{out}\\cdot ICRR$$ &emsp;可以得到电感感值的最低要求，如下所示： $$L_{min}\\geqslant \\frac{V_{in}-V_{out}}{I_{out}\\cdot ICRR}\\cdot \\frac{V_{out}}{V_{in}}\\cdot \\frac{1}{f_{sw}}$$ 饱和电流限制&emsp;计算电感电流的最大值，可以用于确定电感的饱和电流要求，电感电流的最大值计算如下： $$I_{max}= \\frac{1}{2}\\cdot \\frac{V_{in}-V_{out}}{L}\\cdot \\frac{V_{out}}{V_{in}}\\cdot \\frac{1}{f_{sw}}+I_{out}$$ 温升电流限制&emsp;对于功率电感，温升电流一般定义为电感的温升为40摄氏度时对应地电流RMS值。电感的RMS值计算如下：&emsp;Maple已经尽力了，但是这个结果并不够优雅，不能使我满意，那么化简一下： $$I_{L,rms}=\\sqrt{I{_{out}}^{2}+\\frac{1}{12}\\cdot (\\frac{V_{in}-V_{out}}{L}\\cdot \\frac{V_{out}}{V_{in}}\\cdot \\frac{1}{f_{sw}})^{2}}$$ &emsp;注意看，括号里的部分就是最大电感纹波电流。 输入滤波电容&emsp;输入滤波电容主要用于稳定输入电压，将输入纹波电压控制在一个较小的范围以内，以满足DCDC芯片的输入电压要求。如果DCDC芯片给出明确的输入纹波电压范围，可以参照该参数进行设计；否则通常将其控制在100mV峰峰值以内足以满足绝大多数要求。 RMS电流限制&emsp;稳态状态下，如果不考虑电路本身的能量损耗，则电路的输入功率等于输出功率。假设输入电流为直流，根据功率守恒可以得到如下式子： $$V_{in}\\cdot I_{in}= V_{out}\\cdot I_{out}$$ $$I_{in}= D\\cdot I_{out}$$ &emsp;输入滤波电容的电流RMS值计算过程如下： &emsp;Maple的运算结果可以进行优化，最终结果如下： $$I_{Cin,rms}=\\sqrt{I{_{out}}^{2}\\cdot D\\cdot (1-D)+\\frac{1}{12}\\cdot (\\frac{V_{in}-V_{out}}{L}\\cdot \\frac{V_{out}}{V_{in}}\\cdot \\frac{1}{f_{sw}})^{2}\\cdot D}​$$ &emsp;上式确定了输入滤波电容的电流RMS值要求。 输入纹波限制&emsp;继续考虑输入纹波电流的要求，在计算输入滤波电容RMS值的过程中，容易看出电容处于稳定的充放电过程中，取充电阶段进行计算，易知电容的电压纹波峰峰值为： $$\\Delta V_{Cin,vpp}=\\frac{I_{in}\\cdot (1-D)\\cdot T_{s}}{C_{in}}=\\frac{I_{out}\\cdot D\\cdot (1-D)}{C_{in}\\cdot f_{sw}}$$ &emsp;上式在占空比D为50%时取最大值，最大值为： $$\\Delta V_{Cin,vpp}=\\frac{I_{out}}{4\\cdot C_{in}\\cdot f_{sw}}$$ &emsp;根据上式可以获得输入滤波电容的最低容值要求，即： $$C_{in,min}\\geqslant \\frac{I_{out}}{4\\cdot \\Delta V_{Cin,vpp}\\cdot f_{sw}}$$ 输出滤波电容ESR纹波限制&emsp;输出滤波电容的等效串联电阻ESR也会因为电感纹波电流产生纹波，表达式如下： $$\\Delta V_{out,ESR}=ESR\\cdot \\Delta I_{L}$$ 输出电压纹波限制&emsp;为了保证输入电压纹波在一个较小范围以内，定义电容电压纹波系数CVRR(capacitor voltage ripple ratio)如下，其中$\\Delta V_{out}$为输出电压纹波的峰峰值： $$CVRR=\\frac{\\Delta V_{out}}{V_{out}}$$ &emsp;对于输出滤波电容，其电流波形如下图所示。当电感电流大于输出电流时，电容充电，电容电压上升；当电感电流小于输出电流时，电容放电，电容电压下降。稳态状态下，电容的充电电荷与放电电荷相等，电流平均值为0。因此，阴影部分中电容充电电荷引起的电容电压变化即为电容电压纹波的峰峰值。 则有： $$C_{out,min}\\geqslant \\frac{\\Delta Q}{\\Delta V_{out} }=\\frac{\\Delta I_{L}\\cdot\\Delta t}{\\Delta V_{out} }$$ 即为： $$C_{out,min}\\geqslant \\frac{I_{out}\\cdot ICRR}{2}\\cdot\\frac{1}{2\\cdot f_{sw}}\\cdot\\frac{1}{2}\\cdot \\frac{1}{V_{out}\\cdot CVRR}$$ 有： $$C_{out,min}\\geqslant \\frac{I_{out}\\cdot ICRR}{8\\cdot f_{sw}\\cdot V_{out}\\cdot CVRR}$$ RMS电流限制&emsp;输出滤波电容的电流RMS值计算如下： &emsp;化简后可得： $$I_{C_{out},RMS}= \\sqrt{I{_{out}}^{2}\\cdot (1-D)^{2}+\\frac{1}{12}\\cdot (\\frac{V_{in}-V_{out}}{L}\\cdot \\frac{V_{out}}{V_{in}}\\cdot \\frac{1}{f_{sw}})^{2}}$$ &emsp;至此，buck电路的功率部分计算完毕。😄","categories":[{"name":"电源","slug":"电源","permalink":"http://jiaodi.tech/categories/电源/"}],"tags":[{"name":"Buck","slug":"Buck","permalink":"http://jiaodi.tech/tags/Buck/"},{"name":"DCDC","slug":"DCDC","permalink":"http://jiaodi.tech/tags/DCDC/"}]},{"title":"使用C#构建一个串口程序","slug":"myserial","date":"2017-11-16T15:11:21.000Z","updated":"2018-03-15T13:46:58.848Z","comments":true,"path":"2017/11/16/myserial/","link":"","permalink":"http://jiaodi.tech/2017/11/16/myserial/","excerpt":"&emsp;本文简述如何使用C#构建一个简单的串口程序。","text":"&emsp;本文简述如何使用C#构建一个简单的串口程序。 新建一个C#程序&emsp;打开VS，选择新建一个C#窗体程序并设置工程存储路径，点击确定即可。 窗体设置&emsp;新建好程序后，在窗体中添加必要控件，添加过程这里不再叙述，完成后如图所示。&emsp;窗体中的控件主要如下。 Label&emsp;Port、Receive等为label，无交互功能，仅仅作为提示显示。 ComboBox&emsp;COM1处为ComboBox，具有下拉选择功能。 Button&emsp;Open、Close等为Button，具有点击功能。 TextBox&emsp;窗体中空白区域以及波特率设置等处为TextBox，为文本显示区域。 SerialPort&emsp;窗体下方区域为SerialPort，为serial相关控件。 窗体组件设置窗体加载设置&emsp;双击主窗体，可以设置主窗体加载时候执行的代码。 12345678private void Form1_Load(object sender, EventArgs e)&#123; string[] ports = SerialPort.GetPortNames(); Array.Sort(ports); comboSerial.Items.Clear(); comboSerial.Items.AddRange(ports); btnClose.Enabled = false;&#125; &emsp;这段代码的主要功能是：获取当前可用串口列表，然后将其放在下拉菜单中。 Open控件&emsp;点击Open控件时候的执行代码如下。123456789101112131415161718private void btnOpen_Click(object sender, EventArgs e)&#123; btnOpen.Enabled = false; btnClose.Enabled = true; try &#123; serialPort1.PortName = comboSerial.Text; serialPort1.BaudRate = Convert.ToInt32(BaudRate.Text); serialPort1.Open(); &#125; catch (Exception ex) &#123; MessageBox.Show(ex.Message, \"Message\", MessageBoxButtons.OK, MessageBoxIcon.Error); btnOpen.Enabled = true; btnClose.Enabled = false; &#125;&#125; &emsp;这段代码的主要功能是：加载串口号与波特率，尝试打开串口。 Close控件&emsp;点击Close控件时候的执行代码如下。123456789101112131415private void btnClose_Click(object sender, EventArgs e)&#123; btnOpen.Enabled = true; btnClose.Enabled = false; try &#123; serialPort1.Close(); &#125; catch (Exception ex) &#123; MessageBox.Show(ex.Message, \"Message\", MessageBoxButtons.OK, MessageBoxIcon.Error); btnOpen.Enabled = false; btnClose.Enabled = true; &#125;&#125; &emsp;这段代码的主要功能是：关闭串口。 Send控件&emsp;点击Send控件时候的执行代码如下。 1234567891011private void btnSend_Click(object sender, EventArgs e)&#123; try &#123; serialPort1.WriteLine(txtSend.Text + Environment.NewLine); &#125; catch (Exception ex) &#123; MessageBox.Show(ex.Message, \"Message\", MessageBoxButtons.OK, MessageBoxIcon.Error); &#125;&#125; &emsp;这段代码的主要功能是：将Send文本区的数据发送到串口。 Clear控件&emsp;点击Clear控件时候的执行代码如下。 1234567891011private void btnClear_Click(object sender, EventArgs e)&#123; try &#123; txtReceive.Clear(); &#125; catch (Exception ex) &#123; MessageBox.Show(ex.Message, \"Message\", MessageBoxButtons.OK, MessageBoxIcon.Error); &#125;&#125; &emsp;这段代码的主要功能是：将Receive文本区的数据清空。 串口控件&emsp;为串口控件增加DataReceived事件EVents，执行代码如下。1234567891011private void serialPort1_DataReceived(object sender, SerialDataReceivedEventArgs e)&#123; try &#123; txtReceive.Text += serialPort1.ReadExisting(); &#125; catch (Exception ex) &#123; MessageBox.Show(ex.Message, \"Message\", MessageBoxButtons.OK, MessageBoxIcon.Error); &#125;&#125; &emsp;这段代码的主要功能是：当串口接收到数据时，读取数据并显示在Receive文本区域。 关闭IllegalCrossThreadCalls&emsp;在Form1()中关闭IllegalCrossThreadCalls检查。12345public Form1()&#123; InitializeComponent(); CheckForIllegalCrossThreadCalls = false;&#125; Form1_FormClosing Events设置&emsp;当窗体关闭时候，应当释放串口，代码如下。12345private void Form1_FormClosing(object sender, FormClosingEventArgs e)&#123; if (serialPort1.IsOpen) serialPort1.Close();&#125; 运行程序&emsp;运行上述程序，可以看到串口可以正常进行发送接收功能。 &emsp;至此，一个简单的串口程序就完成啦~~~ 😄😄😄 学习过程主要参考了YouTube的视频：C# Tutorial - Serial Communication | FoxLearn。","categories":[{"name":"C#","slug":"C","permalink":"http://jiaodi.tech/categories/C/"}],"tags":[{"name":"串口","slug":"串口","permalink":"http://jiaodi.tech/tags/串口/"},{"name":"C#","slug":"C","permalink":"http://jiaodi.tech/tags/C/"},{"name":"serial","slug":"serial","permalink":"http://jiaodi.tech/tags/serial/"}]},{"title":"Allegro学习笔记-差分线与等长线","slug":"allegro-guide-2","date":"2017-07-09T04:30:00.000Z","updated":"2018-03-15T13:46:45.391Z","comments":true,"path":"2017/07/09/allegro-guide-2/","link":"","permalink":"http://jiaodi.tech/2017/07/09/allegro-guide-2/","excerpt":"&emsp;本文介绍Allegro中差分线与等长线的设置方法。","text":"&emsp;本文介绍Allegro中差分线与等长线的设置方法。 Xnet的设置&emsp;实际的电路设计中，差分线与等长线之间往往串接一个电阻用于匹配，或者说用于调节信号强度而减弱振铃效应。而差分线或者等长线设置中，均只能针对同一网络进行设置。由于串联电阻之后，电阻两端的网络已经不再是同一个网络，而无法按照单一网络进行差分或者等长控制。&emsp;Allegro中通过Xnet解决这一问题。Xnet即为拓展网络（Extended net）：连续的由被动元件连接的net组与被动元件共同构成Xnet，其中被动原件通常为电阻。这里给出Allegro官方的定义： An Xnet is a connection between drivers and receivers. An Xnet includes all the drivers and receivers connected to each other plus any discrete components that are connected to the Xnet. Xnets pass through devices such as resistors and capacitors as shown in the following figure. &emsp;接上一篇文章中基本的原理图与PCB规则设置所述，这里举例将DAC串接电阻的输出网络设置为Xnet。具体步骤如下。&emsp;打开Allegro，明确需要设置的Xnet，这里将R1以及两端网络设置为Xnet。 &emsp;选择菜单栏Analyze-Model Assignment，打开SI Design Audit，选择OK忽略现有的Audit Errors。 &emsp;选择R1，点击Create Model。&emsp;选择Create ESpiceDevice model，点击OK。&emsp;在Create ESpiceDevice Model设置中，Single Pins中每两个pin连接的网络与元件本身构成一个Xnet。如果器件为排阻等按照两两对应设置Xnet。确认无误后点击OK。&emsp;之后弹出Signal Model Assigment Changes提示框。&emsp;至此，R1连接的Xnet设置完毕。同理设置R2相关网络。可以打开Constraint Manager查看已经设置好的Xnet。 差分线的设置差分线的定义&emsp;维基百科中关于差分线的定义如下： 差分传输是一种信号传输的技术，区别于传统的一根信号线一根地线的做法，差分传输在这两根线上都传输信号，这两个信号的振幅相同，相位相反。在这两根线上的传输的信号就是差分信号。信号接收端比较这两个电压的差值来判断发送端发送的是逻辑0还是逻辑1。在电路板上，差分走线必须是等长、等宽、紧密靠近、且在同一层面的两根线。 差分线对的设置&emsp;打开Constraint Manager，选择Physical-Net-All Layers；选中需要设置为差分线对的2个网络，这里选择VOUTA与VOUTB网络。 &emsp;右键，选择Create-Differential Pair，此时可以编辑差分线对名字，之后点击Create即可。至此，差分线对设置完毕。 差分线的规则设置&emsp;打开Constraint Manager，选择Electrical Constraint Set-Routing-Differential Pair；选择Objects-Create-Electrical CSet，输入规则约束名字DIFF，点击OK确认。可以看到所有的规则设置项如下所示。 Coupling Parameters&emsp;在Allegro中，最基本的差分线设置为Coupling Parameters设置，示意图如下。 &emsp;其中Primary设置为典型情况下差分线的线宽与线距设置，Neck设置为布局受限情况下差分线的线宽与线距设置。具体设置参数需要按照阻抗规则、PCB加工能力等具体分析。 Uncoupled Length&emsp;Uncoupled Length用于约束差分线的不匹配长度，例如差分线引线处可能存在不耦合的情况。可以通过使能Gather Control，设置Max值设置不耦合长度的最大允许值。 Static Phase&emsp;Cadence官方论坛中对Static Phase Tolerance做出的解释如下： a one time check from Driver to Receiver comparing lengths or delay of each member. If a Driver cannot be determined, the check is performed across the longest path of the pair. &emsp;即Static Phase为静态相位检查，一次性检测整个差分线对的长度或者延时误差，是对差分线对的整体误差控制。 Dynamic Phase&emsp;Cadence官方论坛中对Dynamic Phase Tolerance做出的解释如下： Etch length of each member is compared at each bend point interval across the Driver-Receiver path of the Diff Pair. Etch length is always measured back to the Driver pins. &emsp;即Dynamic Phase为动态相位检查，将对差分线对的每一个转角处进行误差检查，控制每一个转角处相对于驱动端的长度或者延时误差。 &emsp;Cadence官方论坛中对Dynamic Phase Max Length做出的解释如下： When specified, the Diff Pair is permitted to exceed the phase tolerance constraint for a contiguous etch length of less than or equal to the value of Max Length specified. If no compensation is made within this specified distance, a DRC will be reported at the point where the Diff Pair first goes out of phase. &emsp;Dynamic Phase Max Length的具体意义为：在Dynamic Phase Max Length范围以内，差分线的误差可以超过Tolerance。但如果在Dynamic Phase Max Length规定的长度内仍然未能将误差补偿，则给出一个DRC错误。&emsp;Dynamic Phase的应用举例来说。 &emsp;设定Tolerance为x mil，Dynamic Phase Max Length为y mil。则Dynamic Phase的功能在于保证整个差分对网络的误差不会超过x mil。如果在网络的某个点差分对的误差超过了x mil，则超过的部分必须在y mil以内补偿回来。&emsp;补偿的形式可以通过蛇形线或者拐角进行实现。 等长线的设置等长线的定义&emsp;等长线的意义在于保证等长线组的长度或者延时误差在允许范围以内。例如在DDR布线过程中，需要保证数据线的等长以确保数据传输的准确性。 等长线的设置&emsp;打开Constraint Manager，选择Electrical-Net-Routing；选择需要设置等长的网路，这里举例选择SPI的SCLK、DIN、SYNC网络（事实上SPI信号通常在50MHz以内，对等长的要求并不严格）。选中网络后，与设置差分线一样，右键选择Create-Match Group，命名为SPI即可。 Allegro的设置&emsp;在进行等长线设置之前，需要打开Allegro的相关设置。按照图打开如下2处设置，使得Allegro动态显示走线的长度以及差分线的误差。 等长规则的设置&emsp;设置Pin Pairs为Longest Pin Pairs，表示以最长的一条线为标准进行比对；设置Relative Delay为-40mil；40mil，代表误差在±40mil之间。此时，等长线组的走线长度木匾设置为Longest Pin Pair - 40mil，在此基础上误差为±40即为满足要求。&emsp;按以上要求设置完毕后，选择等长线组，右键选择Analyse即可对等长线组进行分析，例如此时的分析结果如下： &emsp;此时DIN为最长线，长度为755mil，可知此时的目标线长为755-40=715mil。目标线长减去40mil则为允许的最短线长，为675mil。对于SCLK，Margin为675-621=54mil，已经不满足要求；而SYNC的Margin为686-675=11，满足要求。因此SCLK需要调整。 等长线的调整&emsp;等长线的调整可以通过Delay Tune实现，注意options选项中要设置Gap为3倍线宽，同时使用弧形线。经过绕线可以调整等长线到相近长度，此时Margin充足，满足要求。😄","categories":[{"name":"EDA","slug":"EDA","permalink":"http://jiaodi.tech/categories/EDA/"}],"tags":[{"name":"Cadence","slug":"Cadence","permalink":"http://jiaodi.tech/tags/Cadence/"},{"name":"Allegro","slug":"Allegro","permalink":"http://jiaodi.tech/tags/Allegro/"},{"name":"高速电路","slug":"高速电路","permalink":"http://jiaodi.tech/tags/高速电路/"},{"name":"差分线","slug":"差分线","permalink":"http://jiaodi.tech/tags/差分线/"},{"name":"等长线","slug":"等长线","permalink":"http://jiaodi.tech/tags/等长线/"}]},{"title":"Allegro学习笔记-基础篇","slug":"allegro-guide-1","date":"2017-06-11T15:47:54.000Z","updated":"2018-03-15T13:46:26.316Z","comments":true,"path":"2017/06/11/allegro-guide-1/","link":"","permalink":"http://jiaodi.tech/2017/06/11/allegro-guide-1/","excerpt":"&emsp;Allegro是Cadence公司旗下的功能强大的PCB设计工具，在高速电路设计中应用较多。最近学习Allegro整理了一些笔记，这里与大家分享。","text":"&emsp;Allegro是Cadence公司旗下的功能强大的PCB设计工具，在高速电路设计中应用较多。最近学习Allegro整理了一些笔记，这里与大家分享。 准备工作&emsp;首先建立一个简单的工程，本文建立的工程如图所示，即DAC8552的一个接口电路，包括DAC的模拟输入输出以及SPI数字接口。&emsp;原理图及封装设计这里不再说明。 为PCB添加outline板框以及Route Keepin区域&emsp;建立PCB后，首先要添加一个板框，即规定了PCB的外形。在菜单栏中选择Add-line，Options栏中选择Board Geometry-Outline，之后可以按照所需大小进行画线即可。如果需要精确控制外板框大小，可以在命令窗口中通过x，ix，iy指令进行精确绘制。绘制完毕后，单击鼠标右键选择Done即完成。&emsp;Outline绘制完成后，需要规定允许布线区域，在菜单栏中选择Edit-Z-Copy，Options栏中选择ROUTE KEEPIN-ALL，Offset设置为所需要的安全距离，例如20mil，Find栏中选择Lines，之后点击板框的任何一个边线即可生成Route Keepin边框。如下图所示。&emsp;同理，还可以设置元器件的允许摆放区域，即Package Keepin。设置该区域即规定了元器件的摆放范围，主要是PCB进行焊接过程中的间距要求，以及防止拼版之后隔板过程损伤器件。 通过Constraint Manager设置基本规则&emsp;硬件设计中，完成原理图设计仅仅是第一步，PCB设计是更为关键的一步。PCB layout中需要关注信号完整性、电源完整性、电磁辐射、热设计以及结构设计等等要素，因此设计基本的规则非常重要。在Cadence中，可以在原理图中完成部分规则设计，但是考虑到通常的设计流程是硬件工程师完成原理图设计，提供网表给CAD工程师完成PCB layout工作。通常来说，硬件工程师给出布局以及阻抗控制等要求，CAD工程师设计规则并具体实现。因此，本文的思路是不在原理图中设置规则，全部规则在PCB中设置。&emsp;Constraint Manager可以在Setup-Constraint中打开，或者直接点击菜单栏CM图标。Constraint Manager共Electrical、Physical、Spacing、Same net spacing、Properties与DRC，其中前4项较为常用。&emsp;通常情况下，可以按照类型对走线网络进行分类，例如按照电源、射频、高速信号等对网络分类，之后可以对同一类型网络设置一致规则，可以提高效率。因此首先介绍对网络分类的方法。 1. 对网络进行分类&emsp;打开Constraint Manager，选择Objects-Create-Class，进入Net Class设置页面。这里举例设置SPI接口的SYNC、SCLK与DIN为同一个class。&emsp;将Net Class命名为SPI，同时勾选“Create for both physical and spacing”，以便网络分类可以在不同的规则环境下均可使用。点击OK进入下一步设置。&emsp;在Physical-Net-All Layers中选择SPI Net Class，右键选择Net Class Members，添加DIN、SCLK、SYNC网络，点击OK完成设置。 2. Physical规则设置&emsp;Physical即为物理规则的设置，通常用于设置走线的宽度以及差分线的一些性质等。关于差分线的设置将会单独开一篇博客讲解，所以这里仅仅进行线宽的设置。举例来说，PCB中通常电源为了满足电流要求，线宽一般大于信号线宽度，所以可以设置一个physical约束规则用于控制电源线线宽。&emsp;打开Constraint Manager，选中Physical Constraint Set，菜单栏中选择Objects-Create-Physical CSet，进入Net Class设置页面，将规则约束命名为Power。此时，可以看到Physical页面下存在2条约束规则，DEFAULT与POWER。DEFAULT表示PCB的默认规则，没有单独设置约束规则的网络将遵循此规则，此时将线宽设置为6mil；POWER为设置的电源网络规则，设置线宽为12mil。&emsp;之后对相应网络应用规则。对网络P5V应用POWER规则，其余网络默认为DEFAULT规则。可以看到属于同一个Class的网络可以统一应用规则。 3. Spacing规则设置&emsp;Physical即为间距规则的设置，通常用于设置指定网络与其它网络、过孔及敷铜等的间距。与物理规则设置近似，可以针对指定网络设置相应规则，例如POWER网络与其它网络的间距可以适当增大。 4. Region区域设置&emsp;PCB layout中经常遇到的一个问题是：对于CPU以及其它高密度封装区域布局时，需要适当减小线宽与走线距离等，而在PCB其它区域，应当保证足够的线宽与线距以获取最佳加工可靠性。Allegro中可以设置独立的区域来解决此问题。&emsp;选择Objects-Create-Region，设置为DGK8，此时DGK8的规则约束可以独立设置，可以调整线宽与线距。&emsp;之后，在PCB layout界面中选择Shape-Polygon，OPtions中选择Constraint Region以及对应的区域DKG8，完成区域边框的设置即可。","categories":[{"name":"EDA","slug":"EDA","permalink":"http://jiaodi.tech/categories/EDA/"}],"tags":[{"name":"Cadence","slug":"Cadence","permalink":"http://jiaodi.tech/tags/Cadence/"},{"name":"Allegro","slug":"Allegro","permalink":"http://jiaodi.tech/tags/Allegro/"},{"name":"高速电路","slug":"高速电路","permalink":"http://jiaodi.tech/tags/高速电路/"},{"name":"封装","slug":"封装","permalink":"http://jiaodi.tech/tags/封装/"}]},{"title":"使用Ultra Librarian创建Cadence原理图与PCB封装","slug":"cadence-allegro-package","date":"2017-04-04T07:49:27.000Z","updated":"2018-03-15T13:46:14.054Z","comments":true,"path":"2017/04/04/cadence-allegro-package/","link":"","permalink":"http://jiaodi.tech/2017/04/04/cadence-allegro-package/","excerpt":"&emsp;元器件的封装制作是原理图与PCB设计的第一步。自行设计封装固然可行，但通常要花费一定时间。使用芯片厂家提供的封装库是一个便捷的手段，尤其对于具有通用性的PCB封装。例如德州仪器公司与 Accelerated Designs公司合作制作了自己几乎全部元器件的封装库，整合为bxl文件，可以使用Ultra Librarian创建Cadence原理图与PCB封装。 &emsp;以C2000处理器TMS320F28069芯片为例，本文将介绍使用该工具生成封装库的方法。","text":"&emsp;元器件的封装制作是原理图与PCB设计的第一步。自行设计封装固然可行，但通常要花费一定时间。使用芯片厂家提供的封装库是一个便捷的手段，尤其对于具有通用性的PCB封装。例如德州仪器公司与 Accelerated Designs公司合作制作了自己几乎全部元器件的封装库，整合为bxl文件，可以使用Ultra Librarian创建Cadence原理图与PCB封装。 &emsp;以C2000处理器TMS320F28069芯片为例，本文将介绍使用该工具生成封装库的方法。 Ultra Librarian的安装与bxl文件的下载&emsp;Ultra Librarian软件可以在ti官网直接下载。在ti官网搜索TMS320F28069，在芯片主页打开质量与封装选项，页面下方可以看到bxl文件与Ultra Librarian软件的下载链接。&emsp;Ultra Librarian软件按照默认安装即可。&emsp;TMS320F28069封装中，下载LQFP100为例。 使用Ultra Librarian生成Cadence原理图与PCB封装&emsp;Ultra Librarian可以直接打开bxl文件，其中左侧为PCB封装预览，右侧为原理图封装预览（上面还有一个3D封装，我不知道是哪里来的…）。&emsp;Ultra Librarian软件设置如下：其中勾选Cadence Allegro选项，注意选择自己的Cadence软件版本，本文以16.6版本为例。该选项对应PCB封装；同时勾选Cadence Allegro Capture选项，该选项对应原理图封装。&emsp;点击Step 3. Export to Selected Tools生成封装。PCB封装生成过程中，需要调用Allegro软件。处理过程可能比较长，请耐心等待。 PCB封装的处理以及加入3D模型&emsp;封装生成之后，可以打开Ultra Librarian输出文件夹（UltraLibrarian\\Library\\Exported\\Allegro）中对应时间生成的文件，其中.dra .psm .pad文件均为必须文件，其中pz100代表中等密度封装，pz100-l代表高密度封装，pz100-m代表低密度封装。此时可以用Allegro软件打开dra文件查看具体封装。&emsp;为了便于整理，可以将上述文件复制到自己的封装库文件夹中，本文中将其复制到C:\\Cadence\\mypcblib目录下。&emsp;为了使得PCB封装更接近于实际效果，可以下载其3D外形加入到封装中。这里推荐到3D ContentCentral下载3D封装。&emsp;搜索LQFP100，选择合适的器件。&emsp;打开器件页面，选择STEP文件下载并保存在3D封装文件夹中，本文对应为C:\\Cadence\\step。&emsp;打开Allegro软件，添加steppath路径。&emsp;打开pz100封装，选择setup-Step Packaging Mapping，选择LQFP100并进行方向位置的微调，点击Save进行保存并退出。此时，如果Allegro调用该PCB封装，则会自动加载其3D模型。 原理图封装的处理&emsp;Ultra Librarian生成的封装需要经过Cadence导入方可使用。打开Cadence Capture软件，选择file-Import Design，打开UltraLibrarian\\Library\\Exported\\Orcad路径下对应的edf cfg文件，如图所示。&emsp;生成完毕后，文件夹内会出现OLB，即为原理图库文件。为了方便起见，可以将库里的元器件复制到自建库中，同时指定PCB封装为pz100。 新建工程进行测试&emsp;新建一个工程进行原理图与PCB封装测试。&emsp;原理图中仅仅放置F28069，然后生成网络表并用Allegro软件打开。此时可以在Allegro软件中对该器件进行放置，选择3D方式进行查看，可以看到器件的3D效果。","categories":[{"name":"EDA","slug":"EDA","permalink":"http://jiaodi.tech/categories/EDA/"}],"tags":[{"name":"Cadence","slug":"Cadence","permalink":"http://jiaodi.tech/tags/Cadence/"},{"name":"Allegro","slug":"Allegro","permalink":"http://jiaodi.tech/tags/Allegro/"},{"name":"封装","slug":"封装","permalink":"http://jiaodi.tech/tags/封装/"}]},{"title":"新建一个C2000工程","slug":"新建一个C2000工程","date":"2017-03-06T05:13:46.000Z","updated":"2018-03-15T13:47:19.445Z","comments":true,"path":"2017/03/06/新建一个C2000工程/","link":"","permalink":"http://jiaodi.tech/2017/03/06/新建一个C2000工程/","excerpt":"&emsp;安装好开发环境CCS与对应软件套件controlSUITE之后，可以尝试新建一个CCS工程。新建的CCS工程目标是：尽可能使该工程模块更方便使用，清晰明了，同时便于移植。","text":"&emsp;安装好开发环境CCS与对应软件套件controlSUITE之后，可以尝试新建一个CCS工程。新建的CCS工程目标是：尽可能使该工程模块更方便使用，清晰明了，同时便于移植。 准备工作&emsp;安装完毕的CCS与controlSUITE，可以参照安装CCS与controlSUITE。 新建一个空项目 启动CCS v5，选择工作空间。 选择菜单栏File-&gt;New-&gt;CCS Project。进入New CCS Project设置选项。 &emsp;Target：目标器件，左框选择2806x Piccolo，右框选择TMS320F28069； &emsp;Connection：仿真器，选择Texs Instruments XDS100v2 USB Debug Probe； &emsp;Project name：新建项目的名称，示例输入F28069Empty。将作为后续的工程模板使用； &emsp;勾选Use default location； &emsp;Compiler version：编译器版本，采用默认值TI v6.2.10。 &emsp;Advance settings保持默认即可； &emsp;Project templates and examples：项目模板，选择Empty Project（with main.c）。 &emsp;选择finish完成空项目工程的建立。 空项目建立完成后，可以看到Project Explore中存在F28069Empty工程。CCS已经自动加入了链接器命令文件28069_RAM_lnk.cmd。同时main.c中存在一个空的main函数。 增加外设与初始化文件&emsp;在空项目建立完成后，将需要使用到的头文件与源文件导入，才能正常使用其中的初始化与外设驱动函数。 增加头文件 单击选中F28069Empty空项目。右键，选择New-&gt;Folder，进入新建文件夹界面。在Folder name栏输入include，作为头文件文件夹。 选择controlSUITE安装目录下controlSUITE\\device_support\\f2806x\\v136\\F2806x_headers\\include，选择其中所有头文件并复制。右键F28069Empty空项目下include文件夹，选择paste粘贴指令。此时，头文件将复制于include文件夹中。 选择controlSUITE安装目录下controlSUITE\\device_support\\f2806x\\v136\\F2806x_common\\include，选择其中所有头文件，复制到include文件夹中。 增加源文件 单击选中F28069Empty空项目。右键，选择New-&gt;Folder，进入新建文件夹界面。在Folder name栏输入source，作为源文件文件夹。 选择controlSUITE安装目录下controlSUITE\\device_support\\f2806x\\v136\\F2806x_common\\source，选择其中(除F2806x_CSMPasswords.asm、F2806x_SWPrioritizedDefaultIsr.c与F2806x_SWPrioritizedPieVect.c外所有)源文件并复制。右键F28069Empty空项目下source文件夹，选择paste粘贴指令。此时，源文件将复制于include文件夹中。 注意：器件启动文件F2806x_CodeStartBranch.asm与延时函数源文件F2806x_usDelay.asm也已经复制与source文件夹下。 增加位域结构体支持源文件 复制controlSUITE\\device_support\\f2806x\\v136\\F2806x_headers\\source中F2806x_GlobalVariableDefs.c文件，放到工程工程目录source文件夹下。 复制controlSUITE\\device_support\\f2806x\\v136\\F2806x_headers\\cmd中F2806x_Headers_nonBIOS.cmd文件，放到工程根目录文件夹下。即复制后，右键F28069Empty空项目选择paste指令。 设置包含选项&emsp;尽管已经增加了头文件与源文件，但是还需要设置包含路径，编译器才能搜索到需要的文件。&emsp;在新建F28069Empty空项目右键，选择属性。选择Build-&gt;C2000 Compiler-&gt;Include Options。&emsp;单击Add，选择Workspace…（即选择相对路径），选择新建F28069Empty空项目下的include文件夹。 &emsp;点击OK，回复到属性设置界面，再次点击OK确认。&emsp;点击build，该项目可以编译通过。 使用新工程进行LED闪烁实验&emsp;新建项目中main为空函数。为了检验创建的工程是否可以正常使用，这里进行简单的测试。&emsp;在这里，将main.c文件内容替换为如下内容。 1234567891011121314151617181920212223242526272829#include \"DSP28x_Project.h\" void main(void)&#123; InitSysCtrl(); DINT; InitPieCtrl(); IER = 0x0000; IFR = 0x0000; InitPieVectTable(); EALLOW; GpioCtrlRegs.GPAMUX1.all = 0x00000000; // All GPIO GpioCtrlRegs.GPAMUX2.all = 0x00000000; // All GPIO GpioCtrlRegs.GPBMUX1.all = 0x00000000; // All GPIO GpioCtrlRegs.GPADIR.all = 0xCFFFFFFF; // All outputs GpioCtrlRegs.GPBDIR.all = 0x0000000F; // All outputs EDIS; for(;;) &#123; GpioDataRegs.GPADAT.all =0xffffffff; //赋值修改为0xffffffff GpioDataRegs.GPBDAT.all =0xffffffff; //赋值修改为0xffffffff DELAY_US(1000000); GpioDataRegs.GPADAT.all =0x0; //赋值修改为0x0 GpioDataRegs.GPBDAT.all =0x0; //赋值修改为0x0 DELAY_US(1000000); &#125;&#125; &emsp;单击build编译工程，工程可以编译通过。&emsp;将F28069核心板连接到电脑，将工程debug下载到核心板。运行工程，可以看到LED开始闪烁。&emsp;可以证明，建立工程的方法是可行的。 对工程进行一点优化修改&emsp;按照上述步骤，建立了一个可用的工程模板。以下，为了后续学习的便捷性，需要对工程进行少许修改。 定义数据类型头文件&emsp;不同的器件平台和不同的编译器，可能具有不同的数据类型，或者同名的数据类型具有不同的长度。为了程序更易于移植使用，应该在程序设计中尽可能消除这种差异。&emsp;因此，可以尝试建立数据类型定义。&emsp;右键F28069Empty工程，选择New-&gt;Header File，为工程添加一个头文件。文件名定义为mytype.h。&emsp;在mytype.h中，输入如下数据类型定义。 1234567891011121314151617181920212223242526272829//Optimizing C C++ User's Guide.pdf//chapter 6.4 Data Types#ifndef MYTYPE_H_#define MYTYPE_H_ typedef char int8; //in fact,16 bits.//typedef unsigned char Uint8;//in fact,16 bits.typedef unsigned char uint8;//in fact,16 bits.//typedef int int16;//typedef unsigned int Uint16;typedef unsigned int uint16;//typedef long int32;//typedef unsigned long Uint32;typedef unsigned long uint32;//typedef long long int64;//typedef unsigned long long Uint64;typedef unsigned long long uint64;typedef volatile int8 vint8;typedef volatile uint8 vuint8;typedef volatile int16 vint16;typedef volatile uint16 vuint16;typedef volatile int32 vint32;typedef volatile uint32 vuint32;typedef volatile long long vint64;typedef volatile unsigned long long vuint64;//typedef float float32;//typedef long double float64; #endif /* MYTYPE_H_ */ &emsp;查阅Optimizing C C++ User&#39;s Guide.pdf手册6.4节data type可以看到相关的数据类型定义。基于此确定数据类型的定义。&emsp;其中部分定义被注释掉了，原因在于引入的头文件中，已经按照一致的方法定义了，这里不能再次重复定义。 定义公用包含头文件&emsp;在后续实验中，为了增加代码的可读性，程序将进行模块化设计。简单地说，对于不同外设，设置单独的文件夹存储头文件与源文件。&emsp;对于每一个外设均需要引入芯片支持文件，例如，位域结构体支持文件每一个外设均需要使用。为此，可以设置一个公共包含文件common.h，该文件在每个外设文件夹中被引入。&emsp;在项目根目录下添加名为common.h的头文件，并添加如下内容。 12345678#ifndef COMMON_H_#define COMMON_H_ #include \"include\\DSP28x_Project.h\" #include \"mytype.h\" #endif /* COMMON_H_ */ 定义总包含文件&emsp;按照文件夹区分外设后，需要定义总的包含文件，便于程序正常调用不同外设的不同函数。例如，一般来讲，main主程序需要访问全部外设的函数。&emsp;如果每个外设导入一个头文件，在外设较多的时候，导入部分将占有较大篇幅，使程序看起来不简洁。或者，如果系统控制的中断服务函数同样需要访问所有外设，还需要同样大篇幅导入。&emsp;因此，可以设置一个includes.h头文件，用来单独管理外设头文件。&emsp;新建includes.h，并添加如下代码。在后续学习中，外设的头文件将在#include &quot;common.h&quot;后继续添加。123456#ifndef INCLUDES_H_#define INCLUDES_H_ #include \"common.h\" #endif /* INCLUDES_H_ */ 修改main函数包含文件&emsp;上一步定义了总包含文件，这里，将main主函数中原有的#include &quot;DSP28x_Project.h&quot;修改为#include &quot;includes.h&quot;。&emsp;重新编译并调试工程，该工程仍然可以正常运行。 删除测试代码&emsp;上述完成的F28069Empty工程中，加入了LED闪烁的测试代码。本节目的是新建一个空工程，因此，这里可以将测试代码删除。建议main函数调整为如下所示。123456789101112131415161718#include \"includes.h\"uint32 loop_count = 0; void main(void)&#123; InitSysCtrl(); DINT; InitPieCtrl(); IER = 0x0000; IFR = 0x0000; InitPieVectTable(); EINT; // Enable Global interrupt INTM ERTM; // Enable Global realtime interrupt DBGM for(;;) &#123; loop_count++; &#125;&#125; &emsp;其中加入的EINT与ERTM为中断控制指令，后续章节会有介绍。&emsp;新建了变量loop_count计数主循环运行次数，在调试程序时有一些用途。&emsp;以后的学习中，将使用该工程作为模板。&emsp;CCS支持工程的直接复制。在使用的过程中，单击选中工程。按住ctrl+C可以复制工程，再按住ctrl+V，则可以完成工程的复制。&emsp;重命名后，则可以开始开发新的项目。 程序在flash中执行&emsp;目前为止，所创建的工程均是在RAM中运行。现在，仅仅需要对原有工程进行一些修改，即可完成在flash运行的工程。这样，器件再重新上电后可以继续执行原有程序。&emsp;注意：尽管介绍了程序在flash运行的方式，但是在学习过程中，强烈建议尽量使用ram运行方式进行实验。在ram运行程序使得器件相对安全。如果使用flash进行程序烧录，初学者由于操作不正确或者不熟练等，可能造成flash锁死等情况发生。&emsp;修改步骤如下。 更改链接器命令文件，将28069_RAM_lnk.cmd文件进行删除，同时替换为controlSUITE\\device_support\\f2806x\\v136\\F2806x_common\\cmd下的F28069.cmd； 在main函数#include &quot;includes.h&quot;之后，增加如下4条语句； 12345// These are defined by the linker (see F2808.cmd)extern Uint16 RamfuncsLoadStart;extern Uint16 RamfuncsLoadEnd;extern Uint16 RamfuncsRunStart;extern Uint16 RamfuncsLoadSize; 在main函数InitPieVectTable()后，增加如下2条语句。 12memcpy(&amp;RamfuncsRunStart, &amp;RamfuncsLoadStart, (Uint32)&amp;RamfuncsLoadSize);InitFlash(); 此时，程序再进行烧录，可以看到扇区擦除的过程。","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://jiaodi.tech/categories/嵌入式/"}],"tags":[{"name":"C2000","slug":"C2000","permalink":"http://jiaodi.tech/tags/C2000/"},{"name":"DSP","slug":"DSP","permalink":"http://jiaodi.tech/tags/DSP/"},{"name":"CCS","slug":"CCS","permalink":"http://jiaodi.tech/tags/CCS/"}]},{"title":"安装CCS与controlSUITE","slug":"安装CCS与controlSUITE","date":"2017-03-06T02:11:59.000Z","updated":"2017-03-06T12:47:53.423Z","comments":true,"path":"2017/03/06/安装CCS与controlSUITE/","link":"","permalink":"http://jiaodi.tech/2017/03/06/安装CCS与controlSUITE/","excerpt":"&emsp;在学习TI C2000系列DSP之前，需要首先安装好开发环境CCS与对应软件套件controlSUITE。","text":"&emsp;在学习TI C2000系列DSP之前，需要首先安装好开发环境CCS与对应软件套件controlSUITE。 CCS的安装&emsp;Code Composer Studio™ (CCStudio) 是用于德州仪器 (TI) 嵌入式处理器系列的集成开发环境 (IDE)。 CCStudio 包含一整套用于开发和调试嵌入式应用的工具。 它包含适用于每个 TI 器件系列的编译器、源码编辑器、项目构建环境、调试器、描述器、仿真器、实时操作系统以及多种其他功能。 直观的 IDE 提供了单个用户界面，可帮助用户完成应用开发流程的每个步骤。借助于精密的高效工具，用户能够利用熟悉的工具和界面快速上手并将功能添加至他们的应用。&emsp;Code Composer Studio 以 Eclipse 开源软件框架为基础。&emsp;Code Composer Studio 可在 Windows 和 Linux PC 上运行。 并非所有功能或器件都与 Linux 兼容，详细信息请参见 Linux 主机支持。 CCS集成开发环境的下载&emsp;CCS可以在德州仪器官网（www.ti.com.cn）下载。可参考TI 网页上的WIKI 中有关CCStudio 安装的描述。下载网址&emsp;登陆TI官网后，在搜索栏输入code composer studio或CCS并点击搜索，即可获得相关资料。&emsp;下载CCS需要使用TI账户登录。创建TI账户可以下载TI更多的软件资料和使用一些在线仿真工具等。如果使用教育邮箱或企业邮箱申请，还可以进行申请样片等。 CCS集成开发环境的安装&emsp;注意： 1.安装CCS的过程中，请务必保证计算机的杀毒软件和防火墙软件已经关闭，否则在安装过程中很可能失败或者部分组件无法安装； 2.CCS安装路径与后续的工作空间所在路径严禁出现中文字符； 3.对于win 8用户，请注意系统用户名必须是英文字符，出现中文很有可能安装失败无法使用。&emsp;经实验，CCS可在win 7和win 8平台运行，对32位和64位系统兼容。建议读者使用win 7或者win 8平台计算机。 运行下载的安装程序ccs_setup.exe，当进入安装目录界面时，可以点击Browse进行安装路径的选择，但推荐直接安装在默认的C盘中。 当运行到下图处时，选择Custom选项，进入手动选择安装通道。如果下载的为在线安装包，需要在安装过程中保证联网。 单击Next得到如下图所示的窗口，为了安装快捷，在此只选择支持C28x 32-bit Real-time MCUS的选项。单击Next，保持默认配置，继续安装。CCS目前不支持在安装完毕后增加器件支持的安装，故如有可能，建议同时安装可能用到的器件，以避免重装的麻烦。 安装过程中出现的对话框全部选择“安装”选项。安装完毕后，出现以下界面。&emsp;单击Finish，往往要求先重启Windows。至此，CCS安装完毕。&emsp;之后将运行CCS，弹出如下图所示窗口，单击Browse，将工作区间链接到所建文件夹。CCS首先要求的是定义一个工作区，即用于保存开发过程中用到的所有元素（项目和指向项目的链接，可能还有源代码）的目录。默认情况下，会在C:\\Users\\&lt;用户&gt;\\Documents 或C:\\Documents and Settings\\&lt;用户&gt;\\My Documents目录下创建工作区，但可以任意选择其位置。每次执行CCS都会要求工作区目录。如果计划对所有项目使用一个目录，只需选中“Use this as the default and do not ask again（默认使用此目录且不再询问）”选项。以后随时可以在CCS中更改工作区。&emsp;实验中，使用了如图的文件夹作为工作空间。工作文件可能较多，可以在D或E盘中单独建立文件夹并以芯片的名字建立子目录。如：D:\\ti\\tms320f28069。 单击OK，第一次运行CCS需进行软件许可的选择，如下图所示。在此，选择FREE LICENSE选项，在该选项下，使用XDS100仿真器将不限制代码容量使用。而我们学习C2000系列DSP即使用该仿真器。若您有软件许可，可以参考链接进行软件许可的认证. 单击Finish即可进入CCSv5 软件开发集成环境，如下图所示。 controlSUITE的安装&emsp;controlSUITE是德州仪器公司为C2000系列微处理器设计的一款集软件、硬件与技术资料一体的复合套件。套件中提供了C2000全套器件的示例程序，这对学习该系列器件非常有用。示例程序展示了绝大多数外设的常用使用方法和技巧，借助示例程序，我们可以更快入手C2000器件的学习，或者直接借助其底层驱动进行开发。&emsp;controlSUITE中包含了完善的设备初始化函数和绝大多数外设的底层驱动函数，我们可以借助其更好地入手学习C2000设备。因此，本节我们将介绍controlSUITE的安装与使用方法。 controlSUITE的下载&emsp;controlSUITE可以在德州仪器官网（www.ti.com.cn）下载。&emsp;登陆TI官网后，在搜索栏输入controlSUITE并点击搜索，即可获得相关资料。&emsp;下载controlSUITE同样需要使用TI账户登录。 controlSUITE的安装 将压缩包解压，运行下载的安装程序controlSUITE.exe。运行到下图步骤时，可以自定义选择安装地址。&emsp;示例中，controlSUITE安装于D盘下ti文件夹下。该地址需要记住，后续需要使用该地址将controlSUITE导入到CCS中。 安装完成后，可以打开controlSUITE套件所在安装目录下的controlSUITE.exe，即可打开使用。 controlSUITE中包含了众多的技术资料，以Piccolo F2806x为例，其中包含了技术手册、用户指南和示例程序等多种资料。 将controlSUITE添加进CCS&emsp;controlSUITE可以通过CCS的资源管理器进行管理。通过CCS管理，可以更便捷地使用controlSUITE的资源，例如导入其中的示例程序进行学习等。&emsp;事实上，TI针对不同器件均有类似组件包。例如msp430的430WARE和TIVA系列ARM的TIVAWARE，也都可以通过如下方法导入到CCS中进行管理。&emsp;本节将介绍将controlSUITE导入CCS的方法。 打开CCS，选择菜单栏中View-&gt;Resource Explore，即可打开TI资源管理器。 在资源管理器左上角packages右侧，有Add additional packages按钮。 单击按钮，出现Package Configuration界面。选择Add按钮，在浏览文件夹中选择controlSUITE所在的目录。点击确定。 之后回到Package Configuration界面，点击OK。CCS将完成controlSUITE的导入。 在完成导入后，在packages栏可以选择controlSUITE。此时可以通过CCS完成对controlSUITE资源的使用。","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://jiaodi.tech/categories/嵌入式/"}],"tags":[{"name":"C2000","slug":"C2000","permalink":"http://jiaodi.tech/tags/C2000/"},{"name":"DSP","slug":"DSP","permalink":"http://jiaodi.tech/tags/DSP/"},{"name":"CCS","slug":"CCS","permalink":"http://jiaodi.tech/tags/CCS/"}]}]}