{"meta":{"title":"ç„¦è¿ªçš„åšå®¢","subtitle":"Shape of my heart.","description":null,"author":"ç„¦è¿ª","url":"http://jiaodi.tech"},"pages":[{"title":"","date":"2017-04-20T15:28:33.923Z","updated":"2017-04-20T15:28:33.923Z","comments":true,"path":"google32fe2dbbd68bea92.html","permalink":"http://jiaodi.tech/google32fe2dbbd68bea92.html","excerpt":"","text":"google-site-verification: google32fe2dbbd68bea92.html"},{"title":"ç„¦è¿ªæµ‹è¯•æ–‡ç« ","date":"2017-03-05T08:58:49.000Z","updated":"2017-03-05T08:59:58.169Z","comments":true,"path":"reserved/ç„¦è¿ªæµ‹è¯•æ–‡ç« .html","permalink":"http://jiaodi.tech/reserved/ç„¦è¿ªæµ‹è¯•æ–‡ç« .html","excerpt":"","text":"è¿™æ˜¯ä¸€ç¯‡æµ‹è¯•æ–‡ç« ï¼Œæ¬¢è¿å…³æ³¨ä½œè€…åšå®¢[1]: https://nemoj.github.io/"},{"title":"about","date":"2017-03-06T04:03:36.000Z","updated":"2017-03-06T04:03:36.384Z","comments":true,"path":"about/index-1.html","permalink":"http://jiaodi.tech/about/index-1.html","excerpt":"","text":""},{"title":"æ ‡ç­¾","date":"2017-03-06T03:48:21.000Z","updated":"2017-03-06T04:14:19.082Z","comments":false,"path":"tags/index.html","permalink":"http://jiaodi.tech/tags/index.html","excerpt":"","text":""},{"title":"å…³äºæˆ‘","date":"2017-03-06T03:54:42.000Z","updated":"2017-09-24T15:26:48.319Z","comments":false,"path":"about/index.html","permalink":"http://jiaodi.tech/about/index.html","excerpt":"","text":"é›¨ä¸‹æ•´å¤œ æ­¤åˆ»åˆæ™´"},{"title":"Hello World","date":"2017-04-13T15:17:00.152Z","updated":"2017-03-05T08:35:02.085Z","comments":true,"path":"reserved/hello-world.html","permalink":"http://jiaodi.tech/reserved/hello-world.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}],"posts":[{"title":"åˆ©ç”¨SMT32F767é©±åŠ¨AD7616","slug":"stm32f767-fmc-ad7616","date":"2018-08-11T12:45:50.000Z","updated":"2018-09-12T13:21:08.617Z","comments":true,"path":"2018/08/11/stm32f767-fmc-ad7616/","link":"","permalink":"http://jiaodi.tech/2018/08/11/stm32f767-fmc-ad7616/","excerpt":"&emsp;æœ¬æ–‡ä»‹ç»STM32F767 FMCæ§åˆ¶AD7616çš„åŸºæœ¬æ–¹æ³•ã€‚","text":"&emsp;æœ¬æ–‡ä»‹ç»STM32F767 FMCæ§åˆ¶AD7616çš„åŸºæœ¬æ–¹æ³•ã€‚ å¼€å‘ç¯å¢ƒç¡¬ä»¶ç¯å¢ƒ ç”µè„‘ï¼šWindows 10 Home x64 Apollo STM32F767å¼€å‘æ¿(ST-LINK V2ä»¿çœŸå™¨) è½¯ä»¶ç¯å¢ƒ Keil Version 5.24.1 (Pack Installerï¼šKeil.STM32F7xx_DFP.2.9.0.pack) STM32CubeMX Version 4.25.0(Packages Managerï¼šSTM32CubeF7) AD7616åŠŸèƒ½ç®€ä»‹ä¸»è¦ç‰¹æ€§ 16é€šé“åŒæ ¸åŒæ­¥é‡‡æ ·è¾“å…¥ ç‹¬ç«‹å¯é€‰çš„é€šé“é‡‡æ ·è¾“å…¥èŒƒå›´ï¼šÂ±10Vï¼ŒÂ±5Vï¼ŒÂ±2.5Vï¼› å•ç«¯5Væ¨¡æ‹Ÿä¾›ç”µï¼Œ2.3Vè‡³3.6Væ•°å­—é©±åŠ¨ä¾›ç”µï¼› æ¨¡æ‹Ÿç‰¹æ€§ï¼šè¾“å…¥é’³ä½ä¿æŠ¤ã€è¾“å…¥é˜»æŠ—1MÎ©ï¼› 16ä½SAR ADCï¼Œååé‡ä½2*1MSPSï¼Œæ”¯æŒè¿‡é‡‡æ ·ï¼Œæ”¯æŒåºåˆ—å™¨ï¼› æ”¯æŒä¸²è¡Œå¹¶è¡Œæ¥å£ï¼ŒCRCæ ¡éªŒï¼› è®¾è®¡ç›®æ ‡ ä½¿ç”¨å¹¶è¡Œæ¥å£ä»¥è·å–AD7616æœ€ä½³æ€§èƒ½ï¼› ä½¿ç”¨åºåˆ—å™¨æ¨¡å¼é™ä½æ§åˆ¶å¤æ‚åº¦ï¼šå¯ä»¥è¿ç»­è¯»å–å¤šä¸ªé‡‡æ ·å€¼ï¼› å®ç°æ•ˆæœSPIæ¥å£ åŸºäºSPIé©±åŠ¨å®Œæˆï¼› åœ¨SPIæ—¶é’Ÿä¸º27MHzä¸‹ï¼Œå•æ¬¡è§¦å‘æ¨¡å¼ä¸‹é‡‡æ ·ç‡å¯è¾¾380kHzåŒè·¯ï¼›è€ŒAD7616å…è®¸çš„SPIæœ€é«˜æ—¶é’Ÿä¸º50MHzï¼Œå› æ­¤å…¶é€Ÿç‡å¯ä»¥è¿›ä¸€æ­¥æé«˜ï¼› æœ¬æ¬¡éœ€è¦åˆ©ç”¨å¹¶å£è°ƒè¯•ï¼Œæ•…SPIæœªåšæ·±å…¥ç ”ç©¶ï¼›åºåˆ—å™¨ç­‰åŠŸèƒ½æš‚æœªåŠ å…¥ï¼› å¹¶è¡Œæ¥å£ åŸºäºFMCæ¥å£é©±åŠ¨å®Œæˆï¼› å•æ¬¡è§¦å‘æ¨¡å¼å¯ä»¥è¾¾åˆ°æé™é‡‡æ ·é€Ÿç‡1MHzåŒè·¯ï¼› å®Œæˆåºåˆ—å™¨åŠŸèƒ½ã€‚ å®ç°æ–¹æ³•&emsp;AD7616åº”ç”¨äºä¸€ä¸ªé‡è¦é¡¹ç›®ï¼Œè¯¥æ¨¡å—å±äºæ ¸å¿ƒæ¨¡å—ï¼Œæ­¤éƒ¨åˆ†æŠ€æœ¯å†…å®¹ä¿å¯†ã€‚ğŸ˜„ğŸ˜„ğŸ˜„","categories":[{"name":"åµŒå…¥å¼","slug":"åµŒå…¥å¼","permalink":"http://jiaodi.tech/categories/åµŒå…¥å¼/"}],"tags":[{"name":"STM32F7","slug":"STM32F7","permalink":"http://jiaodi.tech/tags/STM32F7/"},{"name":"FMC","slug":"FMC","permalink":"http://jiaodi.tech/tags/FMC/"},{"name":"AD7616","slug":"AD7616","permalink":"http://jiaodi.tech/tags/AD7616/"}]},{"title":"STM32F767 MPUçš„åŸºæœ¬ç”¨æ³•","slug":"stm32f767-mpu","date":"2018-07-27T15:59:00.000Z","updated":"2018-07-28T17:15:13.753Z","comments":true,"path":"2018/07/27/stm32f767-mpu/","link":"","permalink":"http://jiaodi.tech/2018/07/27/stm32f767-mpu/","excerpt":"æœ¬æ–‡ä»‹ç»STM32F767 MPUçš„åŸºæœ¬ç”¨æ³•ã€‚","text":"æœ¬æ–‡ä»‹ç»STM32F767 MPUçš„åŸºæœ¬ç”¨æ³•ã€‚ å¼€å‘ç¯å¢ƒç¡¬ä»¶ç¯å¢ƒ ç”µè„‘ï¼šWindows 10 Home x64 Apollo STM32F767å¼€å‘æ¿(ST-LINK V2ä»¿çœŸå™¨) è½¯ä»¶ç¯å¢ƒ Keil Version 5.24.1 (Pack Installerï¼šKeil.STM32F7xx_DFP.2.9.0.pack) STM32CubeMX Version 4.25.0(Packages Managerï¼šSTM32CubeF7) MPUåŠŸèƒ½ç®€ä»‹ä¸»è¦ç‰¹æ€§&emsp;MPU(Memory Protection Unit)å³ä¸ºå†…å­˜ä¿æŠ¤å•å…ƒï¼Œå…¶ä¸»è¦ä½œç”¨æ˜¯å®æ–½å­˜å‚¨å™¨çš„ä¿æŠ¤ï¼Œå®ƒèƒ½å¤Ÿåœ¨ç³»ç»Ÿæˆ–ç¨‹åºå‡ºç°å¼‚å¸¸è€Œéæ­£å¸¸åœ°è®¿é—®ä¸åº”è¯¥è®¿é—®çš„å­˜å‚¨ç©ºé—´æ—¶ï¼Œé€šè¿‡è§¦å‘å¼‚å¸¸ä¸­æ–­è€Œè¾¾åˆ°æé«˜ç³»ç»Ÿå¯é æ€§çš„ç›®çš„ã€‚ &emsp;å…¶ä¸»è¦åŠŸèƒ½æœ‰ï¼š å°†å­˜å‚¨å™¨æ˜ å°„ä¸ºä¸åŒåŒºåŸŸï¼Œå¯ä»¥è®¾ç½®æ¯ä¸ªåŒºåŸŸçš„ä½ç½®ã€å¤§å°ã€è®¿é—®æƒé™ï¼› å¯¹äºæ¯ä¸€ä¸ªåŒºåŸŸï¼Œå…¶å±æ€§è®¾ç½®åŒ…æ‹¬ï¼šIsBufferableã€IsCacheableã€IsShareableï¼› å¯¹äºæ¯ä¸€ä¸ªåŒºåŸŸï¼Œå¯ä»¥æ§åˆ¶åŒºåŸŸæ˜¯å¦å¯æ‰§è¡Œï¼› å¯„å­˜å™¨è¯´æ˜MPUå¯¹åŒºåŸŸçš„å±æ€§ä¸å¤§å°é…ç½®é€šè¿‡å¯„å­˜å™¨MPU_RASRå®ç°ï¼Œæ”¹å¯„å­˜å™¨çš„è¯´æ˜å¦‚ä¸‹ï¼š Bits Name Function [31:29] - Reserved. [28] XN Instruction access disable bit:0ï¼šInstruction fetches enabled.1 Instruction fetches disabled. [27] - Reserved. [26:24] AP è§è¡¨1 [23:22] - Reserved. [21:19, 17, 16] TEX, C, B è§è¡¨2 [18] S è§è¡¨2 [15:8] SRD Subregion disable bits. For each bit in this field:0:Corresponding sub-region is enabled.1:Corresponding sub-region is disabled [7:6] - Reserved [5:1] SIZE $RegionSize(bytes) = 2^{SIZE+1}$ [0] ENABLE Region enable bit MPU_RASRä¸­ç”¨æ¥è®¾ç½®æ•°æ®è®¿é—®è®¸å¯çš„APå­—æ®µè¯¦ç»†è®¾ç½®é€‰é¡¹å¦‚ä¸‹ï¼š AP[2 :0] AP[2 :0] ç”¨æˆ·æ¨¡å¼ æè¿° 000 ä¸å¯è®¿é—® ä¸å¯è®¿é—® æ‰€æœ‰çš„è®¿é—®äº§ç”Ÿä¸€ä¸ªå†…å­˜ç®¡ç†å¼‚å¸¸ 001 RW ä¸å¯è®¿é—® ä»…å¯ä»ç‰¹æƒæ¨¡å¼è®¿é—® 010 RW RO åœ¨ç”¨æˆ·æ¨¡å¼ä¸‹çš„å†™è®¿é—®ä¼šäº§ç”Ÿå†…å­˜ç®¡ç†å¼‚å¸¸ 011 RW RW å®Œå…¨è®¿é—® 100 ä¸å¯é¢„çŸ¥ ä¸å¯é¢„çŸ¥ ä¿ç•™ 101 RO ä¸å¯è®¿é—® ä»…å¯åœ¨ç‰¹æƒæ¨¡å¼ä¸‹è¿›è¡Œè¯»è®¿é—® 110 RO RO ç‰¹æƒå’Œç”¨æˆ·æ¨¡å¼åªè¯» 111 RO RO ç‰¹æƒå’Œç”¨æˆ·æ¨¡å¼åªè¯» å¯¹äºTEX, C, B, Sä½çš„è®¾ç½®ï¼Œå¸¸ç”¨æ¨¡å¼ä¸‹TEXå–1ï¼Œæ­¤æ—¶é…ç½®æ–¹æ³•ä¸ºå¦‚ä¸‹ï¼š åŸºäºMPUå¯¹SDRAMæ•°æ®åŒºè¿›è¡Œä¿æŠ¤MPUçš„è®¾ç½®MPUçš„è®¾ç½®ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š 12345678910111213141516171819202122232425262728293031323334353637/** * @brief Configures the main MPU regions. * @param None * @retval None */void MPU_Config(void)&#123; MPU_Region_InitTypeDef MPU_InitStruct; /* Disable MPU */ HAL_MPU_Disable(); /* SDRAMé…ç½® */ MPU_InitStruct.Enable = MPU_REGION_ENABLE; MPU_InitStruct.Number = MPU_REGION_NUMBER0; MPU_InitStruct.BaseAddress = SDRAM_BASE_ADDRESS; MPU_InitStruct.Size = MPU_REGION_SIZE_32MB; MPU_InitStruct.SubRegionDisable = 0x00; MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0; MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS; MPU_InitStruct.IsBufferable = MPU_ACCESS_BUFFERABLE; MPU_InitStruct.IsCacheable = MPU_ACCESS_CACHEABLE; MPU_InitStruct.IsShareable = MPU_ACCESS_NOT_SHAREABLE; MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE; HAL_MPU_ConfigRegion(&amp;MPU_InitStruct); /* Enable MPU (any access not covered by any enabled region will cause a fault) */ HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);&#125; å…¶è®¾ç½®åŠŸèƒ½ä¸»è¦æœ‰ï¼š ä½¿èƒ½å¯¹SDRAMåŒºåŸŸçš„ä¿æŠ¤ï¼› è®¾ç½®åŒºåŸŸç¼–å·ä¸º0ï¼› è®¾ç½®SDRAMæ•°æ®åŒºçš„åœ°å€ä¸å¤§å°ï¼› å…³é—­å­åŒºåŸŸåŠŸèƒ½ï¼› TEXæ‹“å±•å­—æ®µè®¾ç½®ä¸º0ï¼› è®¿é—®æƒé™ä¸ºå®Œå…¨è®¿é—®ï¼› è®¾ç½®è¯¥åŒºåŸŸä¸ºBUFFERABLEã€CACHEABLEã€ä¸å¯å…±äº«ï¼› è®¾ç½®è¯¥åŒºåŸŸç¦æ­¢æ‰§è¡Œä»£ç ã€‚ MPUè®¾ç½®å¯¹SDRAMè¯»å†™é€Ÿç‡çš„å½±å“","categories":[{"name":"åµŒå…¥å¼","slug":"åµŒå…¥å¼","permalink":"http://jiaodi.tech/categories/åµŒå…¥å¼/"}],"tags":[{"name":"STM32F7","slug":"STM32F7","permalink":"http://jiaodi.tech/tags/STM32F7/"},{"name":"MPU","slug":"MPU","permalink":"http://jiaodi.tech/tags/MPU/"}]},{"title":"STM32F767 FMC-SDRAMçš„åŸºæœ¬ç”¨æ³•","slug":"stm32f767-sdram","date":"2018-07-16T14:10:41.000Z","updated":"2018-07-27T15:46:41.006Z","comments":true,"path":"2018/07/16/stm32f767-sdram/","link":"","permalink":"http://jiaodi.tech/2018/07/16/stm32f767-sdram/","excerpt":"&emsp;æœ¬æ–‡ä»‹ç»STM32F767 FMC-SDRAMçš„åŸºæœ¬ç”¨æ³•ã€‚","text":"&emsp;æœ¬æ–‡ä»‹ç»STM32F767 FMC-SDRAMçš„åŸºæœ¬ç”¨æ³•ã€‚ å¼€å‘ç¯å¢ƒç¡¬ä»¶ç¯å¢ƒ ç”µè„‘ï¼šWindows 10 Home x64 Apollo STM32F767å¼€å‘æ¿(ST-LINK V2ä»¿çœŸå™¨) è½¯ä»¶ç¯å¢ƒ Keil Version 5.24.1 (Pack Installerï¼šKeil.STM32F7xx_DFP.2.9.0.pack) STM32CubeMX Version 4.25.0(Packages Managerï¼šSTM32CubeF7) FMCåŠŸèƒ½ç®€ä»‹ä¸»è¦ç‰¹æ€§&emsp;æœ¬ä¾‹ä½¿ç”¨FMCçš„SDRAMæ§åˆ¶å™¨ï¼Œå…¶ä¸»è¦ç‰¹æ€§å¦‚ä¸‹ï¼š ä¸¤ä¸ª SDRAM å­˜å‚¨åŒºåŸŸï¼Œå¯ç‹¬ç«‹é…ç½® 8 ä½ã€16 ä½å’Œ 32 ä½æ•°æ®æ€»çº¿å®½åº¦ 13 ä½åœ°å€è¡Œï¼Œ11 ä½åœ°å€åˆ—ï¼Œ4 ä¸ªå†…éƒ¨å­˜å‚¨åŒºåŸŸï¼š4x16Mx32bit (256 MB)ã€4x16Mx16bit(128 MB)ã€4x16Mx8bit (64 MB) æ”¯æŒå­—ã€åŠå­—å’Œå­—èŠ‚è®¿é—® SDRAM æ—¶é’Ÿå¯ä»¥æ˜¯ HCLK/2 æˆ– HCLK/3 è‡ªåŠ¨è¿›è¡Œè¡Œå’Œå­˜å‚¨åŒºåŸŸè¾¹ç•Œç®¡ç† å¤šå­˜å‚¨åŒºåŸŸä¹’ä¹“è®¿é—® å¯ç¼–ç¨‹æ—¶åºå‚æ•° æ”¯æŒè‡ªåŠ¨åˆ·æ–°æ“ä½œï¼Œå¯ç¼–ç¨‹åˆ·æ–°é€Ÿç‡ è‡ªåˆ·æ–°æ¨¡å¼ æ‰ç”µæ¨¡å¼ é€šè¿‡è½¯ä»¶è¿›è¡Œ SDRAM ä¸Šç”µåˆå§‹åŒ– CAS å»¶è¿Ÿ 1,2,3 è¯» FIFO å¯ç¼“å­˜ï¼Œæ”¯æŒ 6 è¡Œ x 32 ä½æ·±åº¦ï¼ˆ6 x14 ä½åœ°å€æ ‡è®°ï¼‰ SDRAMå¤–éƒ¨å­˜å‚¨å™¨æ¥å£ä¿¡å· SDRAMåˆå§‹åŒ–æµç¨‹&emsp;è¯¥éƒ¨åˆ†ç›´æ¥ä»¥è½¯ä»¶å½¢å¼ä»‹ç»ã€‚ SDRAMçš„ä½¿ç”¨SDRAMåˆå§‹åŒ–å‡½æ•°&emsp;SDRAMçš„åˆå§‹åŒ–å‡½æ•°å¦‚ä¸‹æ‰€ç¤ºã€‚ 12345678910111213141516171819202122232425262728293031323334353637/* FMC initialization function */void MX_FMC_Init(void)&#123; FMC_SDRAM_TimingTypeDef SdramTiming; FMC_SDRAM_CommandTypeDef Command; /** Perform the SDRAM1 memory initialization sequence */ hsdram1.Instance = FMC_SDRAM_DEVICE; /* hsdram1.Init */ hsdram1.Init.SDBank = FMC_SDRAM_BANK1; hsdram1.Init.ColumnBitsNumber = FMC_SDRAM_COLUMN_BITS_NUM_9; hsdram1.Init.RowBitsNumber = FMC_SDRAM_ROW_BITS_NUM_13; hsdram1.Init.MemoryDataWidth = FMC_SDRAM_MEM_BUS_WIDTH_16; hsdram1.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4; hsdram1.Init.CASLatency = FMC_SDRAM_CAS_LATENCY_2; hsdram1.Init.WriteProtection = FMC_SDRAM_WRITE_PROTECTION_DISABLE; hsdram1.Init.SDClockPeriod = FMC_SDRAM_CLOCK_PERIOD_2; hsdram1.Init.ReadBurst = FMC_SDRAM_RBURST_ENABLE; hsdram1.Init.ReadPipeDelay = FMC_SDRAM_RPIPE_DELAY_0; /* SdramTiming */ SdramTiming.LoadToActiveDelay = 2; SdramTiming.ExitSelfRefreshDelay = 8; SdramTiming.SelfRefreshTime = 7; SdramTiming.RowCycleDelay = 7; SdramTiming.WriteRecoveryTime = 2; SdramTiming.RPDelay = 2; SdramTiming.RCDDelay = 2; if (HAL_SDRAM_Init(&amp;hsdram1, &amp;SdramTiming) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; SDRAM_Initialization_Sequence(&amp;hsdram1, &amp;Command);//å‘é€SDRAMåˆå§‹åŒ–åºåˆ—&#125; &emsp;å…¶ä¸­ï¼Œä½¿ç”¨hsdram1.Initè®¾ç½®SDRAMçš„åŸºæœ¬å‚æ•°ï¼Œä½¿ç”¨SdramTimingè®¾ç½®çš„ä¸ºSDRAMçš„æ—¶åºå‚æ•°ï¼ŒSDRAM_Initialization_Sequence()å‡½æ•°ä¸ºSDRAMçš„åˆå§‹åŒ–åºåˆ—ã€‚ä»¥ä¸‹å°†é’ˆå¯¹æ¯ä¸ªæ¨¡å—è¿›è¡Œä»‹ç»ã€‚ SDRAMçš„åŸºæœ¬å‚æ•°&emsp;æœ¬ä¾‹ä¸­ä½¿ç”¨çš„SDRAMä¸ºW9825G66KH-6ï¼Œå…¶åŸºæœ¬å‚æ•°å¦‚ä¸‹ï¼š 4M x 4Banks x 16Bits = 32MByte æœ€é«˜é€Ÿç‡166MHz@CL3 CAS Latencyï¼š2å’Œ3 8K Refresh Cycles/64ms è¡Œ(Row)åœ°å€A0-A12ï¼Œåˆ—(Column)åœ°å€A0-A8 &emsp;æ¶‰åŠSDRAMåŸºæœ¬å‚æ•°çš„åˆå§‹åŒ–å‡½æ•°å¦‚ä¸‹è¡¨æ‰€ç¤ºã€‚ å‚æ•° è¯´æ˜ å¯é€‰å€¼ æœ¬ä¾‹å–å€¼ SDBank SDRAMå­˜å‚¨å™¨åŒºåŸŸ FMC_SDRAM_BANK1/2 FMC_SDRAM_BANK1 ColumnBitsNumber åˆ—åœ°å€ä½æ•° FMC_SDRAM_COLUMN_BITS_NUM_8/9/10/11 FMC_SDRAM_COLUMN_BITS_NUM_9 RowBitsNumber è¡Œåœ°å€ä½æ•° FMC_SDRAM_ROW_BITS_NUM_11/12/13 FMC_SDRAM_ROW_BITS_NUM_13 MemoryDataWidth æ•°æ®çº¿ä½æ•° FMC_SDRAM_MEM_BUS_WIDTH_8/16/32 FMC_SDRAM_MEM_BUS_WIDTH_16 InternalBankNumber bankæ•°ç›® FMC_SDRAM_INTERN_BANKS_NUM_2/4 FMC_SDRAM_INTERN_BANKS_NUM_4 CASLatency CASå»¶è¿Ÿ FMC_SDRAM_CAS_LATENCY_1/2/3 FMC_SDRAM_CAS_LATENCY_3 WriteProtection å†™ä¿æŠ¤æ§åˆ¶ FMC_SDRAM_WRITE_PROTECTION_DISABLE/ENABLE FMC_SDRAM_WRITE_PROTECTION_DISABLE SDClockPeriod SDRAMæ—¶é’Ÿå‘¨æœŸ FMC_SDRAM_CLOCK_DISABLE/PERIOD_2/PERIOD_3 FMC_SDRAM_CLOCK_PERIOD_2 ReadBurst Read_Burstæ§åˆ¶ FMC_SDRAM_RBURST_DISABLE/ENABLE FMC_SDRAM_RBURST_ENABLE ReadPipeDelay Read_Pipe_Delayæ§åˆ¶ FMC_SDRAM_RPIPE_DELAY_0/1/2 FMC_SDRAM_RPIPE_DELAY_1 SDBankå¯¹åº”SDRAMå­˜å‚¨å™¨åŒºåŸŸï¼ŒSTM32F7å¯ä»¥å¤–æ¥2ç‰‡SDRAMï¼Œæœ¬ä¾‹ä»…åœ¨åŒºåŸŸ1æ¥SDRAMï¼› åˆ—åœ°å€ã€è¡Œåœ°å€ã€æ•°æ®çº¿ä½æ•°ã€bankä½æ•°æ ¹æ®SDRAMç›¸åº”å‚æ•°é€‰æ‹©ï¼› CASå»¶è¿Ÿï¼šæœ¬ä¾‹ä¸­SDRAMçš„æ—¶é’Ÿé¢‘ç‡ä¸º108MHzï¼ŒCASå»¶è¿Ÿå¯ä»¥è®¾ç½®ä¸º2ï¼› WriteProtectionï¼šç¦ç”¨å†™ä¿æŠ¤ä»¥æé«˜å†™å…¥æ•ˆç‡ï¼› SDClockPeriodï¼šè®¾ç½®SDCLKç›¸å¯¹äºHCLKçš„åˆ†é¢‘æ•°ï¼Œæœ¬ä¾‹ä¸­HCLKç­‰äºç³»ç»Ÿæ—¶é’Ÿé¢‘ç‡ï¼Œä¸º216MHzï¼ŒSDCLKä¸ºHCLKäºŒåˆ†é¢‘å¾—åˆ°ï¼› ReadBurstï¼šå®šä¹‰åœ¨ CAS å»¶è¿Ÿåå»¶åå¤šå°‘ä¸ª HCLK æ—¶é’Ÿå‘¨æœŸè¯»å–æ•°æ®ï¼Œæœ¬ä¾‹å»¶æ—¶ä¸º0ï¼› SDRAMçš„æ—¶åºå‚æ•°&emsp;SdramTimingç»“æ„ä½“ä¸­å®šä¹‰SDRAMçš„æ—¶åºå‚æ•°ï¼Œå…¶è®¡ç®—æ–¹æ³•å¦‚ä¸‹ã€‚æ³¨æ„æ‰€æœ‰çš„æ—¶é—´å‡æŒ‰ç…§SDRAMæ—¶é’Ÿå‘¨æœŸè®¡ç®—ã€‚ &emsp;æœ¬ä¾‹ä½¿ç”¨çš„SDRAMå‹å·ä¸ºï¼šW9825G6KH-6ï¼Œå…¶æ—¶åºå‚æ•°ä¹Ÿè®°å½•åœ¨è¡¨ä¸­ã€‚ å‚æ•° å®šä¹‰ W9825G6KH-6è¦æ±‚ æœ€ç»ˆå–å€¼ LoadToActiveDelay åŠ è½½æ¨¡å¼å¯„å­˜å™¨åˆ°æ¿€æ´»ï¼šåŠ è½½æ¨¡å¼å¯„å­˜å™¨å‘½ä»¤å’Œæ¿€æ´»æˆ–åˆ·æ–°å‘½ä»¤ä¹‹é—´çš„å»¶è¿Ÿ $t{RSC}=2 \\cdot t{CK}$ 2 ExitSelfRefreshDelay é€€å‡ºè‡ªåˆ·æ–°å»¶è¿Ÿï¼šè‡ªåˆ·æ–°å‘½ä»¤åˆ°å‘å‡ºæ¿€æ´»å‘½ä»¤ä¹‹é—´çš„å»¶è¿Ÿ $t_{XSR}=72ns$ 7.7â‰ˆ8 SelfRefreshTime è‡ªåˆ·æ–°æ—¶é—´ï¼šæœ€çŸ­çš„è‡ªåˆ·æ–°å‘¨æœŸ $t_{RC}=60ns$ 6.5â‰ˆ7 RowCycleDelay è¡Œå¾ªç¯å»¶è¿Ÿï¼šåˆ·æ–°å‘½ä»¤å’Œæ¿€æ´»å‘½ä»¤ä¹‹é—´çš„å»¶è¿Ÿï¼Œä»¥åŠä¸¤ä¸ªç›¸é‚»åˆ·æ–°å‘½ä»¤ä¹‹é—´çš„å»¶è¿Ÿ $t_{RC}=60ns$ 6.5â‰ˆ7 WriteRecoveryTime æ¢å¤å»¶è¿Ÿï¼šå†™å‘½ä»¤å’Œé¢„å……ç”µå‘½ä»¤ä¹‹é—´çš„å»¶è¿Ÿ $t{WR}=2 \\cdot t{CK}$ 2 RPDelay è¡Œé¢„å……ç”µå»¶è¿Ÿï¼šé¢„å……ç”µå‘½ä»¤ä¸å…¶å®ƒå‘½ä»¤ä¹‹é—´çš„å»¶è¿Ÿ $t_{RP}=60ns$ 6.5â‰ˆ7 RCDDelay è¡Œåˆ°åˆ—å»¶è¿Ÿï¼šæ¿€æ´»å‘½ä»¤ä¸è¯»/å†™å‘½ä»¤ä¹‹é—´çš„å»¶è¿Ÿ $t_{RCD}=60ns$ 6.5â‰ˆ7 SDRAMçš„åˆå§‹åŒ–åºåˆ—&emsp;SDRAMçš„åˆå§‹åŒ–åºåˆ—å¦‚ä¸‹æ‰€ç¤ºã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * @brief Perform the SDRAM exernal memory inialization sequence * @param hsdram: SDRAM handle * @param Command: Pointer to SDRAM command structure * @retval None */void SDRAM_Initialization_Sequence(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command)&#123; vuint32 tmpmrd = 0; /* Step 1: Configure a clock configuration enable command */ Command-&gt;CommandMode = FMC_SDRAM_CMD_CLK_ENABLE; Command-&gt;CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1; Command-&gt;AutoRefreshNumber = 1; Command-&gt;ModeRegisterDefinition = 0; /* Send the command */ HAL_SDRAM_SendCommand(hsdram, Command, 0x1000); /* Step 2: Insert 100 us minimum delay */ SYS_Delay_US(500); /* Step 3: Configure a PALL (precharge all) command */ Command-&gt;CommandMode = FMC_SDRAM_CMD_PALL; Command-&gt;CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1; Command-&gt;AutoRefreshNumber = 1; Command-&gt;ModeRegisterDefinition = 0; /* Send the command */ HAL_SDRAM_SendCommand(hsdram, Command, 0x1000); /* Step 4 : Configure a Auto-Refresh command */ Command-&gt;CommandMode = FMC_SDRAM_CMD_AUTOREFRESH_MODE; Command-&gt;CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1; Command-&gt;AutoRefreshNumber = 8; Command-&gt;ModeRegisterDefinition = 0; /* Send the command */ HAL_SDRAM_SendCommand(hsdram, Command, 0x1000); /* Step 5: Program the external memory mode register */ tmpmrd=(uint32)SDRAM_MODEREG_BURST_LENGTH_1 | SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL | SDRAM_MODEREG_CAS_LATENCY_2 | SDRAM_MODEREG_OPERATING_MODE_STANDARD | SDRAM_MODEREG_WRITEBURST_MODE_SINGLE; printf(\"tmpmrd is: %x\\n\", tmpmrd); Command-&gt;CommandMode = FMC_SDRAM_CMD_LOAD_MODE; Command-&gt;CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1; Command-&gt;AutoRefreshNumber = 1; Command-&gt;ModeRegisterDefinition = tmpmrd; /* Send the command */ HAL_SDRAM_SendCommand(hsdram, Command, 0x1000); /* Step 6: Set the refresh rate counter */ HAL_SDRAM_ProgramRefreshRate(&amp;hsdram1,824); &#125; step 1ï¼šä½¿èƒ½SDRAMæ—¶é’Ÿï¼› step 2ï¼šä¸Šç”µåï¼Œåœ¨precharge all bankså‰å»¶æ—¶500usï¼Œæœ¬ä¾‹ä¸­W9825G6KH-6è¦æ±‚æœ€ä½200usï¼› step 3ï¼šprecharge all banksï¼› step 4ï¼šè®¾ç½®è‡ªåˆ·æ–°cycleæ•°ï¼Œæœ¬ä¾‹ä¸­è¦æ±‚è‡³å°‘8ä¸ªAuto Refresh cycles(CBR); step 5ï¼šè®¾ç½®SDRAMæ¨¡å¼å¯„å­˜å™¨ï¼Œåœ¨æœ¬ä¾‹ä¸­ï¼Œè®¾ç½®bursté•¿åº¦ä¸º1(STM32F767è¦æ±‚burst lengthä¸º1ï¼Œæ•°æ®æ‰‹å†Œä¸­åŸæ–‡è¯´æ˜ä¸ºï¼šthe Burst Length (BL) of 1 must be selected by configuring the M[2:0] bits to 000 in the mode register)ã€burstç±»å‹ä¸ºSequentialã€CAS_LATENCYä¸º2(ä¸FMCä¸­SDRAMæ§åˆ¶å™¨è®¾ç½®ç›¸å¯¹åº”)ã€è¿è¡Œæ¨¡å¼ä¸ºæ ‡å‡†ã€Write Burstæ¨¡å¼ä¸ºSingle Location Accessï¼› step 6ï¼šè®¾ç½®FMC_SDRTR å¯„å­˜å™¨ä¸­çš„åˆ·æ–°é€Ÿç‡ï¼Œè®¡ç®—æ–¹æ³•ä¸ºCOUNT = (SDRAM refresh period â„ Number of rows) â€“ 20ï¼Œæœ¬ä¾‹ä¸º824ï¼› è‡³æ­¤ï¼ŒSDRAMé…ç½®å®Œæ¯•ã€‚ SDRAMçš„è¯»å†™å®ç°&emsp;SDRAMçš„è¯»å†™éå¸¸ç®€å•ï¼Œå…¶è¢«å¤„ç†å™¨æ˜ å°„ä¸ºä¸€æ®µèµ·å§‹åœ°å€ä¸º0XC0000000çš„å­˜å‚¨åŒºåŸŸï¼Œå…¶è¯»å†™å®ç°å¦‚ä¸‹æ‰€ç¤ºã€‚ 123456789101112131415161718192021222324252627#define Bank5_SDRAM_ADDR ((uint32)(0XC0000000)) /* SDRAMå¼€å§‹åœ°å€ */void FMC_SDRAM_WriteBuffer16b(uint16 *pSrcBuffer,uint32 WriteAddr,uint32 BufferSize)&#123; __IO uint16_t *pSdramAddress = (uint16_t *)(Bank5_SDRAM_ADDR + WriteAddr); /* Write data to memory */ for(; BufferSize != 0; BufferSize--) &#123; *(__IO uint16_t *)pSdramAddress = *pSrcBuffer; pSrcBuffer++; pSdramAddress++; &#125;&#125;void FMC_SDRAM_ReadBuffer16b(uint16 *pDstBuffer,uint32 pAddress,uint32 BufferSize)&#123; __IO uint16_t *pSdramAddress = (uint16_t *)(Bank5_SDRAM_ADDR + pAddress); /* Read data from source */ for(; BufferSize != 0; BufferSize--) &#123; *pDstBuffer = *(__IO uint16_t *)pSdramAddress; pDstBuffer++; pSdramAddress++; &#125;&#125; SDRAMçš„è¯»å†™æµ‹è¯•&emsp;å¯¹SDRAMè¿›è¡Œè¯»å†™æµ‹è¯•ï¼Œæµ‹è¯•ä»£ç å¦‚ä¸‹ã€‚ 123456#define BUFFER_SIZE (64*1024)uint32 test_addr = 0x00000000;uint32 test_index = 0;uint16 test_writeBuff[BUFFER_SIZE];uint16 test_readBuff[BUFFER_SIZE];uint16 testErrorNum = 0; 123456789101112131415161718192021222324252627282930printf(\"----SDRAM write and read test----\\n\");for (test_index = 0; test_index &lt; BUFFER_SIZE; test_index++)&#123; test_writeBuff[test_index] = test_index % UINT16_MAX;&#125;printf(\"SDRAM write start...\\n\");HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);FMC_SDRAM_WriteBuffer16b(test_writeBuff,test_addr,BUFFER_SIZE);HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);printf(\"SDRAM write finished\\n\\n\"); printf(\"SDRAM read start...\\n\");HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);FMC_SDRAM_ReadBuffer16b(test_readBuff,test_addr,BUFFER_SIZE);HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);printf(\"SDRAM read finished\\n\\n\");HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);for (test_index = 0; test_index &lt; BUFFER_SIZE; test_index++)&#123; if (test_readBuff[test_index] != test_writeBuff[test_index]) &#123; //printf(\"readBuff is NOT equal with writeBuff at: %d\\n\", test_index); testErrorNum++; &#125;&#125;printf(\"Total test number is: %d, error number is: %d\\n\", test_index, testErrorNum); &emsp;æµ‹è¯•ç»“æœè¡¨ç¤ºè¯»å†™æ— è¯¯ã€‚","categories":[{"name":"åµŒå…¥å¼","slug":"åµŒå…¥å¼","permalink":"http://jiaodi.tech/categories/åµŒå…¥å¼/"}],"tags":[{"name":"STM32F7","slug":"STM32F7","permalink":"http://jiaodi.tech/tags/STM32F7/"},{"name":"FMC","slug":"FMC","permalink":"http://jiaodi.tech/tags/FMC/"},{"name":"SDRAM","slug":"SDRAM","permalink":"http://jiaodi.tech/tags/SDRAM/"}]},{"title":"STM32F767 QUADSPIçš„åŸºæœ¬ç”¨æ³•","slug":"stm32f767-qspi","date":"2018-06-30T03:26:08.000Z","updated":"2018-07-16T14:13:21.944Z","comments":true,"path":"2018/06/30/stm32f767-qspi/","link":"","permalink":"http://jiaodi.tech/2018/06/30/stm32f767-qspi/","excerpt":"æœ¬æ–‡ä»‹ç»STM32F767 QUADSPIçš„åŸºæœ¬ç”¨æ³•ã€‚","text":"æœ¬æ–‡ä»‹ç»STM32F767 QUADSPIçš„åŸºæœ¬ç”¨æ³•ã€‚ å¼€å‘ç¯å¢ƒç¡¬ä»¶ç¯å¢ƒ ç”µè„‘ï¼šWindows 10 Home x64 Apollo STM32F767å¼€å‘æ¿(ST-LINK V2ä»¿çœŸå™¨) è½¯ä»¶ç¯å¢ƒ Keil Version 5.24.1 (Pack Installerï¼šKeil.STM32F7xx_DFP.2.9.0.pack) STM32CubeMX Version 4.25.0(Packages Managerï¼šSTM32CubeF7) QUADSPIåŠŸèƒ½ç®€ä»‹ä¸»è¦ç‰¹æ€§ ä¸‰ç§åŠŸèƒ½æ¨¡å¼ï¼šé—´æ¥æ¨¡å¼ã€çŠ¶æ€è½®è¯¢æ¨¡å¼å’Œå†…å­˜æ˜ å°„æ¨¡å¼ åŒé—ªå­˜æ¨¡å¼ï¼Œé€šè¿‡å¹¶è¡Œè®¿é—®ä¸¤ä¸ª Flashï¼Œå¯åŒæ—¶å‘é€/æ¥æ”¶ 8 ä½æ•°æ® æ”¯æŒ SDR å’Œ DDR æ¨¡å¼ é’ˆå¯¹é—´æ¥æ¨¡å¼å’Œå†…å­˜æ˜ å°„æ¨¡å¼ï¼Œå®Œå…¨å¯ç¼–ç¨‹æ“ä½œç  é’ˆå¯¹é—´æ¥æ¨¡å¼å’Œå†…å­˜æ˜ å°„æ¨¡å¼ï¼Œå®Œå…¨å¯ç¼–ç¨‹å¸§æ ¼å¼ é›†æˆ FIFOï¼Œç”¨äºå‘é€å’Œæ¥æ”¶ å…è®¸ 8ã€16 å’Œ 32 ä½æ•°æ®è®¿é—® å…·æœ‰é€‚ç”¨äºé—´æ¥æ¨¡å¼æ“ä½œçš„ DMA é€šé“ åœ¨è¾¾åˆ° FIFO é˜ˆå€¼ã€è¶…æ—¶ã€æ“ä½œå®Œæˆä»¥åŠå‘ç”Ÿè®¿é—®é”™è¯¯æ—¶äº§ç”Ÿä¸­æ–­ QUADSPI å‘½ä»¤åºåˆ—&emsp;QUADSPI é€šè¿‡å‘½ä»¤ä¸ Flash é€šä¿¡æ¯æ¡å‘½ä»¤åŒ…æ‹¬æŒ‡ä»¤ã€åœ°å€ã€äº¤æ›¿å­—èŠ‚ã€ç©ºæŒ‡ä»¤å’Œæ•°æ®è¿™äº”ä¸ªé˜¶æ®µ ä»»ä¸€é˜¶æ®µå‡å¯è·³è¿‡ï¼Œä½†è‡³å°‘è¦åŒ…å«æŒ‡ä»¤ã€åœ°å€ã€äº¤æ›¿å­—èŠ‚æˆ–æ•°æ®é˜¶æ®µä¹‹ä¸€ã€‚nCS åœ¨æ¯æ¡æŒ‡ä»¤å¼€å§‹å‰ä¸‹é™ï¼Œåœ¨æ¯æ¡æŒ‡ä»¤å®Œæˆåå†æ¬¡ä¸Šå‡ã€‚ æŒ‡ä»¤é˜¶æ®µ&emsp;è¿™ä¸€é˜¶æ®µï¼Œå°†åœ¨ QUADSPI_CCR[7:0] å¯„å­˜å™¨çš„ INSTRUCTION å­—æ®µä¸­é…ç½®çš„ä¸€æ¡ 8 ä½æŒ‡ä»¤å‘é€åˆ° Flashï¼ŒæŒ‡å®šå¾…æ‰§è¡Œæ“ä½œçš„ç±»å‹ã€‚&emsp;å°½ç®¡å¤§å¤šæ•° Flash ä» IO0/SO ä¿¡å·(å•çº¿ SPI æ¨¡å¼)åªèƒ½ä»¥ä¸€æ¬¡ 1 ä½çš„æ–¹å¼æ¥æ”¶æŒ‡ä»¤ï¼Œä½†æŒ‡ä»¤é˜¶æ®µå¯é€‰æ‹©ä¸€æ¬¡å‘é€ 2 ä½(åœ¨åŒçº¿ SPI æ¨¡å¼ä¸­é€šè¿‡ IO0/IO1)æˆ–ä¸€æ¬¡å‘é€ 4 ä½(åœ¨å››çº¿SPI æ¨¡å¼ä¸­é€šè¿‡ IO0/IO1/IO2/IO3)ã€‚è¿™å¯é€šè¿‡ QUADSPI_CCR[9:8] å¯„å­˜å™¨ä¸­çš„ IMODE[1:0]å­—æ®µè¿›è¡Œé…ç½®ã€‚&emsp;è‹¥ IMODE = 00ï¼Œåˆ™è·³è¿‡æŒ‡ä»¤é˜¶æ®µï¼Œå‘½ä»¤åºåˆ—ä»åœ°å€é˜¶æ®µ(å¦‚æœå­˜åœ¨)å¼€å§‹ã€‚ åœ°å€é˜¶æ®µ&emsp;åœ¨åœ°å€é˜¶æ®µï¼Œå°† 1-4 å­—èŠ‚å‘é€åˆ° Flashï¼ŒæŒ‡ç¤ºæ“ä½œåœ°å€ã€‚å¾…å‘é€çš„åœ°å€å­—èŠ‚æ•°åœ¨QUADSPI_CCR[13:12] å¯„å­˜å™¨çš„ ADSIZE[1:0] å­—æ®µä¸­è¿›è¡Œé…ç½®ã€‚åœ¨é—´æ¥æ¨¡å¼å’Œè‡ªåŠ¨è½®è¯¢æ¨¡å¼ä¸‹ï¼Œå¾…å‘é€çš„åœ°å€å­—èŠ‚åœ¨ QUADSPI_AR å¯„å­˜å™¨çš„ ADDRESS[31:0] ä¸­æŒ‡å®šã€‚åœ¨å†…å­˜æ˜ å°„æ¨¡å¼ä¸‹ï¼Œåˆ™é€šè¿‡ AHB(æ¥è‡ªäº CortexÂ® æˆ– DMA)ç›´æ¥ç»™å‡ºåœ°å€ã€‚&emsp;åœ°å€é˜¶æ®µå¯ä¸€æ¬¡å‘é€ 1 ä½(åœ¨å•çº¿ SPI æ¨¡å¼ä¸­é€šè¿‡ SO)ã€2 ä½(åœ¨åŒçº¿ SPI æ¨¡å¼ä¸­é€šè¿‡ IO0/IO1)æˆ– 4 ä½(åœ¨å››çº¿ SPI æ¨¡å¼ä¸­é€šè¿‡ IO0/IO1/IO2/IO3)ã€‚è¿™å¯é€šè¿‡QUADSPI_CCR[11:10] å¯„å­˜å™¨ä¸­çš„ ADMODE[1:0] å­—æ®µè¿›è¡Œé…ç½®ã€‚&emsp;è‹¥ ADMODE = 00ï¼Œåˆ™è·³è¿‡åœ°å€é˜¶æ®µï¼Œå‘½ä»¤åºåˆ—ç›´æ¥è¿›å…¥ä¸‹ä¸€é˜¶æ®µ(å¦‚æœå­˜åœ¨)ã€‚ äº¤æ›¿å­—èŠ‚é˜¶æ®µ&emsp;åœ¨äº¤æ›¿å­—èŠ‚é˜¶æ®µï¼Œå°† 1-4 å­—èŠ‚å‘é€åˆ° Flashï¼Œä¸€èˆ¬ç”¨äºæ§åˆ¶æ“ä½œæ¨¡å¼ã€‚å¾…å‘é€çš„äº¤æ›¿å­—èŠ‚æ•°åœ¨ QUADSPI_CCR[17:16] å¯„å­˜å™¨çš„ ABSIZE[1:0] å­—æ®µä¸­è¿›è¡Œé…ç½®ã€‚å¾…å‘é€çš„å­—èŠ‚åœ¨QUADSPI_ABR å¯„å­˜å™¨ä¸­æŒ‡å®šã€‚äº¤æ›¿å­—èŠ‚é˜¶æ®µå¯ä¸€æ¬¡å‘é€ 1 ä½(åœ¨å•çº¿ SPI æ¨¡å¼ä¸­é€šè¿‡ SO)ã€2 ä½(åœ¨åŒçº¿ SPI æ¨¡å¼ä¸­é€šè¿‡ IO0/IO1)æˆ– 4 ä½(åœ¨å››çº¿ SPI æ¨¡å¼ä¸­é€šè¿‡ IO0/IO1/IO2/IO3)ã€‚è¿™å¯é€šè¿‡QUADSPI_CCR[15:14] å¯„å­˜å™¨ä¸­çš„ ABMODE[1:0] å­—æ®µè¿›è¡Œé…ç½®ã€‚&emsp;è‹¥ ABMODE = 00ï¼Œåˆ™è·³è¿‡äº¤æ›¿å­—èŠ‚é˜¶æ®µï¼Œå‘½ä»¤åºåˆ—ç›´æ¥è¿›å…¥ä¸‹ä¸€é˜¶æ®µ(å¦‚æœå­˜åœ¨)ã€‚ ç©ºæŒ‡ä»¤å‘¨æœŸé˜¶æ®µ&emsp;åœ¨ç©ºæŒ‡ä»¤å‘¨æœŸé˜¶æ®µï¼Œç»™å®šçš„ 1-31 ä¸ªå‘¨æœŸå†…ä¸å‘é€æˆ–æ¥æ”¶ä»»ä½•æ•°æ®ï¼Œç›®çš„æ˜¯å½“é‡‡ç”¨æ›´é«˜çš„æ—¶é’Ÿé¢‘ç‡æ—¶ï¼Œç»™ Flash ç•™å‡ºå‡†å¤‡æ•°æ®é˜¶æ®µçš„æ—¶é—´ã€‚è¿™ä¸€é˜¶æ®µä¸­ç»™å®šçš„å‘¨æœŸæ•°åœ¨QUADSPI_CCR[22:18] å¯„å­˜å™¨çš„ DCYC[4:0] å­—æ®µä¸­æŒ‡å®šã€‚åœ¨ SDR å’Œ DDR æ¨¡å¼ä¸‹ï¼ŒæŒç»­æ—¶é—´è¢«æŒ‡å®šä¸ºä¸€å®šä¸ªæ•°çš„å…¨æ—¶é’Ÿå‘¨æœŸã€‚&emsp;è‹¥ DCYC ä¸ºé›¶ï¼Œåˆ™è·³è¿‡ç©ºæŒ‡ä»¤å‘¨æœŸé˜¶æ®µï¼Œå‘½ä»¤åºåˆ—ç›´æ¥è¿›å…¥æ•°æ®é˜¶æ®µ(å¦‚æœå­˜åœ¨)ã€‚&emsp;ç©ºæŒ‡ä»¤å‘¨æœŸé˜¶æ®µçš„æ“ä½œæ¨¡å¼ç”± DMODE ç¡®å®šã€‚&emsp;ä¸ºç¡®ä¿æ•°æ®ä¿¡å·ä»è¾“å‡ºæ¨¡å¼è½¬å˜ä¸ºè¾“å…¥æ¨¡å¼æœ‰è¶³å¤Ÿçš„â€œå‘¨è½¬â€æ—¶é—´ï¼Œä½¿ç”¨åŒçº¿å’Œå››çº¿æ¨¡å¼ä»Flash æ¥æ”¶æ•°æ®æ—¶ï¼Œè‡³å°‘éœ€è¦æŒ‡å®šä¸€ä¸ªç©ºæŒ‡ä»¤å‘¨æœŸã€‚ æ•°æ®é˜¶æ®µ&emsp;åœ¨æ•°æ®é˜¶æ®µï¼Œå¯ä» Flash æ¥æ”¶æˆ–å‘å…¶å‘é€ä»»æ„æ•°é‡çš„å­—èŠ‚ã€‚&emsp;åœ¨é—´æ¥æ¨¡å¼å’Œè‡ªåŠ¨è½®è¯¢æ¨¡å¼ä¸‹ï¼Œå¾…å‘é€/æ¥æ”¶çš„å­—èŠ‚æ•°åœ¨ QUADSPI_DLR å¯„å­˜å™¨ä¸­æŒ‡å®šã€‚&emsp;åœ¨é—´æ¥å†™å…¥æ¨¡å¼ä¸‹ï¼Œå‘é€åˆ° Flash çš„æ•°æ®å¿…é¡»å†™å…¥ QUADSPI_DR å¯„å­˜å™¨ã€‚åœ¨é—´æ¥è¯»å–æ¨¡å¼ä¸‹ï¼Œé€šè¿‡è¯»å– QUADSPI_DR å¯„å­˜å™¨è·å¾—ä» Flash æ¥æ”¶çš„æ•°æ®ã€‚&emsp;åœ¨å†…å­˜æ˜ å°„æ¨¡å¼ä¸‹ï¼Œè¯»å–çš„æ•°æ®é€šè¿‡ AHB ç›´æ¥å‘é€å› Cortex æˆ– DMAã€‚&emsp;æ•°æ®é˜¶æ®µå¯ä¸€æ¬¡å‘é€/ æ¥æ”¶ 1 ä½(åœ¨å•çº¿ SPI æ¨¡å¼ä¸­é€šè¿‡ SO)ã€2 ä½(åœ¨åŒçº¿ SPI æ¨¡å¼ä¸­é€šè¿‡ IO0/IO1)æˆ– 4 ä½(åœ¨å››çº¿ SPI æ¨¡å¼ä¸­é€šè¿‡ IO0/IO1/IO2/IO3)ã€‚è¿™å¯é€šè¿‡QUADSPI_CCR[15:14] å¯„å­˜å™¨ä¸­çš„ ABMODE[1:0] å­—æ®µè¿›è¡Œé…ç½®ã€‚&emsp;è‹¥ DMODE = 00ï¼Œåˆ™è·³è¿‡æ•°æ®é˜¶æ®µï¼Œå‘½ä»¤åºåˆ—åœ¨æ‹‰é«˜ nCS æ—¶ç«‹å³å®Œæˆã€‚è¿™ä¸€é…ç½®ä»…å¯ç”¨äºä»…é—´æ¥å†™å…¥æ¨¡å¼ã€‚ QUADSPI Flash é…ç½®&emsp;è®¾å¤‡é…ç½®å¯„å­˜å™¨ (QUADSPI_DCR) å¯ç”¨äºæŒ‡å®šå¤–éƒ¨ SPI Flash çš„ç‰¹æ€§ã€‚&emsp;FSIZE[4:0] å­—æ®µä½¿ç”¨ä¸‹é¢çš„å…¬å¼å®šä¹‰å¤–éƒ¨å­˜å‚¨å™¨çš„å¤§å°ï¼š$$Flash ä¸­çš„å­—èŠ‚æ•° = 2^{FSIZE+1}$$&emsp;FSIZE+1 æ˜¯å¯¹ Flash å¯»å€æ‰€éœ€çš„åœ°å€ä½æ•°ã€‚åœ¨é—´æ¥æ¨¡å¼ä¸‹ï¼ŒFlash å®¹é‡æœ€é«˜å¯è¾¾ 4GB(ä½¿ç”¨32 ä½è¿›è¡Œå¯»å€)ï¼Œä½†åœ¨å†…å­˜æ˜ å°„æ¨¡å¼ä¸‹çš„å¯å¯»å€ç©ºé—´é™åˆ¶ä¸º 256MBã€‚&emsp;å¦‚æœ DFM = 1ï¼ŒFSIZE è¡¨ç¤ºä¸¤ä¸ª Flash å®¹é‡çš„æ€»å’Œã€‚&emsp;QUADSPI è¿ç»­æ‰§è¡Œä¸¤æ¡å‘½ä»¤æ—¶ï¼Œå®ƒåœ¨ä¸¤æ¡å‘½ä»¤ä¹‹é—´å°†ç‰‡é€‰ä¿¡å· (nCS) ç½®ä¸ºé«˜ç”µå¹³é»˜è®¤ä»…ä¸€ä¸ª CLK å‘¨æœŸæ—¶é•¿ã€‚å¦‚æœ Flash éœ€è¦å‘½ä»¤ä¹‹é—´çš„æ—¶é—´æ›´é•¿ï¼Œå¯ä½¿ç”¨ç‰‡é€‰é«˜ç”µå¹³æ—¶é—´ (CSHT) å­—æ®µæŒ‡å®š nCS å¿…é¡»ä¿æŒé«˜ç”µå¹³çš„æœ€å°‘ CLK å‘¨æœŸæ•°(æœ€å¤§ä¸º 8)ã€‚&emsp;æ—¶é’Ÿæ¨¡å¼ (CKMODE) ä½æŒ‡ç¤ºå‘½ä»¤ä¹‹é—´çš„ CLK ä¿¡å·é€»è¾‘ç”µå¹³(nCS = 1 æ—¶)ã€‚ QUADSPI å»¶è¿Ÿæ•°æ®é‡‡æ ·&emsp;é»˜è®¤æƒ…å†µä¸‹ï¼ŒQUADSPI åœ¨ Flash é©±åŠ¨ä¿¡å·åè¿‡åŠä¸ª CLK å‘¨æœŸæ‰å¯¹ Flash é©±åŠ¨çš„æ•°æ®é‡‡æ ·ã€‚&emsp;åœ¨å¤–éƒ¨ä¿¡å·å»¶è¿Ÿæ—¶ï¼Œè¿™æœ‰åˆ©äºæ¨è¿Ÿæ•°æ®é‡‡æ ·ã€‚ä½¿ç”¨ SSHIFT ä½ (QUADSPI_CR[4])ï¼Œå¯å°†æ•°æ®é‡‡æ ·ç§»ä½åŠä¸ª CLK å‘¨æœŸã€‚&emsp;DDR æ¨¡å¼ä¸‹ä¸æ”¯æŒæ—¶é’Ÿç§»ä½ï¼šè‹¥ DDRM ä½ç½® 1ï¼ŒSSHIFT ä½å¿…é¡»æ¸…é›¶ã€‚ ä½¿ç”¨QSPIè¯»å†™W25Q256FV&emsp;W25Q256ä¸º32MBä¸²è¡Œflashå­˜å‚¨ï¼Œæ”¯æŒdual/quadä¸QPIæ¨¡å¼ã€‚æœ¬ä¾‹ä¸­å°†ä½¿ç”¨QSPIæ¥å£å¯¹W25Q256è¿›è¡Œè¯»å†™ã€‚ QSPIçš„åˆå§‹åŒ–&emsp;QSPIçš„åˆå§‹åŒ–å‡½æ•°å¦‚ä¸‹æ‰€ç¤ºï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103QSPI_HandleTypeDef hqspi;/* QUADSPI init function */void MX_QUADSPI_Init(void)&#123; hqspi.Instance = QUADSPI; hqspi.Init.ClockPrescaler = 2; hqspi.Init.FifoThreshold = 4; hqspi.Init.SampleShifting = QSPI_SAMPLE_SHIFTING_HALFCYCLE; hqspi.Init.FlashSize = QSPI_FLASH_SIZE - 1; hqspi.Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_4_CYCLE; hqspi.Init.ClockMode = QSPI_CLOCK_MODE_0; hqspi.Init.FlashID = QSPI_FLASH_ID_1; hqspi.Init.DualFlash = QSPI_DUALFLASH_DISABLE; if (HAL_QSPI_Init(&amp;hqspi) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125;&#125;void HAL_QSPI_MspInit(QSPI_HandleTypeDef* qspiHandle)&#123; GPIO_InitTypeDef GPIO_InitStruct; if(qspiHandle-&gt;Instance==QUADSPI) &#123; /* USER CODE BEGIN QUADSPI_MspInit 0 */ /* USER CODE END QUADSPI_MspInit 0 */ /* QUADSPI clock enable */ __HAL_RCC_QSPI_CLK_ENABLE(); /**QUADSPI GPIO Configuration PF6 ------&gt; QUADSPI_BK1_IO3 PF7 ------&gt; QUADSPI_BK1_IO2 PF8 ------&gt; QUADSPI_BK1_IO0 PF9 ------&gt; QUADSPI_BK1_IO1 PB2 ------&gt; QUADSPI_CLK PB6 ------&gt; QUADSPI_BK1_NCS */ GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_HIGH; GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI; HAL_GPIO_Init(GPIOF, &amp;GPIO_InitStruct); GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_HIGH; GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI; HAL_GPIO_Init(GPIOF, &amp;GPIO_InitStruct); GPIO_InitStruct.Pin = GPIO_PIN_2; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_HIGH; GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI; HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct); GPIO_InitStruct.Pin = GPIO_PIN_6; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_PULLUP; GPIO_InitStruct.Speed = GPIO_SPEED_HIGH; GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI; HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct); /* USER CODE BEGIN QUADSPI_MspInit 1 */ /* USER CODE END QUADSPI_MspInit 1 */ &#125;&#125;void HAL_QSPI_MspDeInit(QSPI_HandleTypeDef* qspiHandle)&#123; if(qspiHandle-&gt;Instance==QUADSPI) &#123; /* USER CODE BEGIN QUADSPI_MspDeInit 0 */ /* USER CODE END QUADSPI_MspDeInit 0 */ /* Peripheral clock disable */ __HAL_RCC_QSPI_CLK_DISABLE(); /**QUADSPI GPIO Configuration PF6 ------&gt; QUADSPI_BK1_IO3 PF7 ------&gt; QUADSPI_BK1_IO2 PF8 ------&gt; QUADSPI_BK1_IO0 PF9 ------&gt; QUADSPI_BK1_IO1 PB2 ------&gt; QUADSPI_CLK PB6 ------&gt; QUADSPI_BK1_NCS */ HAL_GPIO_DeInit(GPIOF, GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9); HAL_GPIO_DeInit(GPIOB, GPIO_PIN_2|GPIO_PIN_6); /* USER CODE BEGIN QUADSPI_MspDeInit 1 */ /* USER CODE END QUADSPI_MspDeInit 1 */ &#125;&#125; &emsp;å…¶ä¸»è¦åŠŸèƒ½ä¸ºï¼š æŸ¥è¯¢W25Q256FVæ‰‹å†Œå¯çŸ¥ï¼Œå…¶æœ€å¤§å¯æ”¯æŒçš„è¯»å†™æ—¶é’Ÿé¢‘ç‡ä¸º104MHzï¼›QSPIä½¿ç”¨AHB1æ—¶é’Ÿï¼ŒAHBä¸»æ—¶é’Ÿçš„é¢‘ç‡ä¸º216MHzï¼Œè®¾ç½®åˆ†é¢‘ç³»æ•°ä¸º2ï¼Œåˆ™QSPIæ—¶é’Ÿä¸º72MHzï¼› è®¾ç½®QSPIçš„FIFOæ·±åº¦ä¸º4byteï¼› è®¾ç½®ç§»ä½åŠä¸ªå‘¨æœŸè¿›è¡Œæ•°æ®é‡‡æ ·ï¼Œæœ‰åŠ©äºæé«˜æ•°æ®è¯»å–ç¨³å®šæ€§ï¼› è®¾ç½®flashå®¹é‡å‚æ•°ä¸º32MBï¼Œå¯¹åº”QSPI_FLASH_SIZEä¸º25ï¼› æŸ¥è¯¢W25Q256FVæ‰‹å†Œå¯çŸ¥ï¼ŒCSç‰‡é€‰ä¿¡å·çš„ç¦æ­¢æ—¶é—´è‡³å°‘ä¸º50nsï¼›å› æ­¤è®¾ç½®ç‰‡é€‰é«˜ç”µå¹³æ—¶é—´ä¸º4ä¸ªæ—¶é’Ÿå‘¨æœŸï¼› æ—¶é’Ÿæ¨¡å¼ä¸ºæ¨¡å¼0ï¼Œå³ç‰‡é€‰ä¿¡å·CSé‡Šæ”¾åï¼ŒCLKä¿æŒä½ç”µå¹³ï¼›W25Q256FVå¯¹æ­¤æ— è¦æ±‚ï¼› FlashIDé€‰æ‹©Flash ID 1ï¼› éåŒflashæ¨¡å¼ï¼› åˆå§‹åŒ–QSPIã€‚ &emsp;åˆå§‹åŒ–å‡½æ•°å¦‚ä¸‹æ‰€ç¤ºã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273HAL_StatusTypeDef HAL_QSPI_Init(QSPI_HandleTypeDef *hqspi)&#123; HAL_StatusTypeDef status = HAL_ERROR; uint32_t tickstart = HAL_GetTick(); /* Check the QSPI handle allocation */ if(hqspi == NULL) &#123; return HAL_ERROR; &#125; /* Check the parameters */ assert_param(IS_QSPI_ALL_INSTANCE(hqspi-&gt;Instance)); assert_param(IS_QSPI_CLOCK_PRESCALER(hqspi-&gt;Init.ClockPrescaler)); assert_param(IS_QSPI_FIFO_THRESHOLD(hqspi-&gt;Init.FifoThreshold)); assert_param(IS_QSPI_SSHIFT(hqspi-&gt;Init.SampleShifting)); assert_param(IS_QSPI_FLASH_SIZE(hqspi-&gt;Init.FlashSize)); assert_param(IS_QSPI_CS_HIGH_TIME(hqspi-&gt;Init.ChipSelectHighTime)); assert_param(IS_QSPI_CLOCK_MODE(hqspi-&gt;Init.ClockMode)); assert_param(IS_QSPI_DUAL_FLASH_MODE(hqspi-&gt;Init.DualFlash)); if (hqspi-&gt;Init.DualFlash != QSPI_DUALFLASH_ENABLE ) &#123; assert_param(IS_QSPI_FLASH_ID(hqspi-&gt;Init.FlashID)); &#125; /* Process locked */ __HAL_LOCK(hqspi); if(hqspi-&gt;State == HAL_QSPI_STATE_RESET) &#123; /* Allocate lock resource and initialize it */ hqspi-&gt;Lock = HAL_UNLOCKED; /* Init the low level hardware : GPIO, CLOCK */ HAL_QSPI_MspInit(hqspi); /* Configure the default timeout for the QSPI memory access */ HAL_QSPI_SetTimeout(hqspi, HAL_QPSI_TIMEOUT_DEFAULT_VALUE); &#125; /* Configure QSPI FIFO Threshold */ MODIFY_REG(hqspi-&gt;Instance-&gt;CR, QUADSPI_CR_FTHRES, ((hqspi-&gt;Init.FifoThreshold - 1) &lt;&lt; 8)); /* Wait till BUSY flag reset */ status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi-&gt;Timeout); if(status == HAL_OK) &#123; /* Configure QSPI Clock Prescaler and Sample Shift */ MODIFY_REG(hqspi-&gt;Instance-&gt;CR,(QUADSPI_CR_PRESCALER | QUADSPI_CR_SSHIFT | QUADSPI_CR_FSEL | QUADSPI_CR_DFM), ((hqspi-&gt;Init.ClockPrescaler &lt;&lt; 24)| hqspi-&gt;Init.SampleShifting | hqspi-&gt;Init.FlashID| hqspi-&gt;Init.DualFlash )); /* Configure QSPI Flash Size, CS High Time and Clock Mode */ MODIFY_REG(hqspi-&gt;Instance-&gt;DCR, (QUADSPI_DCR_FSIZE | QUADSPI_DCR_CSHT | QUADSPI_DCR_CKMODE), ((hqspi-&gt;Init.FlashSize &lt;&lt; 16) | hqspi-&gt;Init.ChipSelectHighTime | hqspi-&gt;Init.ClockMode)); /* Enable the QSPI peripheral */ __HAL_QSPI_ENABLE(hqspi); /* Set QSPI error code to none */ hqspi-&gt;ErrorCode = HAL_QSPI_ERROR_NONE; /* Initialize the QSPI state */ hqspi-&gt;State = HAL_QSPI_STATE_READY; &#125; /* Release Lock */ __HAL_UNLOCK(hqspi); /* Return function status */ return status;&#125; &emsp;å…¶å…·ä½“é…ç½®é€šè¿‡QUADSPI æ§åˆ¶å¯„å­˜å™¨ (QUADSPI_CR)ä¸QUADSPI å™¨ä»¶é…ç½®å¯„å­˜å™¨ (QUADSPI_CCR)å®ç°ï¼Œè¿™é‡Œä¸å†è¯¦ç»†è¯´æ˜ã€‚ QSPIçš„æŒ‡ä»¤ä¸è¯»å†™å®ç°&emsp;QSPIçš„æŒ‡ä»¤å‘é€å‡½æ•°å¦‚ä¸‹æ‰€ç¤ºã€‚è¯¥å‡½æ•°çš„è¾“å…¥å‚æ•°å¯ä»¥å®Œæ•´å®ç°å¯¹æŒ‡ä»¤é˜¶æ®µçš„æ§åˆ¶ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940/** * è¯´æ˜ï¼š ä½¿ç”¨QSPIå‘é€Cmd * å‚æ•°ï¼š insModeï¼š æŒ‡ä»¤æ¨¡å¼ * insï¼š æŒ‡ä»¤å€¼ * addrModeï¼šåœ°å€æ¨¡å¼ * addrï¼š åœ°å€å€¼ * addrSizeï¼š åœ°å€å€¼å¤§å° * alterModeï¼š å¤ç”¨å­—èŠ‚æ¨¡å¼ * alterï¼š å¤ç”¨å­—èŠ‚å€¼ * altersizeï¼š å¤ç”¨å­—èŠ‚å¤§å° * dummyCyclesï¼š ç©ºå‘¨æœŸæ—¶é’Ÿæ•° * dataModeï¼š æ•°æ®æ¨¡å¼ * @è¿”å›å€¼ æ—  */QSPI_StatusTypeDef QSPI_SendCmd(uint32_t insMode, uint32 ins, uint32_t addrMode, uint32_t addr, uint32_t addrSize, uint32 alterMode, uint32 alter, uint32 altersize, uint32_t dummyCycles, uint32_t dataMode)&#123; QSPI_CommandTypeDef qspiCmdhandler; qspiCmdhandler.Instruction = ins; qspiCmdhandler.Address = addr; qspiCmdhandler.AlternateBytes = alter; qspiCmdhandler.AddressSize=addrSize; qspiCmdhandler.AlternateBytesSize = altersize; qspiCmdhandler.DummyCycles = dummyCycles; qspiCmdhandler.InstructionMode = insMode; qspiCmdhandler.AddressMode = addrMode; qspiCmdhandler.AlternateByteMode = alterMode; qspiCmdhandler.DataMode=dataMode; qspiCmdhandler.SIOOMode=QSPI_SIOO_INST_EVERY_CMD; qspiCmdhandler.DdrMode=QSPI_DDR_MODE_DISABLE; qspiCmdhandler.DdrHoldHalfCycle=QSPI_DDR_HHC_ANALOG_DELAY; if (HAL_OK == HAL_QSPI_Command(&amp;hqspi,&amp;qspiCmdhandler,HAL_QPSI_TIMEOUT_DEFAULT_VALUE)) return QSPI_OK; else return QSPI_ERROR;&#125; &emsp;QSPIçš„çš„è¯»å†™å‡½æ•°å®ç°å¦‚ä¸‹ï¼Œå‡åˆ©ç”¨äº†HALåº“å®Œæˆã€‚ 1234567891011121314151617QSPI_StatusTypeDef QSPI_Receive(uint8 *buf,uint32 datalen)&#123; hqspi.Instance-&gt;DLR = datalen - 1; if(HAL_OK == HAL_QSPI_Receive(&amp;hqspi,buf,HAL_QPSI_TIMEOUT_DEFAULT_VALUE)) return QSPI_OK; else return QSPI_ERROR;&#125;QSPI_StatusTypeDef QSPI_Transmit(uint8 *buf,uint32 datalen)&#123; hqspi.Instance-&gt;DLR = datalen - 1; if(HAL_OK == HAL_QSPI_Transmit(&amp;hqspi,buf,HAL_QPSI_TIMEOUT_DEFAULT_VALUE)) return QSPI_OK; else return QSPI_ERROR;&#125; W25Q256FVçš„åˆå§‹åŒ–æ“ä½œæ¡†å›¾&emsp;W25Q256FVçš„æ“ä½œæ¡†å›¾å¦‚ä¸‹æ‰€ç¤ºã€‚å…¶ä¸Šç”µåæ ¹æ®ADPçš„å€¼å†³å®šè¿›å…¥3byteæˆ–è€…4byteåœ°å€çº¿æ¨¡å¼ï¼Œå•å‡å¤„äºSPIæ¨¡å¼ä¸‹ã€‚ä¹‹åå¯ä»¥æ§åˆ¶å…¶è¿›å»QPIæ¨¡å¼ã€‚ &emsp;æœ¬ä¾‹ä¸­ï¼Œå°†å…¶æ§åˆ¶åœ¨QPIæ¨¡å¼ä»¥è¾¾åˆ°æœ€é«˜æ€§èƒ½ã€‚ è¿è¡Œæ¨¡å¼åˆ¤æ–­&emsp;è¿è¡Œæ¨¡å¼çš„åˆ¤æ–­é€šè¿‡ä»¥SPI/QPIè¯»å–Device IDå®ç°ï¼Œå“ªç§æ–¹æ³•å¯ä»¥å¾—åˆ°æ­£ç¡®çš„IDåˆ™è¯´æ˜å…·ä½“ä¸ºå“ªç§æ¨¡å¼ï¼›ç¡®è®¤æ¨¡å¼åï¼Œåœ¨è¯»å–ADPå€¼ç¡®è®¤æ˜¯3byteæˆ–è€…4byteåœ°å€çº¿æ¨¡å¼ã€‚ &emsp;å‡½æ•°å®ç°å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839W25QxxModeTypeDef GetW25QxxMode(void)&#123; uint16 id = 0; uint8 buf; if (QSPI_OK != W25QxxReadDeciveID(&amp;id, SPI_3_Byte)) return UnknownMode; if (Q25Q256FV_ID == id) &#123; if (QSPI_OK != QSPI_SendCmd(QSPI_INSTRUCTION_1_LINE, ReadStatusReg3, QSPI_ADDRESS_NONE, 0, 0, QSPI_ALTERNATE_BYTES_NONE, 0, 0, 0, QSPI_DATA_1_LINE)) return UnknownMode; if (QSPI_OK != QSPI_Receive(&amp;buf,1)) return UnknownMode; if ((buf &amp; ReadStatusReg3_ADS_Msk) != ReadStatusReg3_ADS_Msk) return SPI_3_Byte; else return SPI_4_Byte; &#125; if (QSPI_OK != W25QxxReadDeciveID(&amp;id, QPI_3_Byte)) return UnknownMode; if (Q25Q256FV_ID == id) &#123; if (QSPI_OK != QSPI_SendCmd(QSPI_INSTRUCTION_4_LINES, ReadStatusReg3, QSPI_ADDRESS_NONE, 0, 0, QSPI_ALTERNATE_BYTES_NONE, 0, 0, 0, QSPI_DATA_4_LINES)) return UnknownMode; if (QSPI_OK != QSPI_Receive(&amp;buf,1)) return UnknownMode; if ((buf &amp; ReadStatusReg3_ADS_Msk) != ReadStatusReg3_ADS_Msk) return QPI_3_Byte; else return QPI_4_Byte; &#125; return UnknownMode;&#125; åˆå§‹åŒ–&emsp;W25Q256FVåˆå§‹åŒ–å‡½æ•°çš„åŠŸèƒ½åŒ…æ‹¬ï¼š è®¾ç½®ä¸ºQPIæ¨¡å¼ï¼› è®¾ç½®ä¸º4byteåœ°å€çº¿æ¨¡å¼ï¼› è®¾ç½®SetReadParameterså‚æ•°ï¼Œä»¥ä¾¿è·å¾—æœ€é«˜è¯»å†™é€Ÿåº¦ï¼› 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950QSPI_StatusTypeDef W25QxxEnterQspiMode_FourByte(void)&#123; uint8 buf = 0; QSPI_StatusTypeDef res = QSPI_OK; if (QSPI_OK != W25QxxReadReg(ReadStatusReg2, &amp;buf)) return QSPI_ERROR; if ((buf &amp; ReadStatusReg2_QE_Msk) != ReadStatusReg2_QE_Msk) &#123; if (QSPI_OK != W25QxxWriteVolatileEnable()) return QSPI_ERROR; buf |= ReadStatusReg2_QE_Msk; if (QSPI_OK != W25QxxWriteReg(WriteStatusReg2, &amp;buf)) return QSPI_ERROR; if (QSPI_OK != W25QxxWriteDisable()) return QSPI_ERROR; &#125; if ((W25QxxMode == SPI_3_Byte) || (W25QxxMode == SPI_4_Byte)) res = QSPI_SendCmd(QSPI_INSTRUCTION_1_LINE, EnterQPIMode, QSPI_ADDRESS_NONE, 0, 0, QSPI_ALTERNATE_BYTES_NONE, 0, 0, 0, QSPI_DATA_NONE); if (res != QSPI_OK) return QSPI_ERROR; if (QSPI_OK != W25QxxReadReg(ReadStatusReg3, &amp;buf)) return QSPI_ERROR; if ((buf &amp; ReadStatusReg3_ADP_Msk) != ReadStatusReg3_ADP_Msk) &#123; if (QSPI_OK != W25QxxWriteVolatileEnable()) return QSPI_ERROR; buf |= ReadStatusReg3_ADP_Msk; if (QSPI_OK != W25QxxWriteReg(WriteStatusReg3, &amp;buf)) return QSPI_ERROR; if (QSPI_OK != W25QxxWriteDisable()) return QSPI_ERROR; if (QSPI_OK != QSPI_SendCmd(QSPI_INSTRUCTION_4_LINES, Enter4ByteAddrMode, QSPI_ADDRESS_NONE, 0, 0, QSPI_ALTERNATE_BYTES_NONE, 0, 0, 0, QSPI_DATA_NONE)) return QSPI_ERROR; &#125; W25QxxMode = QPI_4_Byte; if (QSPI_OK != QSPI_SendCmd(QSPI_INSTRUCTION_4_LINES, SetReadParameters, QSPI_ADDRESS_NONE, 0, 0, QSPI_ALTERNATE_BYTES_NONE, 0, 0, 0, QSPI_DATA_4_LINES)) return QSPI_ERROR; buf = SetReadParametersVal; if (QSPI_OK != QSPI_Transmit(&amp;buf,1)) return QSPI_ERROR; return QSPI_OK;&#125; æ“¦é™¤ä¸è¯»å†™æ“ä½œ&emsp;W25Q256FVåˆå§‹åŒ–å®Œæ¯•åï¼ŒæŒ‰ç…§QPI 4byteæ¨¡å¼å¯¹å…¶è¿›è¡Œæ“¦é™¤ä¸è¯»å†™æ“ä½œã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970QSPI_StatusTypeDef W25QxxEraseSector4KB(uint32 addr)&#123; if (QSPI_OK != W25QxxWriteEnable()) return QSPI_ERROR; while (isW25QxxBusy() == TRUE) &#123;printf(\"4KB erase done: %x\\n\", addr);&#125;; if (QSPI_OK != QSPI_SendCmd(QSPI_INSTRUCTION_4_LINES, EraseSector4KB, QSPI_ADDRESS_4_LINES, addr, QSPI_ADDRESS_32_BITS, QSPI_ALTERNATE_BYTES_NONE, 0, 0, 0, QSPI_DATA_NONE)) return QSPI_ERROR; while (isW25QxxBusy() == TRUE) &#123;printf(\"W25QxxEraseSector4KB: %x\\n\", addr);&#125;; return QSPI_OK;&#125;QSPI_StatusTypeDef W25QxxEraseSector64KB(uint32 addr)&#123; if (QSPI_OK != W25QxxWriteEnable()) return QSPI_ERROR; while (isW25QxxBusy() == TRUE) &#123;printf(\"4KB erase done: %x\\n\", addr);&#125;; if (QSPI_OK != QSPI_SendCmd(QSPI_INSTRUCTION_4_LINES, EraseSector64KB, QSPI_ADDRESS_4_LINES, addr, QSPI_ADDRESS_32_BITS, QSPI_ALTERNATE_BYTES_NONE, 0, 0, 0, QSPI_DATA_NONE)) return QSPI_ERROR; while (isW25QxxBusy() == TRUE) &#123;printf(\"W25QxxEraseSector64KB: %x\\n\", addr);&#125;; return QSPI_OK;&#125;QSPI_StatusTypeDef W25QxxEraseChip(void)&#123; if (QSPI_OK != W25QxxWriteEnable()) return QSPI_ERROR; while (isW25QxxBusy() == TRUE) &#123;printf(\"W25QxxEraseChip\\n\");&#125;; if (QSPI_OK != QSPI_SendCmd(QSPI_INSTRUCTION_4_LINES, ChipErase, QSPI_ADDRESS_NONE, 0, 0, QSPI_ALTERNATE_BYTES_NONE, 0, 0, 0, QSPI_DATA_NONE)) return QSPI_ERROR; while (isW25QxxBusy() == TRUE) &#123;printf(\"W25QxxEraseChip\\n\");&#125;; return QSPI_OK;&#125;QSPI_StatusTypeDef W25QxxWritePage32B(uint32 addr, uint8 *writeBuff, uint32 writeBuffLen)&#123; if (QSPI_OK != W25QxxWriteEnable()) return QSPI_ERROR; if (QSPI_OK != QSPI_SendCmd(QSPI_INSTRUCTION_4_LINES, PageProgram32B, QSPI_ADDRESS_4_LINES, addr, QSPI_ADDRESS_32_BITS, QSPI_ALTERNATE_BYTES_NONE, 0, 0, 0, QSPI_DATA_4_LINES)) return QSPI_ERROR; if (QSPI_OK != QSPI_Transmit(writeBuff,writeBuffLen)) return QSPI_ERROR; while (isW25QxxBusy() == TRUE) &#123;printf(\"W25QxxWritePage32B: %x\\n\", addr);&#125;; return QSPI_OK;&#125;QSPI_StatusTypeDef W25QxxRead(uint32 addr, uint8 *readBuff, uint32 readBuffLen)&#123; if (QSPI_OK != QSPI_SendCmd(QSPI_INSTRUCTION_4_LINES, FastRead, QSPI_ADDRESS_4_LINES, addr, QSPI_ADDRESS_32_BITS, QSPI_ALTERNATE_BYTES_NONE, 0, 0, 8, QSPI_DATA_4_LINES)) return QSPI_ERROR; if (QSPI_OK != QSPI_Receive(readBuff, readBuffLen)) return QSPI_ERROR; while (isW25QxxBusy() == TRUE) &#123;printf(\"busy\");&#125;; return QSPI_OK;&#125; å®éªŒéªŒè¯&emsp;æµ‹è¯•å‡½æ•°è®¾ç½®å¦‚ä¸‹ï¼š ç¨‹åºé¦–å…ˆæ“¦é™¤äº†åœ°å€test_addræ‰€åœ¨çš„4KBåŒºåŸŸï¼› ä¹‹åè¯»å–æ“¦é™¤åçš„test_addræ‰€åœ¨åŒºåŸŸæ•°å€¼å¹¶æ‰“å°ï¼› å¯¹test_addræ‰€åœ¨åŒºåŸŸè¿›è¡Œ32byteçš„æ•°å€¼å†™å…¥ï¼› è¯»å–å†™å…¥åŒºåŸŸçš„æ•°å€¼å¹¶æ‰“å°ç¡®å®šæ˜¯å¦æ­£ç¡®å†™å…¥ã€‚ 123456789101112131415161718192021222324252627uint32 test_addr = 0x00000000;uint32 test_index = 0;uint8 test_writeBuff[256];uint8 test_readBuff[256];printf(\"4KB erase addr is: %x\\n\", test_addr);res = W25QxxEraseSector4KB(test_addr);printf(\"W25QxxEraseSector4KB(test_addr) res is: %x\\n\", res);printf(\"4KB erase done: %x\\n\\n\", test_addr);res = W25QxxRead(test_addr, test_readBuff, 256); printf(\"W25QxxRead res is: %x\\n\", res); for (test_index = 0; test_index &lt; 256; test_index++) printf(\"test_readBuff[test_index] is: %x\\n\", test_readBuff[test_index]); for (test_index = 0; test_index &lt; 256; test_index++) test_writeBuff[test_index] = test_index; res = W25QxxWritePage32B(test_addr, test_writeBuff, 256); printf(\"W25QxxWritePage32B res is: %x\\n\", res); res = W25QxxRead(test_addr, test_readBuff, 256); printf(\"W25QxxRead res is: %x\\n\", res); for (test_index = 0; test_index &lt; 256; test_index++) printf(\"test_readBuff[test_index] is: %x\\n\", test_readBuff[test_index]); &emsp;ç¨‹åºè¿è¡Œç»“æœç¬¦åˆé¢„æœŸã€‚åŠ¡å¿…æ³¨æ„è¯»å†™æ“ä½œæ‰€é’ˆå¯¹çš„åŒºåŸŸå¿…é¡»é¦–å…ˆå®Œæˆæ“¦é™¤æ“ä½œã€‚","categories":[{"name":"åµŒå…¥å¼","slug":"åµŒå…¥å¼","permalink":"http://jiaodi.tech/categories/åµŒå…¥å¼/"}],"tags":[{"name":"STM32F7","slug":"STM32F7","permalink":"http://jiaodi.tech/tags/STM32F7/"},{"name":"QUADSPI","slug":"QUADSPI","permalink":"http://jiaodi.tech/tags/QUADSPI/"}]},{"title":"STM32F767 Flashçš„åŸºæœ¬ç”¨æ³•","slug":"stm32f767-flash","date":"2018-05-27T03:26:08.000Z","updated":"2018-05-28T16:04:36.636Z","comments":true,"path":"2018/05/27/stm32f767-flash/","link":"","permalink":"http://jiaodi.tech/2018/05/27/stm32f767-flash/","excerpt":"&emsp;æœ¬æ–‡ä»‹ç»STM32F767 Flashçš„åŸºæœ¬ç”¨æ³•ã€‚","text":"&emsp;æœ¬æ–‡ä»‹ç»STM32F767 Flashçš„åŸºæœ¬ç”¨æ³•ã€‚ å¼€å‘ç¯å¢ƒç¡¬ä»¶ç¯å¢ƒ ç”µè„‘ï¼šWindows 10 Home x64 Apollo STM32F767å¼€å‘æ¿(ST-LINK V2ä»¿çœŸå™¨) è½¯ä»¶ç¯å¢ƒ Keil Version 5.24.1 (Pack Installerï¼šKeil.STM32F7xx_DFP.2.9.0.pack) STM32CubeMX Version 4.25.0(Packages Managerï¼šSTM32CubeF7) FlashåŠŸèƒ½ä»‹ç»Flashæ„æˆ&emsp;Flash å…·æœ‰ä»¥ä¸‹ä¸»è¦ç‰¹æ€§ï¼š å®¹é‡é«˜è¾¾ 1 MBï¼› 256 ä½å®½æ•°æ®è¯»å–ï¼› å­—èŠ‚ã€åŠå­—ã€å­—å’ŒåŒå­—æ•°æ®å†™å…¥ï¼› æ‰‡åŒºæ“¦é™¤ä¸å…¨éƒ¨æ“¦é™¤ï¼› &emsp;Flashç»“æ„å¦‚ä¸‹ï¼š ä¸»å­˜å‚¨å™¨å—ï¼šåˆ†ä¸º 4 ä¸ª 32 KB æ‰‡åŒºã€1 ä¸ª 128 KB æ‰‡åŒºå’Œ 3 ä¸ª 256 KB æ‰‡åŒºï¼› ä¿¡æ¯å—ï¼šç³»ç»Ÿå­˜å‚¨å™¨ã€OTPå’Œé€‰é¡¹å­—èŠ‚ è¯»è®¿é—®å»¶æ—¶&emsp;è¯¥éƒ¨åˆ†å†…å®¹åœ¨ç³»ç»Ÿå†…æ ¸ä¸æ—¶é’Ÿè®¾ç½®æ–‡ä¸­å·²ç»è®²è§£ï¼Œè¿™é‡Œä¸å†ä»‹ç»ã€‚ Flashæ§åˆ¶å™¨è§£é”&emsp;å¤ä½åï¼ŒFlash æ§åˆ¶å¯„å­˜å™¨ (FLASH_CR) ä¸å…è®¸æ‰§è¡Œå†™æ“ä½œï¼Œä»¥é˜²å› ç”µæ°”å¹²æ‰°ç­‰åŸå› å‡ºç°å¯¹Flash çš„æ„å¤–æ“ä½œã€‚æ­¤å¯„å­˜å™¨çš„è§£é”é¡ºåºå¦‚ä¸‹ï¼š åœ¨ Flash å¯†é’¥å¯„å­˜å™¨ (FLASH_KEYR) ä¸­å†™å…¥ KEY1 = 0x45670123ï¼› åœ¨ Flash å¯†é’¥å¯„å­˜å™¨ (FLASH_KEYR) ä¸­å†™å…¥ KEY2 = 0xCDEF89ABã€‚ ç¼–ç¨‹/æ“¦é™¤å¹¶è¡Œä½æ•°&emsp;é€šè¿‡ FLASH_CR å¯„å­˜å™¨ä¸­çš„ PSIZE åŸŸé…ç½®å¹¶è¡Œä½æ•°ã€‚å¹¶è¡Œä½æ•°è¡¨ç¤ºæ¯æ¬¡å¯¹ Flash è¿›è¡Œå†™æ“ä½œæ—¶å°†ç¼–ç¨‹çš„å­—èŠ‚æ•°ã€‚PSIZE å—é™äºç”µæºç”µå‹ä»¥åŠæ˜¯å¦ä½¿ç”¨å¤–éƒ¨ VPP ç”µæºã€‚å› æ­¤ï¼Œåœ¨è¿›è¡Œä»»ä½•ç¼–ç¨‹/æ“¦é™¤æ“ä½œå‰ï¼Œå¿…é¡»åœ¨ FLASH_CR å¯„å­˜å™¨ä¸­å¯¹å…¶è¿›è¡Œæ­£ç¡®é…ç½®ã€‚ Flashæ“¦é™¤é¡ºåº&emsp;Flash æ“¦é™¤æ“ä½œå¯é’ˆå¯¹æ‰‡åŒºæˆ–æ•´ä¸ª Flashï¼ˆæ‰¹é‡æ“¦é™¤ï¼‰æ‰§è¡Œã€‚æ‰§è¡Œæ‰¹é‡æ“¦é™¤æ—¶ï¼Œä¸ä¼šå½±å“ OTPæ‰‡åŒºæˆ–é…ç½®æ‰‡åŒºã€‚ æ‰‡åŒºæ“¦é™¤&emsp;æ‰‡åŒºæ“¦é™¤çš„å…·ä½“æ­¥éª¤å¦‚ä¸‹ï¼š æ£€æŸ¥ FLASH_SR å¯„å­˜å™¨ä¸­çš„ BSY ä½ï¼Œä»¥ç¡®è®¤å½“å‰æœªæ‰§è¡Œä»»ä½• Flash æ“ä½œï¼› åœ¨ FLASH_CR å¯„å­˜å™¨ä¸­å°† SER ä½ç½® 1 å¹¶é€‰æ‹©éœ€è¦æ“¦é™¤çš„æ‰‡åŒº (SNB)ï¼Œæ‰€é€‰æ‰‡åŒºåº”ä¸ºä¸»å­˜å‚¨å™¨å—ä¸­çš„ 8 ä¸ªæ‰‡åŒºä¹‹ä¸€ï¼› å°† FLASH_CR å¯„å­˜å™¨ä¸­çš„ STRT ä½ç½® 1ï¼› ç­‰å¾… BSY ä½æ¸…é›¶ã€‚ æ‰¹é‡æ“¦é™¤&emsp;è¦æ‰§è¡Œæ‰¹é‡æ“¦é™¤ï¼Œå»ºè®®é‡‡ç”¨ä»¥ä¸‹æ­¥éª¤ï¼š æ£€æŸ¥ FLASH_SR å¯„å­˜å™¨ä¸­çš„ BSY ä½ï¼Œä»¥ç¡®è®¤å½“å‰æœªæ‰§è¡Œä»»ä½• Flash æ“ä½œï¼› å°† FLASH_CR å¯„å­˜å™¨ä¸­çš„ MER ä½ç½® 1ï¼› å°† FLASH_CR å¯„å­˜å™¨ä¸­çš„ STRT ä½ç½® 1ï¼› ç­‰å¾… BSY ä½æ¸…é›¶ã€‚ Flashç¼–ç¨‹é¡ºåºæ ‡å‡†ç¼–ç¨‹&emsp;Flash ç¼–ç¨‹é¡ºåºå¦‚ä¸‹ï¼š æ£€æŸ¥ FLASH_SR ä¸­çš„ BSY ä½ï¼Œä»¥ç¡®è®¤å½“å‰æœªæ‰§è¡Œä»»ä½•ä¸»è¦ Flash æ“ä½œï¼› å°† FLASH_CR å¯„å­˜å™¨ä¸­çš„ PG ä½ç½® 1ï¼› é’ˆå¯¹æ‰€éœ€å­˜å‚¨å™¨åœ°å€ï¼ˆä¸»å­˜å‚¨å™¨å—æˆ– OTP åŒºåŸŸå†…ï¼‰æ‰§è¡Œæ•°æ®å†™å…¥æ“ä½œï¼šâ€“ å¹¶è¡Œä½æ•°ä¸º x8 æ—¶æŒ‰å­—èŠ‚å†™å…¥â€“ å¹¶è¡Œä½æ•°ä¸º x16 æ—¶æŒ‰åŠå­—å†™å…¥â€“ å¹¶è¡Œä½æ•°ä¸º x32 æ—¶æŒ‰å­—å†™å…¥â€“ å¹¶è¡Œä½æ•°ä¸º x64 æ—¶æŒ‰åŒå­—å†™å…¥ ç­‰å¾… BSY ä½æ¸…é›¶ã€‚ HALåº“Flashè¯»å†™æ“ä½œå®ç°&emsp;Flashæ“¦é™¤çš„æœ€å°å•ä½ä¸ºæ‰‡åŒºï¼ŒåŒæ—¶å†™å…¥æ•°æ®å‰å¿…é¡»å¯¹æ‰‡åŒºè¿›è¡Œæ“¦é™¤ã€‚å› æ­¤ä¸€æ¬¡Flashçš„å†™å…¥è¿‡ç¨‹ä¸ºï¼šç¡®è®¤å†™å…¥çš„æ‰‡åŒºã€æ“¦é™¤å¯¹åº”æ‰‡åŒºã€å†™å…¥æ•°æ®ã€‚ &emsp;Flashçš„è¯»å–ç›¸å¯¹ç®€å•ï¼Œç›´æ¥åˆ©ç”¨æŒ‡é’ˆè¯»å–å³å¯ã€‚ è·å–å†…å­˜åœ°å€å¯¹åº”æ‰‡åŒº&emsp;STM32F76xæœ€å¤§æ”¯æŒ2MB Flashï¼Œæœ¬ä¾‹ä¸­æ‰€ç”¨çš„STM32767 Flashä¸º1MBï¼Œå³DUAL_BANKæœªè¢«å®šä¹‰ã€‚ Flashæ‰‡åŒºçš„åœ°å€å¯¹åº”å…³ç³»å¦‚ä¸‹æ‰€ç¤ºã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940/* Base address of the Flash sectors */#if defined(DUAL_BANK)#define ADDR_FLASH_SECTOR_0 ((uint32_t)0x08000000) /* Base address of Sector 0, 16 Kbytes */#define ADDR_FLASH_SECTOR_1 ((uint32_t)0x08004000) /* Base address of Sector 1, 16 Kbytes */#define ADDR_FLASH_SECTOR_2 ((uint32_t)0x08008000) /* Base address of Sector 2, 16 Kbytes */#define ADDR_FLASH_SECTOR_3 ((uint32_t)0x0800C000) /* Base address of Sector 3, 16 Kbytes */#define ADDR_FLASH_SECTOR_4 ((uint32_t)0x08010000) /* Base address of Sector 4, 64 Kbytes */#define ADDR_FLASH_SECTOR_5 ((uint32_t)0x08020000) /* Base address of Sector 5, 128 Kbytes */#define ADDR_FLASH_SECTOR_6 ((uint32_t)0x08040000) /* Base address of Sector 6, 128 Kbytes */#define ADDR_FLASH_SECTOR_7 ((uint32_t)0x08060000) /* Base address of Sector 7, 128 Kbytes */#define ADDR_FLASH_SECTOR_8 ((uint32_t)0x08080000) /* Base address of Sector 8, 128 Kbytes */#define ADDR_FLASH_SECTOR_9 ((uint32_t)0x080A0000) /* Base address of Sector 9, 128 Kbytes */#define ADDR_FLASH_SECTOR_10 ((uint32_t)0x080C0000) /* Base address of Sector 10, 128 Kbytes */#define ADDR_FLASH_SECTOR_11 ((uint32_t)0x080E0000) /* Base address of Sector 11, 128 Kbytes */#define ADDR_FLASH_SECTOR_12 ((uint32_t)0x08100000) /* Base address of Sector 12, 16 Kbytes */#define ADDR_FLASH_SECTOR_13 ((uint32_t)0x08104000) /* Base address of Sector 13, 16 Kbytes */#define ADDR_FLASH_SECTOR_14 ((uint32_t)0x08108000) /* Base address of Sector 14, 16 Kbytes */#define ADDR_FLASH_SECTOR_15 ((uint32_t)0x0810C000) /* Base address of Sector 15, 16 Kbytes */#define ADDR_FLASH_SECTOR_16 ((uint32_t)0x08110000) /* Base address of Sector 16, 64 Kbytes */#define ADDR_FLASH_SECTOR_17 ((uint32_t)0x08120000) /* Base address of Sector 17, 128 Kbytes */#define ADDR_FLASH_SECTOR_18 ((uint32_t)0x08140000) /* Base address of Sector 18, 128 Kbytes */#define ADDR_FLASH_SECTOR_19 ((uint32_t)0x08160000) /* Base address of Sector 19, 128 Kbytes */#define ADDR_FLASH_SECTOR_20 ((uint32_t)0x08180000) /* Base address of Sector 20, 128 Kbytes */#define ADDR_FLASH_SECTOR_21 ((uint32_t)0x081A0000) /* Base address of Sector 21, 128 Kbytes */#define ADDR_FLASH_SECTOR_22 ((uint32_t)0x081C0000) /* Base address of Sector 22, 128 Kbytes */#define ADDR_FLASH_SECTOR_23 ((uint32_t)0x081E0000) /* Base address of Sector 23, 128 Kbytes */#else#define ADDR_FLASH_SECTOR_0 ((uint32_t)0x08000000) /* Base address of Sector 0, 32 Kbytes */#define ADDR_FLASH_SECTOR_1 ((uint32_t)0x08008000) /* Base address of Sector 1, 32 Kbytes */#define ADDR_FLASH_SECTOR_2 ((uint32_t)0x08010000) /* Base address of Sector 2, 32 Kbytes */#define ADDR_FLASH_SECTOR_3 ((uint32_t)0x08018000) /* Base address of Sector 3, 32 Kbytes */#define ADDR_FLASH_SECTOR_4 ((uint32_t)0x08020000) /* Base address of Sector 4, 128 Kbytes */#define ADDR_FLASH_SECTOR_5 ((uint32_t)0x08040000) /* Base address of Sector 5, 256 Kbytes */#define ADDR_FLASH_SECTOR_6 ((uint32_t)0x08080000) /* Base address of Sector 6, 256 Kbytes */#define ADDR_FLASH_SECTOR_7 ((uint32_t)0x080C0000) /* Base address of Sector 7, 256 Kbytes */#define ADDR_FLASH_SECTOR_8 ((uint32_t)0x08100000) /* Base address of Sector 8, 256 Kbytes */#define ADDR_FLASH_SECTOR_9 ((uint32_t)0x08140000) /* Base address of Sector 9, 256 Kbytes */#define ADDR_FLASH_SECTOR_10 ((uint32_t)0x08180000) /* Base address of Sector 10, 256 Kbytes */#define ADDR_FLASH_SECTOR_11 ((uint32_t)0x081C0000) /* Base address of Sector 11, 256 Kbytes */#endif /* DUAL_BANK */ &emsp;Flashæ‰‡åŒºå·çš„å®šä¹‰å¦‚ä¸‹æ‰€ç¤ºã€‚å¯¹äºSTM32F767ï¼Œå…¶Flashåªæœ‰7ä¸ªæ‰‡åŒºã€‚ 123456789101112131415161718192021222324252627282930313233/** @defgroup FLASH_Sectors FLASH Sectors * @&#123; */#define FLASH_SECTOR_0 ((uint32_t)0U) /*!&lt; Sector Number 0 */#define FLASH_SECTOR_1 ((uint32_t)1U) /*!&lt; Sector Number 1 */#define FLASH_SECTOR_2 ((uint32_t)2U) /*!&lt; Sector Number 2 */#define FLASH_SECTOR_3 ((uint32_t)3U) /*!&lt; Sector Number 3 */#define FLASH_SECTOR_4 ((uint32_t)4U) /*!&lt; Sector Number 4 */#define FLASH_SECTOR_5 ((uint32_t)5U) /*!&lt; Sector Number 5 */#define FLASH_SECTOR_6 ((uint32_t)6U) /*!&lt; Sector Number 6 */#define FLASH_SECTOR_7 ((uint32_t)7U) /*!&lt; Sector Number 7 *//** @defgroup FLASHEx_Sectors FLASH Sectors * @&#123; */#if (FLASH_SECTOR_TOTAL == 24)#define FLASH_SECTOR_8 ((uint32_t)8U) /*!&lt; Sector Number 8 */#define FLASH_SECTOR_9 ((uint32_t)9U) /*!&lt; Sector Number 9 */#define FLASH_SECTOR_10 ((uint32_t)10U) /*!&lt; Sector Number 10 */#define FLASH_SECTOR_11 ((uint32_t)11U) /*!&lt; Sector Number 11 */#define FLASH_SECTOR_12 ((uint32_t)12U) /*!&lt; Sector Number 12 */#define FLASH_SECTOR_13 ((uint32_t)13U) /*!&lt; Sector Number 13 */#define FLASH_SECTOR_14 ((uint32_t)14U) /*!&lt; Sector Number 14 */#define FLASH_SECTOR_15 ((uint32_t)15U) /*!&lt; Sector Number 15 */#define FLASH_SECTOR_16 ((uint32_t)16U) /*!&lt; Sector Number 16 */#define FLASH_SECTOR_17 ((uint32_t)17U) /*!&lt; Sector Number 17 */#define FLASH_SECTOR_18 ((uint32_t)18U) /*!&lt; Sector Number 18 */#define FLASH_SECTOR_19 ((uint32_t)19U) /*!&lt; Sector Number 19 */#define FLASH_SECTOR_20 ((uint32_t)20U) /*!&lt; Sector Number 20 */#define FLASH_SECTOR_21 ((uint32_t)21U) /*!&lt; Sector Number 21 */#define FLASH_SECTOR_22 ((uint32_t)22U) /*!&lt; Sector Number 22 */#define FLASH_SECTOR_23 ((uint32_t)23U) /*!&lt; Sector Number 23 */#endif /* FLASH_SECTOR_TOTAL == 24 */ &emsp;è·å–Flashå¯¹åº”æ‰‡åŒºçš„å‡½æ•°å¦‚ä¸‹æ‰€ç¤ºã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/** * è¯´æ˜ï¼š è·å–æŒ‡å®šflashåœ°å€æ‰€åœ¨çš„æ‰‡åŒº * å‚æ•°ï¼š Addressï¼šæŒ‡å®šflashåœ°å€ * * @è¿”å›å€¼ å¯¹åº”flashåœ°å€çš„æ‰‡åŒº */uint32_t STMFLASH_GetFlashSector(uint32 Address)&#123; uint32_t sector = 0; if((Address &lt; ADDR_FLASH_SECTOR_1) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_0)) &#123; sector = FLASH_SECTOR_0; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_2) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_1)) &#123; sector = FLASH_SECTOR_1; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_3) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_2)) &#123; sector = FLASH_SECTOR_2; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_4) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_3)) &#123; sector = FLASH_SECTOR_3; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_5) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_4)) &#123; sector = FLASH_SECTOR_4; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_6) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_5)) &#123; sector = FLASH_SECTOR_5; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_7) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_6)) &#123; sector = FLASH_SECTOR_6; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_8) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_7)) &#123; sector = FLASH_SECTOR_7; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_9) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_8)) &#123; sector = FLASH_SECTOR_8; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_10) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_9)) &#123; sector = FLASH_SECTOR_9; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_11) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_10)) &#123; sector = FLASH_SECTOR_10; &#125;#if defined(DUAL_BANK) else if((Address &lt; ADDR_FLASH_SECTOR_12) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_11)) &#123; sector = FLASH_SECTOR_11; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_13) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_12)) &#123; sector = FLASH_SECTOR_12; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_14) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_13)) &#123; sector = FLASH_SECTOR_13; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_15) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_14)) &#123; sector = FLASH_SECTOR_14; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_16) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_15)) &#123; sector = FLASH_SECTOR_15; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_17) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_16)) &#123; sector = FLASH_SECTOR_16; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_18) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_17)) &#123; sector = FLASH_SECTOR_17; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_19) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_18)) &#123; sector = FLASH_SECTOR_18; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_20) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_19)) &#123; sector = FLASH_SECTOR_19; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_21) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_20)) &#123; sector = FLASH_SECTOR_20; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_22) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_21)) &#123; sector = FLASH_SECTOR_21; &#125; else if((Address &lt; ADDR_FLASH_SECTOR_23) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_22)) &#123; sector = FLASH_SECTOR_22; &#125; else /* (Address &lt; FLASH_END_ADDR) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_23) */ &#123; sector = FLASH_SECTOR_23; &#125; #else else /* (Address &lt; FLASH_END_ADDR) &amp;&amp; (Address &gt;= ADDR_FLASH_SECTOR_11) */ &#123; sector = FLASH_SECTOR_11; &#125;#endif /* DUAL_BANK */ return sector;&#125; Flashæ“¦é™¤å‡½æ•°&emsp;Flashæ“¦é™¤å‡½æ•°çš„å®ç°å¦‚ä¸‹æ‰€ç¤ºã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * @brief Perform a mass erase or erase the specified FLASH memory sectors * @param[in] pEraseInit pointer to an FLASH_EraseInitTypeDef structure that * contains the configuration information for the erasing. * * @param[out] SectorError pointer to variable that * contains the configuration information on faulty sector in case of error * (0xFFFFFFFF means that all the sectors have been correctly erased) * * @retval HAL Status */HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *SectorError)&#123; HAL_StatusTypeDef status = HAL_ERROR; uint32_t index = 0; /* Process Locked */ __HAL_LOCK(&amp;pFlash); /* Check the parameters */ assert_param(IS_FLASH_TYPEERASE(pEraseInit-&gt;TypeErase)); /* Wait for last operation to be completed */ status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE); if(status == HAL_OK) &#123; /*Initialization of SectorError variable*/ *SectorError = 0xFFFFFFFFU; if(pEraseInit-&gt;TypeErase == FLASH_TYPEERASE_MASSERASE) &#123; /*Mass erase to be done*/#if defined (FLASH_OPTCR_nDBANK) FLASH_MassErase((uint8_t) pEraseInit-&gt;VoltageRange, pEraseInit-&gt;Banks);#else FLASH_MassErase((uint8_t) pEraseInit-&gt;VoltageRange); #endif /* FLASH_OPTCR_nDBANK */ /* Wait for last operation to be completed */ status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE); /* if the erase operation is completed, disable the MER Bit */ FLASH-&gt;CR &amp;= (~FLASH_MER_BIT); &#125; else &#123; /* Check the parameters */ assert_param(IS_FLASH_NBSECTORS(pEraseInit-&gt;NbSectors + pEraseInit-&gt;Sector)); /* Erase by sector by sector to be done*/ for(index = pEraseInit-&gt;Sector; index &lt; (pEraseInit-&gt;NbSectors + pEraseInit-&gt;Sector); index++) &#123; FLASH_Erase_Sector(index, (uint8_t) pEraseInit-&gt;VoltageRange); /* Wait for last operation to be completed */ status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE); /* If the erase operation is completed, disable the SER Bit and SNB Bits */ CLEAR_BIT(FLASH-&gt;CR, (FLASH_CR_SER | FLASH_CR_SNB)); if(status != HAL_OK) &#123; /* In case of error, stop erase procedure and return the faulty sector*/ *SectorError = index; break; &#125; &#125; &#125; &#125; /* Process Unlocked */ __HAL_UNLOCK(&amp;pFlash); return status;&#125; FLASH_WaitForLastOperation()å‡½æ•°&emsp;FLASH_WaitForLastOperation()å‡½æ•°ç”¨äºç­‰å¾…Flashæ“ä½œå®Œæˆã€‚ &emsp;è¯¥å‡½æ•°é¦–å…ˆå¯¹FlashçŠ¶æ€è¿›è¡Œè¯»å–ï¼Œç­‰å¾…Flashæ“ä½œå®Œæˆã€‚è¯»å–å¯„å­˜å™¨FLASH_SRçš„BSYä½ï¼Œç›´åˆ°ç¡®è®¤å½“å‰æœªæ‰§è¡Œä»»ä½•Flashæ“ä½œï¼›è¯»å–å¯„å­˜å™¨FLASH_SRçš„æ‰€æœ‰é”™è¯¯ä½ï¼Œåˆ¤æ–­æœ‰æ— é”™è¯¯ï¼›è¯»å–å¯„å­˜å™¨FLASH_SRçš„EOPä½ï¼Œç¡®è®¤å®Œæˆå½“å‰Flashæ“ä½œã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);/** * @brief Wait for a FLASH operation to complete. * @param Timeout maximum flash operationtimeout * @retval HAL Status */HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)&#123; uint32_t tickstart = 0; /* Clear Error Code */ pFlash.ErrorCode = HAL_FLASH_ERROR_NONE; /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset. Even if the FLASH operation fails, the BUSY flag will be reset and an error flag will be set */ /* Get tick */ tickstart = HAL_GetTick(); while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) &#123; if(Timeout != HAL_MAX_DELAY) &#123; if((Timeout == 0)||((HAL_GetTick() - tickstart ) &gt; Timeout)) &#123; return HAL_TIMEOUT; &#125; &#125; &#125; if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_ALL_ERRORS) != RESET) &#123; /*Save the error code*/ FLASH_SetErrorCode(); return HAL_ERROR; &#125; /* Check FLASH End of Operation flag */ if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET) &#123; /* Clear FLASH End of Operation pending bit */ __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP); &#125; /* If there is an error flag set */ return HAL_OK; &#125; #define __HAL_FLASH_GET_FLAG(__FLAG__) ((FLASH-&gt;SR &amp; (__FLAG__))) FLASH_MassErase()å‡½æ•°&emsp;FLASH_MassErase()å‡½æ•°ç”¨äºæ“¦é™¤Flashå…¨éƒ¨æ‰‡åŒºï¼Œå³æŒ‰ç…§bankè¿›è¡Œæ“¦é™¤ã€‚é¦–å…ˆé€šè¿‡å¯„å­˜å™¨FLASH_CRçš„MERä½é€‰æ‹©éœ€è¦æ‰¹é‡æ“¦é™¤çš„bankã€‚STM32F767ä»…æœ‰ä¸€ä¸ªbankï¼Œæ•…æ­¤å¤„åªèƒ½é€‰æ‹©bank1ã€‚ä¹‹åå‘FLASH_CRå¯„å­˜å™¨PSIZEä½å†™å…¥ç¼–ç¨‹å¤§å°å€¼ï¼Œå‘STRTä½å†™å…¥1å¯åŠ¨æ“¦é™¤æ“ä½œã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#if defined (FLASH_OPTCR_nDBANK)/** * @brief Full erase of FLASH memory sectors * @param VoltageRange The device voltage range which defines the erase parallelism. * This parameter can be one of the following values: * @arg VOLTAGE_RANGE_1: when the device voltage range is 1.8V to 2.1V, * the operation will be done by byte (8-bit) * @arg VOLTAGE_RANGE_2: when the device voltage range is 2.1V to 2.7V, * the operation will be done by half word (16-bit) * @arg VOLTAGE_RANGE_3: when the device voltage range is 2.7V to 3.6V, * the operation will be done by word (32-bit) * @arg VOLTAGE_RANGE_4: when the device voltage range is 2.7V to 3.6V + External Vpp, * the operation will be done by double word (64-bit) * @param Banks Banks to be erased * This parameter can be one of the following values: * @arg FLASH_BANK_1: Bank1 to be erased * @arg FLASH_BANK_2: Bank2 to be erased * @arg FLASH_BANK_BOTH: Bank1 and Bank2 to be erased * * @retval HAL Status */static void FLASH_MassErase(uint8_t VoltageRange, uint32_t Banks)&#123; /* Check the parameters */ assert_param(IS_VOLTAGERANGE(VoltageRange)); assert_param(IS_FLASH_BANK(Banks)); /* if the previous operation is completed, proceed to erase all sectors */ FLASH-&gt;CR &amp;= CR_PSIZE_MASK; if(Banks == FLASH_BANK_BOTH) &#123; /* bank1 &amp; bank2 will be erased*/ FLASH-&gt;CR |= FLASH_MER_BIT; &#125; else if(Banks == FLASH_BANK_2) &#123; /*Only bank2 will be erased*/ FLASH-&gt;CR |= FLASH_CR_MER2; &#125; else &#123; /*Only bank1 will be erased*/ FLASH-&gt;CR |= FLASH_CR_MER1; &#125; FLASH-&gt;CR |= FLASH_CR_STRT | ((uint32_t)VoltageRange &lt;&lt;8); /* Data synchronous Barrier (DSB) Just after the write operation This will force the CPU to respect the sequence of instruction (no optimization).*/ __DSB();&#125; FLASH_Erase_Sector()å‡½æ•°&emsp;FLASH_Erase_Sector()å‡½æ•°ç”¨äºæ“¦é™¤ç‰¹å®šçš„Flashæ‰‡åŒºã€‚ å‘FLASH_CRå¯„å­˜å™¨PSIZEä½å†™å…¥ç¼–ç¨‹å¤§å°å€¼ï¼› å‘FLASH_CRå¯„å­˜å™¨SNBä½å†™å…¥å¾…æ“¦é™¤çš„æ‰‡åŒºç¼–å·ï¼›å‘SERä½å†™å…¥1ä½¿èƒ½æ‰‡åŒºæ“¦é™¤æ¨¡å¼ï¼› å‘FLASH_CRå¯„å­˜å™¨STRTä½å†™å…¥1å¯åŠ¨æ“¦é™¤æ“ä½œï¼› æ‰§è¡Œ__DSB()æŒ‡ä»¤ï¼šData synchronous Barrierï¼Œå³æ•°æ®åŒæ­¥å±éšœã€‚åªæœ‰å½“æ­¤æŒ‡ä»¤æ‰§è¡Œå®Œæ¯•åï¼Œæ‰ä¼šæ‰§è¡Œç¨‹åºä¸­ä½äºæ­¤æŒ‡ä»¤åçš„æŒ‡ä»¤ã€‚ A Data Synchronization Barrier (DSB) completes when all instructions before this instruction complete. A Data Memory Barrier (DMB) ensures that all explicit memory accesses before the DMB instruction complete before any explicit memory accesses after the DMB instruction start. An Instruction Synchronization Barrier (ISB) flushes the pipeline in the processor, so that all instructions following the ISB are fetched from cache or memory, after the ISB has been completed. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * @brief Erase the specified FLASH memory sector * @param Sector FLASH sector to erase * The value of this parameter depend on device used within the same series * @param VoltageRange The device voltage range which defines the erase parallelism. * This parameter can be one of the following values: * @arg FLASH_VOLTAGE_RANGE_1: when the device voltage range is 1.8V to 2.1V, * the operation will be done by byte (8-bit) * @arg FLASH_VOLTAGE_RANGE_2: when the device voltage range is 2.1V to 2.7V, * the operation will be done by half word (16-bit) * @arg FLASH_VOLTAGE_RANGE_3: when the device voltage range is 2.7V to 3.6V, * the operation will be done by word (32-bit) * @arg FLASH_VOLTAGE_RANGE_4: when the device voltage range is 2.7V to 3.6V + External Vpp, * the operation will be done by double word (64-bit) * * @retval None */void FLASH_Erase_Sector(uint32_t Sector, uint8_t VoltageRange)&#123; uint32_t tmp_psize = 0; /* Check the parameters */ assert_param(IS_FLASH_SECTOR(Sector)); assert_param(IS_VOLTAGERANGE(VoltageRange)); if(VoltageRange == FLASH_VOLTAGE_RANGE_1) &#123; tmp_psize = FLASH_PSIZE_BYTE; &#125; else if(VoltageRange == FLASH_VOLTAGE_RANGE_2) &#123; tmp_psize = FLASH_PSIZE_HALF_WORD; &#125; else if(VoltageRange == FLASH_VOLTAGE_RANGE_3) &#123; tmp_psize = FLASH_PSIZE_WORD; &#125; else &#123; tmp_psize = FLASH_PSIZE_DOUBLE_WORD; &#125; /* Need to add offset of 4 when sector higher than FLASH_SECTOR_11 */ if(Sector &gt; FLASH_SECTOR_11) &#123; Sector += 4; &#125; /* If the previous operation is completed, proceed to erase the sector */ FLASH-&gt;CR &amp;= CR_PSIZE_MASK; FLASH-&gt;CR |= tmp_psize; CLEAR_BIT(FLASH-&gt;CR, FLASH_CR_SNB); FLASH-&gt;CR |= FLASH_CR_SER | (Sector &lt;&lt; FLASH_CR_SNB_Pos); FLASH-&gt;CR |= FLASH_CR_STRT; /* Data synchronous Barrier (DSB) Just after the write operation This will force the CPU to respect the sequence of instruction (no optimization).*/ __DSB();&#125; HAL_FLASHEx_Erase()å‡½æ•°&emsp;HAL_FLASHEx_Erase()å‡½æ•°ä¸ºå¯¹Flashè¿›è¡Œbankæ“¦é™¤æˆ–è€…å¤šä¸ªåŒºå—æ“¦é™¤çš„å‡½æ•°ï¼Œå…¶å®ç°åˆ©ç”¨äº†FLASH_MassErase()å‡½æ•°ä¸FLASH_Erase_Sector()å‡½æ•°ã€‚å…¶å®ç°éå¸¸ç®€å•ï¼Œè¿™é‡Œä¸å†è¯´æ˜ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * @brief Perform a mass erase or erase the specified FLASH memory sectors * @param[in] pEraseInit pointer to an FLASH_EraseInitTypeDef structure that * contains the configuration information for the erasing. * * @param[out] SectorError pointer to variable that * contains the configuration information on faulty sector in case of error * (0xFFFFFFFF means that all the sectors have been correctly erased) * * @retval HAL Status */HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *SectorError)&#123; HAL_StatusTypeDef status = HAL_ERROR; uint32_t index = 0; /* Process Locked */ __HAL_LOCK(&amp;pFlash); /* Check the parameters */ assert_param(IS_FLASH_TYPEERASE(pEraseInit-&gt;TypeErase)); /* Wait for last operation to be completed */ status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE); if(status == HAL_OK) &#123; /*Initialization of SectorError variable*/ *SectorError = 0xFFFFFFFFU; if(pEraseInit-&gt;TypeErase == FLASH_TYPEERASE_MASSERASE) &#123; /*Mass erase to be done*/#if defined (FLASH_OPTCR_nDBANK) FLASH_MassErase((uint8_t) pEraseInit-&gt;VoltageRange, pEraseInit-&gt;Banks);#else FLASH_MassErase((uint8_t) pEraseInit-&gt;VoltageRange); #endif /* FLASH_OPTCR_nDBANK */ /* Wait for last operation to be completed */ status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE); /* if the erase operation is completed, disable the MER Bit */ FLASH-&gt;CR &amp;= (~FLASH_MER_BIT); &#125; else &#123; /* Check the parameters */ assert_param(IS_FLASH_NBSECTORS(pEraseInit-&gt;NbSectors + pEraseInit-&gt;Sector)); /* Erase by sector by sector to be done*/ for(index = pEraseInit-&gt;Sector; index &lt; (pEraseInit-&gt;NbSectors + pEraseInit-&gt;Sector); index++) &#123; FLASH_Erase_Sector(index, (uint8_t) pEraseInit-&gt;VoltageRange); /* Wait for last operation to be completed */ status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE); /* If the erase operation is completed, disable the SER Bit and SNB Bits */ CLEAR_BIT(FLASH-&gt;CR, (FLASH_CR_SER | FLASH_CR_SNB)); if(status != HAL_OK) &#123; /* In case of error, stop erase procedure and return the faulty sector*/ *SectorError = index; break; &#125; &#125; &#125; &#125; /* Process Unlocked */ __HAL_UNLOCK(&amp;pFlash); return status;&#125; Flashç¼–ç¨‹å‡½æ•°&emsp;Flashç¼–ç¨‹å‡½æ•°çš„å®ç°å¦‚ä¸‹æ‰€ç¤ºã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * @brief Program byte, halfword, word or double word at a specified address * @param TypeProgram Indicate the way to program at a specified address. * This parameter can be a value of @ref FLASH_Type_Program * @param Address specifies the address to be programmed. * @param Data specifies the data to be programmed * * @retval HAL_StatusTypeDef HAL Status */HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)&#123; HAL_StatusTypeDef status = HAL_ERROR; /* Process Locked */ __HAL_LOCK(&amp;pFlash); /* Check the parameters */ assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram)); /* Wait for last operation to be completed */ status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE); if(status == HAL_OK) &#123; switch(TypeProgram) &#123; case FLASH_TYPEPROGRAM_BYTE : &#123; /*Program byte (8-bit) at a specified address.*/ FLASH_Program_Byte(Address, (uint8_t) Data); break; &#125; case FLASH_TYPEPROGRAM_HALFWORD : &#123; /*Program halfword (16-bit) at a specified address.*/ FLASH_Program_HalfWord(Address, (uint16_t) Data); break; &#125; case FLASH_TYPEPROGRAM_WORD : &#123; /*Program word (32-bit) at a specified address.*/ FLASH_Program_Word(Address, (uint32_t) Data); break; &#125; case FLASH_TYPEPROGRAM_DOUBLEWORD : &#123; /*Program double word (64-bit) at a specified address.*/ FLASH_Program_DoubleWord(Address, Data); break; &#125; default : break; &#125; /* Wait for last operation to be completed */ status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE); /* If the program operation is completed, disable the PG Bit */ FLASH-&gt;CR &amp;= (~FLASH_CR_PG); &#125; /* Process Unlocked */ __HAL_UNLOCK(&amp;pFlash); return status;&#125; FLASH_Program_Byte()å‡½æ•°&emsp;FLASH_Program_Byte()å‡½æ•°ç”¨äºå‘ç‰¹å®šåœ°å€å†™å…¥byteæ•°æ®ã€‚å…·ä½“åŠŸèƒ½å¦‚ä¸‹ï¼š å‘FLASH_CRå¯„å­˜å™¨PSIZEä½å†™å…¥ç¼–ç¨‹å¤§å°å€¼ï¼šbyteï¼› å‘FLASH_CRå¯„å­˜å™¨PGä½å†™å…¥1ï¼Œæ¿€æ´»Flashç¼–ç¨‹ï¼› å‘Flashå¯¹åº”åœ°å€å†™å…¥æ•°å€¼ï¼Œæ³¨æ„æŒ‡é’ˆç±»å‹çš„å˜æ¢ï¼› é€šè¿‡DSBä¿éšœæ•°æ®åŒæ­¥ã€‚ 12345678910111213141516171819202122232425262728/** * @brief Program byte (8-bit) at a specified address. * @note This function must be used when the device voltage range is from * 2.7V to 3.6V. * * @note If an erase and a program operations are requested simultaneously, * the erase operation is performed before the program one. * * @param Address specifies the address to be programmed. * @param Data specifies the data to be programmed. * @retval None */static void FLASH_Program_Byte(uint32_t Address, uint8_t Data)&#123; /* Check the parameters */ assert_param(IS_FLASH_ADDRESS(Address)); /* If the previous operation is completed, proceed to program the new data */ FLASH-&gt;CR &amp;= CR_PSIZE_MASK; FLASH-&gt;CR |= FLASH_PSIZE_BYTE; FLASH-&gt;CR |= FLASH_CR_PG; *(__IO uint8_t*)Address = Data; /* Data synchronous Barrier (DSB) Just after the write operation This will force the CPU to respect the sequence of instruction (no optimization).*/ __DSB();&#125; &emsp;FLASH_Program_HalfWord()ã€FLASH_Program_Word()ã€FLASH_Program_DoubleWord()å‡½æ•°å®ç°ä¸æ­¤ç±»ä¼¼ï¼Œä¸å†è¿›è¡Œä»‹ç»ã€‚ å½“è¯¥å‡½æ•°æ‰§è¡Œå®Œæ¯•åï¼Œéœ€è¦å°†FLASH_CRå¯„å­˜å™¨PGä½å¤ä½ï¼Œå…³é—­Flashç¼–ç¨‹ã€‚ åŸºäºHALåº“çš„Flashè¯»å†™å‡½æ•°å®ç°Flashå†™å…¥å‡½æ•°&emsp;Flashå†™å…¥å‡½æ•°çš„å®ç°å¦‚ä¸‹æ‰€ç¤ºã€‚è¯¥å‡½æ•°é€»è¾‘ç®€æ˜ï¼Œè¿™é‡Œä¸å†è¯´æ˜ã€‚ä½¿ç”¨æ—¶è¯·åŠ¡å¿…æ³¨æ„å¾…å†™å…¥flashçš„åœ°å€ï¼Œæœ¬ä¾‹ä¸­é‡‡ç”¨å­—å†™å…¥æ–¹å¼ï¼Œæ•…å†™å…¥åœ°å€å¿…é¡»ä¸º4çš„å€æ•°ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * è¯´æ˜ï¼š å‘æŒ‡å®šflashåŒºåŸŸå†™å…¥æ•°æ® * @å‚æ•° WriteAddrï¼šå¾…å†™å…¥flashçš„åœ°å€ï¼Œæœ¬ä¾‹ä¸­é‡‡ç”¨å­—å†™å…¥æ–¹å¼ï¼Œæ•…å†™å…¥åœ°å€å¿…é¡»ä¸º4çš„å€æ•°ï¼› * @å‚æ•° pBufferï¼šæŒ‡å‘å¾…å†™å…¥æ•°æ®çš„æŒ‡é’ˆï¼ŒæŒ‰ç…§å­—å†™å…¥æ–¹å¼ï¼Œæ‰€ä»¥ç±»å‹ä¸ºuint32ï¼› * @å‚æ•° NumToWriteï¼šå¾…å†™å…¥æ•°æ®ä¸ªæ•°ã€‚ * * @è¿”å›å€¼ HAL Status */HAL_StatusTypeDef STMFLASH_Write(uint32 WriteAddr,uint32 *pBuffer,uint32 NumToWrite) &#123; FLASH_EraseInitTypeDef EraseInitStruct; HAL_StatusTypeDef status = HAL_ERROR; uint32 SECTORError = 0; uint32_t FirstSector = 0, NbOfSectors = 0; uint32 addrStart = WriteAddr; /* flashå†™å…¥çš„èµ·å§‹åœ°å€ */ uint32 addrEnd = WriteAddr + NumToWrite * 4 - 1; /* flashå†™å…¥çš„ç»“æŸåœ°å€ */ /* æ£€æµ‹flashåœ°å€æ˜¯å¦åˆæ³• */ assert_param(IS_FLASH_ADDRESS(addrStart)); assert_param(IS_FLASH_ADDRESS(addrEnd)); /* å¦‚æœå†™å…¥æ•°æ®é‡ä¸º0ï¼Œåˆ™è¿”å›é”™è¯¯ */ if (NumToWrite == 0) return status; /* è§£é”flash */ HAL_FLASH_Unlock(); /* è·å–è¦æ“¦é™¤çš„é¦–ä¸ªæ‰‡åŒº */ FirstSector = STMFLASH_GetFlashSector(addrStart); /* è·å–è¦æ“¦é™¤çš„æ‰‡åŒºä¸ªæ•° */ NbOfSectors = STMFLASH_GetFlashSector(addrEnd) - FirstSector + 1; /* è®¾ç½®EraseInitStructç»“æ„ä½“ä¿¡æ¯ */ EraseInitStruct.TypeErase = FLASH_TYPEERASE_SECTORS; /* æ‰‡åŒºæ“¦é™¤ */ EraseInitStruct.VoltageRange = FLASH_VOLTAGE_RANGE_3; /* ç”µå‹åœ¨2.7-3.6Vä¹‹é—´ï¼Œå®é™…ä¸º3.3V */ EraseInitStruct.Sector = FirstSector; EraseInitStruct.NbSectors = NbOfSectors; /* æ“¦é™¤ç›¸åº”çš„flashæ‰‡åŒº */ status = HAL_FLASHEx_Erase(&amp;EraseInitStruct, &amp;SECTORError); if (status != HAL_OK) return status; status = FLASH_WaitForLastOperation(FLASH_WAITETIME); /* ç­‰å¾…flashæ“ä½œå®Œæˆ */ if(status == HAL_OK) &#123; while(addrStart &lt;= addrEnd)//å†™æ•°æ® &#123; /* å‘flashå†™å…¥æ•°æ® */ status = HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD,addrStart,*pBuffer); if(status != HAL_OK) return status; addrStart += 4; pBuffer++; &#125; &#125; /* é”å®šflash */ HAL_FLASH_Lock(); return status;&#125; Flashè¯»å–å‡½æ•°&emsp;Flashè¯»å–å‡½æ•°çš„å®ç°å¦‚ä¸‹æ‰€ç¤ºã€‚è¯¥å‡½æ•°é€»è¾‘ç®€æ˜ï¼Œè¿™é‡Œä¸å†è¯´æ˜ã€‚ä½¿ç”¨æ—¶è¯·åŠ¡å¿…æ³¨æ„å¾…è¯»å–å…¥flashçš„åœ°å€ï¼Œæœ¬ä¾‹ä¸­é‡‡ç”¨å­—è¯»å–æ–¹å¼ï¼Œæ•…è¯»å–åœ°å€å¿…é¡»ä¸º4çš„å€æ•°ã€‚ 123456789101112131415161718192021222324252627/** * è¯´æ˜ï¼š ä»æŒ‡å®šflashåŒºåŸŸè¯»å–ä¸€ä¸ªå­— * * @è¿”å›å€¼ å¯¹åº”flashåŒºåŸŸçš„æ•°æ® */uint32 STMFLASH_ReadWord(uint32 Address)&#123; return *(__IO uint32_t *)Address; &#125;/** * è¯´æ˜ï¼š ä»æŒ‡å®šflashåŒºåŸŸè¯»å–æ•°æ® * @å‚æ•° ReadAddrï¼šå¾…è¯»å–flashçš„åœ°å€ï¼Œæœ¬ä¾‹ä¸­é‡‡ç”¨å­—è¯»å–æ–¹å¼ï¼Œæ•…è¯»å–åœ°å€å¿…é¡»ä¸º4çš„å€æ•°ï¼› * @å‚æ•° pBufferï¼šæŒ‡å‘å­˜å‚¨è¯»å–æ•°æ®æ•°ç»„çš„æŒ‡é’ˆï¼ŒæŒ‰ç…§å­—è¯»å–æ–¹å¼ï¼Œæ‰€ä»¥ç±»å‹ä¸ºuint32ï¼› * @å‚æ•° NumToReadï¼šå¾…è¯»å–æ•°æ®ä¸ªæ•°ã€‚ * * @è¿”å›å€¼ æ—  */void STMFLASH_Read(uint32 ReadAddr,uint32 *pBuffer,uint32 NumToRead) &#123; uint32 i; for(i = 0;i &lt; NumToRead;i++) &#123; pBuffer[i] = STMFLASH_ReadWord(ReadAddr); /* è¯»å–ä¸€ä¸ªå­— */ ReadAddr += 4; &#125;&#125; å®éªŒéªŒè¯&emsp;éªŒè¯ç¨‹åºç‰‡æ®µå¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243uint32 mainloop = 0;#define FLASH_SAVE_ADDR ADDR_FLASH_SECTOR_7 - 8uint8 writeBuffer[200];uint8 readBuffer[200];#define TEXT_LENTH sizeof(writeBuffer) //æ•°ç»„é•¿åº¦ #define SIZE TEXT_LENTH/4+((TEXT_LENTH%4)?1:0)int16 test = 0;uint16 screenShow = 0;/* åˆå§‹åŒ–éƒ¨åˆ†çœç•¥ */ while (1) &#123; mainloop++; oled_putuint32(0, 2, mainloop); SYS_Delay_US(1000000); for (test = 0; test &lt; 200; test++) &#123; writeBuffer[test] = test + mainloop%50; &#125; screenShow += STMFLASH_Write(FLASH_SAVE_ADDR,(uint32*)writeBuffer,SIZE); STMFLASH_Read(FLASH_SAVE_ADDR,(uint32*)readBuffer,SIZE); HAL_UART_Transmit(&amp;huart1,readBuffer,200,1000); for (test = 0; test &lt; 200; test++) &#123; if (writeBuffer[test] != readBuffer[test]) screenShow++; &#125; oled_putuint32(0, 5, screenShow); &#125; &emsp;ç¨‹åºåŠŸèƒ½å¦‚ä¸‹ï¼š å†™å…¥åœ°å€ä¸ºæ‰‡åŒº7é¦–åœ°å€å‡å»8ï¼Œå®é™…ä¸ºæ‰‡åŒº6é è¿‘æœ«ç«¯ï¼Œåˆ™æ“¦é™¤ã€è¯»å–å‡è¿›è¡Œè·¨æ‰‡åŒºæ“ä½œï¼› å‘è¯¥åœ°å€flashå†™å…¥200å­—èŠ‚æ•°æ®å¹¶è¯»å–æ¯”å¯¹ï¼Œç¡®è®¤æœ‰æ— è¯»å†™é”™è¯¯ï¼› ç»éªŒè¯è¯»å†™å‡æ­£å¸¸ï¼Œå®éªŒå®Œæˆã€‚","categories":[{"name":"åµŒå…¥å¼","slug":"åµŒå…¥å¼","permalink":"http://jiaodi.tech/categories/åµŒå…¥å¼/"}],"tags":[{"name":"STM32F7","slug":"STM32F7","permalink":"http://jiaodi.tech/tags/STM32F7/"},{"name":"Flash","slug":"Flash","permalink":"http://jiaodi.tech/tags/Flash/"}]},{"title":"STM32F767 RTCçš„åŸºæœ¬ç”¨æ³•","slug":"stm32f767-rtc","date":"2018-05-21T15:12:27.000Z","updated":"2018-06-02T03:08:11.210Z","comments":true,"path":"2018/05/21/stm32f767-rtc/","link":"","permalink":"http://jiaodi.tech/2018/05/21/stm32f767-rtc/","excerpt":"&emsp;æœ¬æ–‡ä»‹ç»STM32F767 RTC(Real-time clock)çš„åŸºæœ¬ç”¨æ³•ã€‚","text":"&emsp;æœ¬æ–‡ä»‹ç»STM32F767 RTC(Real-time clock)çš„åŸºæœ¬ç”¨æ³•ã€‚ å¼€å‘ç¯å¢ƒç¡¬ä»¶ç¯å¢ƒ ç”µè„‘ï¼šWindows 10 Home x64 Apollo STM32F767å¼€å‘æ¿(ST-LINK V2ä»¿çœŸå™¨) è½¯ä»¶ç¯å¢ƒ Keil Version 5.24.1 (Pack Installerï¼šKeil.STM32F7xx_DFP.2.9.0.pack) STM32CubeMX Version 4.25.0(Packages Managerï¼šSTM32CubeF7) RTCåŠŸèƒ½ä»‹ç»RTCä¸»è¦ç‰¹æ€§ åŒ…å«äºšç§’ã€ç§’ã€åˆ†é’Ÿã€å°æ—¶ï¼ˆ12/24 å°æ—¶åˆ¶ï¼‰ã€æ˜ŸæœŸå‡ ã€æ—¥æœŸã€æœˆä»½å’Œå¹´ä»½çš„æ—¥å†ï¼› è½¯ä»¶å¯ç¼–ç¨‹çš„å¤ä»¤æ—¶è¡¥å¿ï¼› å…·æœ‰ä¸­æ–­åŠŸèƒ½çš„å¯ç¼–ç¨‹é—¹é’Ÿã€‚å¯é€šè¿‡ä»»æ„æ—¥å†å­—æ®µçš„ç»„åˆè§¦å‘é—¹é’Ÿï¼› è‡ªåŠ¨å”¤é†’å•å…ƒï¼Œå¯å‘¨æœŸæ€§åœ°ç”Ÿæˆæ ‡å¿—ä»¥è§¦å‘è‡ªåŠ¨å”¤é†’ä¸­æ–­ï¼› å‚è€ƒæ—¶é’Ÿæ£€æµ‹ï¼šå¯ä½¿ç”¨æ›´åŠ ç²¾ç¡®çš„ç¬¬äºŒæ—¶é’Ÿæºï¼ˆ50 Hz æˆ– 60 Hzï¼‰æ¥æé«˜æ—¥å†çš„ç²¾ç¡®åº¦ï¼› åˆ©ç”¨äºšç§’çº§ç§»ä½ç‰¹æ€§ä¸å¤–éƒ¨æ—¶é’Ÿå®ç°ç²¾ç¡®åŒæ­¥ï¼› æ•°å­—æ ¡å‡†ç”µè·¯ï¼ˆå‘¨æœŸæ€§è®¡æ•°å™¨è°ƒæ•´ï¼‰ï¼šç²¾åº¦ä¸º 0.95 ppmï¼Œåœ¨æ•°ç§’é’Ÿçš„æ ¡å‡†çª—å£ä¸­è·å¾—ï¼› ç”¨äºäº‹ä»¶ä¿å­˜çš„æ—¶é—´æˆ³åŠŸèƒ½ï¼› å¸¦å¯é…ç½®è¿‡æ»¤å™¨å’Œå†…éƒ¨ä¸Šæ‹‰çš„å…¥ä¾µæ£€æµ‹äº‹ä»¶ï¼› å¯å±è”½ä¸­æ–­/äº‹ä»¶ï¼šé—¹é’ŸAã€é—¹é’ŸBã€å”¤é†’ä¸­æ–­ã€æ—¶é—´æˆ³ã€å…¥ä¾µæ£€æµ‹ 32å¤‡ä»½å¯„å­˜å™¨ã€‚ RTCç³»ç»Ÿæ¡†å›¾ &emsp;æœ¬ä¾‹ä¸­ä»…ä½¿ç”¨RTCçš„åŸºæœ¬åŠŸèƒ½ï¼šè®¾ç½®RTCäº‹ä»¶åè¿›è¡Œè¯»å–æ“ä½œï¼Œæ•…ä¸å†å¯¹æ¡†å›¾è¿›è¡Œè¯´æ˜ã€‚ RTCçš„åŸºæœ¬ç”¨æ³•RTCæ—¶é’Ÿè®¾ç½®&emsp;æœ¬ä¾‹ä¸­ï¼Œä½¿ç”¨å¤–éƒ¨ä½é€Ÿæ—¶é’ŸLSEä½œä¸ºæ—¶é’Ÿæºï¼Œå…¶é¢‘ç‡ä¸º32.768kHzã€‚ &emsp;RTCçš„æ—¶é’Ÿè®¾ç½®å‡½æ•°å¦‚ä¸‹æ‰€ç¤ºã€‚ 12345678910111213141516171819202122232425262728293031323334/** * @brief RTC Clock Configuration * @retval None */void RTC_Clock_Config(void)&#123; RCC_OscInitTypeDef RCC_OscInitStruct; RCC_PeriphCLKInitTypeDef PeriphClkInitStruct; /**Configure the main internal regulator output voltage */ __HAL_RCC_PWR_CLK_ENABLE(); __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1); /**åˆå§‹åŒ–LSEæ—¶é’Ÿï¼š32.768kHz */ RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE; /* LSEé…ç½® */ RCC_OscInitStruct.LSEState = RCC_LSE_ON; /* LSEä½¿èƒ½ */ RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE; /* LSEæ— PLL */ if (HAL_RCC_OscConfig(&amp;RCC_OscInitStruct) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC; /* å¤–è®¾ä¸ºRTC */ PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE; /* RTCæ—¶é’Ÿæºä¸ºLSE */ if (HAL_RCCEx_PeriphCLKConfig(&amp;PeriphClkInitStruct) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125;&#125; &emsp;RTCæ—¶é’Ÿåˆå§‹åŒ–å‡½æ•°çš„ä¸»è¦åŠŸèƒ½å¦‚ä¸‹ï¼š ä½¿èƒ½å¤–éƒ¨LSEæ—¶é’Ÿï¼ŒLSEæ— PLLåŠŸèƒ½ï¼› è®¾ç½®RTCçš„æ—¶é’Ÿæºä¸ºLSEã€‚ RTCåˆå§‹åŒ–å‡½æ•°&emsp;RTCåˆå§‹åŒ–å‡½æ•°å¦‚ä¸‹æ‰€ç¤ºã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051RTC_HandleTypeDef hrtc;#define RTC_BKP_Mask 0x5051/* RTC init function */void MX_RTC_Init(void)&#123; RTC_TimeTypeDef sTime; RTC_DateTypeDef sDate; /**Initialize RTC Only */ hrtc.Instance = RTC;if(HAL_RTCEx_BKUPRead(&amp;hrtc, RTC_BKP_DR0) != RTC_BKP_Mask)&#123; hrtc.Init.HourFormat = RTC_HOURFORMAT_24; /* 24å°æ—¶åˆ¶ */ hrtc.Init.AsynchPrediv = 127; hrtc.Init.SynchPrediv = 255; /* åˆ†é¢‘ç³»æ•° = 128 * 256 = 32768 */ hrtc.Init.OutPut = RTC_OUTPUT_DISABLE; /* ç¦ç”¨RTC outputè¾“å‡º */ hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH; hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN; if (HAL_RTC_Init(&amp;hrtc) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; /**åˆå§‹åŒ–RTCæ—¶é—´ä¸æ—¥æœŸ */ sTime.Hours = 23; sTime.Minutes = 8; sTime.Seconds = 50; sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE; /* å…³é—­å¤ä»¤æ—¶ */ sTime.StoreOperation = RTC_STOREOPERATION_RESET; if (HAL_RTC_SetTime(&amp;hrtc, &amp;sTime, RTC_FORMAT_BIN) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; sDate.WeekDay = RTC_WEEKDAY_WEDNESDAY; sDate.Month = RTC_MONTH_MAY; sDate.Date = 30; sDate.Year = 18; if (HAL_RTC_SetDate(&amp;hrtc, &amp;sDate, RTC_FORMAT_BIN) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; HAL_RTCEx_BKUPWrite(&amp;hrtc,RTC_BKP_DR0,RTC_BKP_Mask); &#125;&#125; &emsp;åˆå§‹åŒ–å‡½æ•°çš„åŠŸèƒ½å¦‚ä¸‹ï¼š è®¾ç½®RTCä¸º24å°æ—¶åˆ¶ï¼› è®¾ç½®RTCåˆ†é¢‘ç³»æ•°ï¼Œ32.768kHzæ—¶é’Ÿåˆ†é¢‘åä¸º1Hzï¼› åˆå§‹åŒ–RTCï¼› è®¾ç½®RTCæ—¶åˆ†ç§’ï¼Œå…³é—­å¤ä»¤æ—¶ï¼› è®¾ç½®RTCå¹´æœˆæ—¥æ˜ŸæœŸï¼› åˆå§‹åŒ–RTCæ—¶é—´ä¸æ—¥æœŸã€‚ HAL_RTC_Init()å‡½æ•°å®ç°&emsp;HAL_RTC_Init()å‡½æ•°ç”¨äºåˆå§‹åŒ–RTCï¼Œå…¶å®ç°å¦‚ä¸‹ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * @brief Initializes the RTC peripheral * @param hrtc pointer to a RTC_HandleTypeDef structure that contains * the configuration information for RTC. * @retval HAL status */HAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc)&#123; /* Check the RTC peripheral state */ if(hrtc == NULL) &#123; return HAL_ERROR; &#125; /* Check the parameters */ assert_param(IS_RTC_ALL_INSTANCE(hrtc-&gt;Instance)); assert_param(IS_RTC_HOUR_FORMAT(hrtc-&gt;Init.HourFormat)); assert_param(IS_RTC_ASYNCH_PREDIV(hrtc-&gt;Init.AsynchPrediv)); assert_param(IS_RTC_SYNCH_PREDIV(hrtc-&gt;Init.SynchPrediv)); assert_param (IS_RTC_OUTPUT(hrtc-&gt;Init.OutPut)); assert_param (IS_RTC_OUTPUT_POL(hrtc-&gt;Init.OutPutPolarity)); assert_param(IS_RTC_OUTPUT_TYPE(hrtc-&gt;Init.OutPutType)); if(hrtc-&gt;State == HAL_RTC_STATE_RESET) &#123; /* Allocate lock resource and initialize it */ hrtc-&gt;Lock = HAL_UNLOCKED; /* Initialize RTC MSP */ HAL_RTC_MspInit(hrtc); /* ä½¿èƒ½RTCæ—¶é’Ÿ */ &#125; /* Set RTC state */ hrtc-&gt;State = HAL_RTC_STATE_BUSY; /* Disable the write protection for RTC registers */ __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc); /* è§£é”RTCå¯„å­˜å™¨çš„å†™ä¿æŠ¤ */ /* Set Initialization mode */ if(RTC_EnterInitMode(hrtc) != HAL_OK) /* è¿›å…¥RTCåˆå§‹åŒ–æ¨¡å¼ */ &#123; /* Enable the write protection for RTC registers */ __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); /* Set RTC state */ hrtc-&gt;State = HAL_RTC_STATE_ERROR; return HAL_ERROR; &#125; else &#123; /* Clear RTC_CR FMT, OSEL and POL Bits */ hrtc-&gt;Instance-&gt;CR &amp;= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL)); /* é…ç½®RTCæ¨¡å¼ */ /* Set RTC_CR register */ hrtc-&gt;Instance-&gt;CR |= (uint32_t)(hrtc-&gt;Init.HourFormat | hrtc-&gt;Init.OutPut | hrtc-&gt;Init.OutPutPolarity); /* Configure the RTC PRER */ /* é…ç½®RTCåˆ†é¢‘ç³»æ•° */ hrtc-&gt;Instance-&gt;PRER = (uint32_t)(hrtc-&gt;Init.SynchPrediv); hrtc-&gt;Instance-&gt;PRER |= (uint32_t)(hrtc-&gt;Init.AsynchPrediv &lt;&lt; 16); /* Exit Initialization mode */ hrtc-&gt;Instance-&gt;ISR &amp;= (uint32_t)~RTC_ISR_INIT; /* è·³å‡ºåˆå§‹åŒ–æ¨¡å¼ */ hrtc-&gt;Instance-&gt;OR &amp;= (uint32_t)~RTC_OR_ALARMTYPE; /* ALARM TIMESTAMP IOè®¾ç½® */ hrtc-&gt;Instance-&gt;OR |= (uint32_t)(hrtc-&gt;Init.OutPutType); /* Enable the write protection for RTC registers */ __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); /* ä¸Šé”RTCå¯„å­˜å™¨çš„å†™ä¿æŠ¤ */ /* Set RTC state */ hrtc-&gt;State = HAL_RTC_STATE_READY; return HAL_OK; &#125;&#125; &emsp;HAL_RTC_MspInit()å‡½æ•°ä»…ç”¨äºä½¿èƒ½RTCæ—¶é’Ÿï¼Œå…·ä½“å¦‚ä¸‹ã€‚ 123456789101112131415void HAL_RTC_MspInit(RTC_HandleTypeDef* rtcHandle)&#123; if(rtcHandle-&gt;Instance==RTC) &#123; /* USER CODE BEGIN RTC_MspInit 0 */ /* USER CODE END RTC_MspInit 0 */ /* RTC clock enable */ __HAL_RCC_RTC_ENABLE(); /* USER CODE BEGIN RTC_MspInit 1 */ /* USER CODE END RTC_MspInit 1 */ &#125;&#125; &emsp;RTCå…·æœ‰å¯„å­˜å™¨å†™ä¿æŠ¤åŠŸèƒ½ï¼Œè¿›è¡Œå¯„å­˜å™¨å†™å…¥ä¹‹å‰å¿…é¡»é¦–å…ˆè¿›è¡Œè§£é”ã€‚è§£é”çš„æ“ä½œä¸ºï¼šæŒ‰é¡ºåºå†™å…¥0xCAä¸0x53å³å¯è§£é”æ‰€æœ‰RTCå¯„å­˜å™¨ï¼›å†™å…¥ä¸€ä¸ªé”™è¯¯çš„å…³é”®å­—ä¼šå†æ¬¡æ¿€æ´»å†™ä¿æŠ¤ã€‚ 1234567891011121314151617181920/** * @brief Disable the write protection for RTC registers. * @param __HANDLE__ specifies the RTC handle. * @retval None */#define __HAL_RTC_WRITEPROTECTION_DISABLE(__HANDLE__) \\ do&#123; \\ (__HANDLE__)-&gt;Instance-&gt;WPR = 0xCAU; \\ (__HANDLE__)-&gt;Instance-&gt;WPR = 0x53U; \\ &#125; while(0U)/** * @brief Enable the write protection for RTC registers. * @param __HANDLE__ specifies the RTC handle. * @retval None */#define __HAL_RTC_WRITEPROTECTION_ENABLE(__HANDLE__) \\ do&#123; \\ (__HANDLE__)-&gt;Instance-&gt;WPR = 0xFFU; \\ &#125; while(0U) &emsp;RTC_EnterInitMode()å‡½æ•°ç”¨äºå°†RTCè®¾ç½®ä¸ºåˆå§‹åŒ–æ¨¡å¼ã€‚é€šè¿‡å°†RTC RTC_ISRå¯„å­˜å™¨INITä½ç½®ä½å®ç°ã€‚ 123456789101112131415161718192021222324252627282930313233/** * @brief Enters the RTC Initialization mode. * @note The RTC Initialization mode is write protected, use the * __HAL_RTC_WRITEPROTECTION_DISABLE() before calling this function. * @param hrtc pointer to a RTC_HandleTypeDef structure that contains * the configuration information for RTC. * @retval HAL status */HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef* hrtc)&#123; uint32_t tickstart = 0; /* Check if the Initialization mode is set */ if((hrtc-&gt;Instance-&gt;ISR &amp; RTC_ISR_INITF) == (uint32_t)RESET) &#123; /* Set the Initialization mode */ hrtc-&gt;Instance-&gt;ISR = (uint32_t)RTC_INIT_MASK; /* Get tick */ tickstart = HAL_GetTick(); /* Wait till RTC is in INIT state and if Time out is reached exit */ while((hrtc-&gt;Instance-&gt;ISR &amp; RTC_ISR_INITF) == (uint32_t)RESET) &#123; if((HAL_GetTick() - tickstart ) &gt; RTC_TIMEOUT_VALUE) &#123; return HAL_TIMEOUT; &#125; &#125; &#125; return HAL_OK; &#125; &emsp;ä¹‹åè¿›å…¥ä¸»é…ç½®ç¯èŠ‚ï¼Œå…·ä½“é…ç½®å¦‚ä¸‹ï¼š é€šè¿‡RTC_CRå¯„å­˜å™¨FMTã€OSELã€POLä½åˆ†åˆ«è®¾ç½®å°æ—¶æ ¼å¼ã€è¾“å‡ºé€‰æ‹©ä¸è¾“å‡ºææ€§ï¼Œæœ¬ä¾‹è®¾ç½®ä¸º24å°æ—¶åˆ¶ï¼Œè¾“å‡ºç¦ç”¨ï¼› é€šè¿‡RTC_PRERå¯„å­˜å™¨è®¾ç½®é¢„åˆ†é¢‘ç³»æ•°ï¼› è·³å‡ºåˆå§‹åŒ–æ¨¡å¼ï¼› è®¾ç½®ALARMä¸TIMESTAMPï¼Œæœ¬ä¾‹ä¸­ä¸ä½¿ç”¨ï¼› ä¸Šé”RTCå¯„å­˜å™¨å†™ä¿æŠ¤ã€‚ HAL_RTC_SetTime()å‡½æ•°å®ç°&emsp;HAL_RTC_SetTime()å‡½æ•°ç”¨äºè®¾ç½®RTCæ—¶é—´ï¼Œå…·ä½“å®ç°å¦‚ä¸‹ã€‚è¯¥å‡½æ•°çš„æ ¸å¿ƒåŠŸèƒ½ä¸ºé€šè¿‡å‘RTCæ—¶é—´å¯„å­˜å™¨RTC_TRå†™å…¥æ—¶åˆ†ç§’æ—¶é—´å®ç°ï¼Œæœ¬ä¾‹ä¸­ä¸å¯ç”¨å¤ä»¤æ—¶ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/** * @brief Sets RTC current time. * @param hrtc pointer to a RTC_HandleTypeDef structure that contains * the configuration information for RTC. * @param sTime Pointer to Time structure * @param Format Specifies the format of the entered parameters. * This parameter can be one of the following values: * @arg FORMAT_BIN: Binary data format * @arg FORMAT_BCD: BCD data format * @retval HAL status */HAL_StatusTypeDef HAL_RTC_SetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)&#123; uint32_t tmpreg = 0; /* Check the parameters */ assert_param(IS_RTC_FORMAT(Format)); assert_param(IS_RTC_DAYLIGHT_SAVING(sTime-&gt;DayLightSaving)); assert_param(IS_RTC_STORE_OPERATION(sTime-&gt;StoreOperation)); /* Process Locked */ __HAL_LOCK(hrtc); hrtc-&gt;State = HAL_RTC_STATE_BUSY; if(Format == RTC_FORMAT_BIN) &#123; if((hrtc-&gt;Instance-&gt;CR &amp; RTC_CR_FMT) != (uint32_t)RESET) &#123; assert_param(IS_RTC_HOUR12(sTime-&gt;Hours)); assert_param(IS_RTC_HOURFORMAT12(sTime-&gt;TimeFormat)); &#125; else &#123; sTime-&gt;TimeFormat = 0x00; assert_param(IS_RTC_HOUR24(sTime-&gt;Hours)); &#125; assert_param(IS_RTC_MINUTES(sTime-&gt;Minutes)); assert_param(IS_RTC_SECONDS(sTime-&gt;Seconds)); tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime-&gt;Hours) &lt;&lt; 16) | \\ ((uint32_t)RTC_ByteToBcd2(sTime-&gt;Minutes) &lt;&lt; 8) | \\ ((uint32_t)RTC_ByteToBcd2(sTime-&gt;Seconds)) | \\ (((uint32_t)sTime-&gt;TimeFormat) &lt;&lt; 16)); &#125; else &#123; if((hrtc-&gt;Instance-&gt;CR &amp; RTC_CR_FMT) != (uint32_t)RESET) &#123; tmpreg = RTC_Bcd2ToByte(sTime-&gt;Hours); assert_param(IS_RTC_HOUR12(tmpreg)); assert_param(IS_RTC_HOURFORMAT12(sTime-&gt;TimeFormat)); &#125; else &#123; sTime-&gt;TimeFormat = 0x00; assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sTime-&gt;Hours))); &#125; assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sTime-&gt;Minutes))); assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sTime-&gt;Seconds))); tmpreg = (((uint32_t)(sTime-&gt;Hours) &lt;&lt; 16) | \\ ((uint32_t)(sTime-&gt;Minutes) &lt;&lt; 8) | \\ ((uint32_t)sTime-&gt;Seconds) | \\ ((uint32_t)(sTime-&gt;TimeFormat) &lt;&lt; 16)); &#125; /* Disable the write protection for RTC registers */ __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc); /* Set Initialization mode */ if(RTC_EnterInitMode(hrtc) != HAL_OK) &#123; /* Enable the write protection for RTC registers */ __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); /* Set RTC state */ hrtc-&gt;State = HAL_RTC_STATE_ERROR; /* Process Unlocked */ __HAL_UNLOCK(hrtc); return HAL_ERROR; &#125; else &#123; /* Set the RTC_TR register */ hrtc-&gt;Instance-&gt;TR = (uint32_t)(tmpreg &amp; RTC_TR_RESERVED_MASK); /* Clear the bits to be configured */ hrtc-&gt;Instance-&gt;CR &amp;= (uint32_t)~RTC_CR_BKP; /* Configure the RTC_CR register */ hrtc-&gt;Instance-&gt;CR |= (uint32_t)(sTime-&gt;DayLightSaving | sTime-&gt;StoreOperation); /* Exit Initialization mode */ hrtc-&gt;Instance-&gt;ISR &amp;= (uint32_t)~RTC_ISR_INIT; /* If CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */ if((hrtc-&gt;Instance-&gt;CR &amp; RTC_CR_BYPSHAD) == RESET) &#123; if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK) &#123; /* Enable the write protection for RTC registers */ __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); hrtc-&gt;State = HAL_RTC_STATE_ERROR; /* Process Unlocked */ __HAL_UNLOCK(hrtc); return HAL_ERROR; &#125; &#125; /* Enable the write protection for RTC registers */ __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); hrtc-&gt;State = HAL_RTC_STATE_READY; __HAL_UNLOCK(hrtc); return HAL_OK; &#125;&#125; HAL_RTC_SetDate()å‡½æ•°å®ç°&emsp;HAL_RTC_SetDate()å‡½æ•°ç”¨äºè®¾ç½®RTCæ—¥æœŸï¼Œå…·ä½“å®ç°å¦‚ä¸‹ã€‚è¯¥å‡½æ•°çš„æ ¸å¿ƒåŠŸèƒ½ä¸ºé€šè¿‡å‘RTCæ—¶é—´å¯„å­˜å™¨RTC_DRå†™å…¥å¹´æœˆæ—¥ä»¥åŠå‘¨æ—¶é—´å®ç°ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/** * @brief Sets RTC current date. * @param hrtc pointer to a RTC_HandleTypeDef structure that contains * the configuration information for RTC. * @param sDate Pointer to date structure * @param Format specifies the format of the entered parameters. * This parameter can be one of the following values: * @arg RTC_FORMAT_BIN: Binary data format * @arg RTC_FORMAT_BCD: BCD data format * @retval HAL status */HAL_StatusTypeDef HAL_RTC_SetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)&#123; uint32_t datetmpreg = 0; /* Check the parameters */ assert_param(IS_RTC_FORMAT(Format)); /* Process Locked */ __HAL_LOCK(hrtc); hrtc-&gt;State = HAL_RTC_STATE_BUSY; if((Format == RTC_FORMAT_BIN) &amp;&amp; ((sDate-&gt;Month &amp; 0x10U) == 0x10U)) &#123; sDate-&gt;Month = (uint8_t)((sDate-&gt;Month &amp; (uint8_t)~(0x10U)) + (uint8_t)0x0AU); &#125; assert_param(IS_RTC_WEEKDAY(sDate-&gt;WeekDay)); if(Format == RTC_FORMAT_BIN) &#123; assert_param(IS_RTC_YEAR(sDate-&gt;Year)); assert_param(IS_RTC_MONTH(sDate-&gt;Month)); assert_param(IS_RTC_DATE(sDate-&gt;Date)); datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate-&gt;Year) &lt;&lt; 16) | \\ ((uint32_t)RTC_ByteToBcd2(sDate-&gt;Month) &lt;&lt; 8) | \\ ((uint32_t)RTC_ByteToBcd2(sDate-&gt;Date)) | \\ ((uint32_t)sDate-&gt;WeekDay &lt;&lt; 13)); &#125; else &#123; assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(sDate-&gt;Year))); assert_param(IS_RTC_MONTH(sDate-&gt;Month)); assert_param(IS_RTC_DATE(sDate-&gt;Date)); datetmpreg = ((((uint32_t)sDate-&gt;Year) &lt;&lt; 16) | \\ (((uint32_t)sDate-&gt;Month) &lt;&lt; 8) | \\ ((uint32_t)sDate-&gt;Date) | \\ (((uint32_t)sDate-&gt;WeekDay) &lt;&lt; 13)); &#125; /* Disable the write protection for RTC registers */ __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc); /* Set Initialization mode */ if(RTC_EnterInitMode(hrtc) != HAL_OK) &#123; /* Enable the write protection for RTC registers */ __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); /* Set RTC state*/ hrtc-&gt;State = HAL_RTC_STATE_ERROR; /* Process Unlocked */ __HAL_UNLOCK(hrtc); return HAL_ERROR; &#125; else &#123; /* Set the RTC_DR register */ hrtc-&gt;Instance-&gt;DR = (uint32_t)(datetmpreg &amp; RTC_DR_RESERVED_MASK); /* Exit Initialization mode */ hrtc-&gt;Instance-&gt;ISR &amp;= (uint32_t)~RTC_ISR_INIT; /* If CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */ if((hrtc-&gt;Instance-&gt;CR &amp; RTC_CR_BYPSHAD) == RESET) &#123; if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK) &#123; /* Enable the write protection for RTC registers */ __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); hrtc-&gt;State = HAL_RTC_STATE_ERROR; /* Process Unlocked */ __HAL_UNLOCK(hrtc); return HAL_ERROR; &#125; &#125; /* Enable the write protection for RTC registers */ __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); hrtc-&gt;State = HAL_RTC_STATE_READY ; /* Process Unlocked */ __HAL_UNLOCK(hrtc); return HAL_OK; &#125;&#125; HAL_RTCEx_BKUPRead/Write()å‡½æ•°å®ç°&emsp;RTCæœ‰32ä¸ªå¤‡ä»½å¯„å­˜å™¨ï¼Œå¯ä»¥ç”¨äºå­˜å‚¨ä¸€äº›ç‰¹å¾å˜é‡ã€‚æœ¬ä¾‹ä¸­RTCåˆå§‹åŒ–å‡½æ•°å±•ç¤ºäº†å¤‡ä»½å¯„å­˜å™¨çš„ä¸€ä¸ªç”¨æ³•ï¼šç”¨äºæ ‡è®°æ˜¯å¦è¿›è¡Œè¿‡RTCåˆå§‹åŒ–ï¼Œé˜²æ­¢é‡æ–°ä¸Šç”µå¯¹RTCè¿›è¡Œé‡å¤åˆå§‹åŒ–ã€‚RTCåˆå§‹åŒ–å‡½æ•°é¦–å…ˆè¯»å–æœ¬åˆ†å¯„å­˜å™¨0å­˜å‚¨çš„æ•°å€¼ï¼Œå¦‚æœä¸æ¯”å¯¹å€¼ä¸ä¸€è‡´åˆ™åˆå§‹åŒ–RTCï¼›å½“åˆå§‹åŒ–å®Œæˆé‡æ–°ä¸Šç”µåï¼Œå¯„å­˜å™¨å€¼ä¸æ¯”å¯¹å€¼ä¸€è‡´ï¼Œæ‰€ä»¥ä¸å†é‡æ–°åˆå§‹åŒ–ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * @brief Reads data from the specified RTC Backup data Register. * @param hrtc pointer to a RTC_HandleTypeDef structure that contains * the configuration information for RTC. * @param BackupRegister RTC Backup data Register number. * This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to * specify the register. * @retval Read value */uint32_t HAL_RTCEx_BKUPRead(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister)&#123; uint32_t tmp = 0; /* Check the parameters */ assert_param(IS_RTC_BKP(BackupRegister)); tmp = (uint32_t)&amp;(hrtc-&gt;Instance-&gt;BKP0R); tmp += (BackupRegister * 4); /* Read the specified register */ return (*(__IO uint32_t *)tmp);&#125;/** * @brief Writes a data in a specified RTC Backup data register. * @param hrtc pointer to a RTC_HandleTypeDef structure that contains * the configuration information for RTC. * @param BackupRegister RTC Backup data Register number. * This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to * specify the register. * @param Data Data to be written in the specified RTC Backup data register. * @retval None */void HAL_RTCEx_BKUPWrite(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister, uint32_t Data)&#123; uint32_t tmp = 0; /* Check the parameters */ assert_param(IS_RTC_BKP(BackupRegister)); tmp = (uint32_t)&amp;(hrtc-&gt;Instance-&gt;BKP0R); tmp += (BackupRegister * 4); /* Write the specified register */ *(__IO uint32_t *)tmp = (uint32_t)Data;&#125; å®éªŒéªŒè¯&emsp;RTCåˆå§‹åŒ–å®Œæˆåå¯ä»¥å¯¹RTCæ—¶é—´è¿›è¡Œè¯»å–ï¼Œå…·ä½“æ–¹æ³•å¦‚ä¸‹ã€‚ 123456789101112131415161718while (1)&#123; mainloop++; oled_putuint32(0, 2, mainloop); HAL_RTC_GetTime(&amp;hrtc, &amp;rtcTime, RTC_FORMAT_BIN); LCD_P6x8Num3(0, 5, rtcTime.Hours); LCD_P6x8Num3(4, 5, rtcTime.Minutes); LCD_P6x8Num3(8, 5, rtcTime.Seconds); HAL_RTC_GetDate(&amp;hrtc, &amp;rtcData, RTC_FORMAT_BIN); LCD_P6x8Num3(0, 4, rtcData.Year); LCD_P6x8Num3(4, 4, rtcData.Month); LCD_P6x8Num3(8, 4, rtcData.Date); SYS_Delay_US(500000); &#125; &emsp;è¿è¡Œç¨‹åºåï¼Œå¯ä»¥çœ‹åˆ°æ—¶é—´ã€æ—¥æœŸè¯»å–æ­£ç¡®ï¼›æ–­ç”µåç”±äºåå¤‡ç”µæ± çš„å­˜åœ¨RTCä¾ç„¶å¯ä»¥è®¡æ—¶ã€‚ æœ‰ä¸€ç‚¹éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒHAL_RTC_GetTime()å‡½æ•°å¿…é¡»å…ˆäºHAL_RTC_GetDate()å‡½æ•°è°ƒç”¨ï¼ŒSTå¯¹æ­¤çš„è§£é‡Šå¦‚ä¸‹ï¼š å…³äºè¿™ä¸ªé—®é¢˜ï¼Œè¯»æ—¥å†æ—¶é—´æ—¶æœ‰ä¸¤ç§æ¨¡å¼ã€‚ ä¸€ç§æ˜¯é€šè¿‡å½±å­å¯„å­˜å™¨æ¥è¯»å–ï¼Œä¸€ç§æ˜¯ç›´æ¥æ—¥å†è®¡æ•°å™¨ä¸­è¯»ã€‚ä½ è°ˆåˆ°çš„æƒ…å†µæ˜¯å‰è€…ã€‚ åœ¨è¯¥æƒ…å½¢ä¸‹ï¼Œå»ºè®®å…ˆè¯»æ—¶åˆ†ç§’å¯„å­˜å™¨å³TRå¯„å­˜å™¨ï¼Œç„¶åè¯»æ—¥æœŸå¯„å­˜å™¨ï¼Œå³DRå¯„å­˜å™¨ã€‚ åœ¨è¯»å–TR/SSRå¯„å­˜å™¨åï¼ŒDRå½±å­å¯„å­˜å™¨çš„æ•°æ®ä¼šè¢«é”å®šè€Œä¸è¢«æ›´æ–°ï¼Œç›´åˆ°ä½ æ¥è¯»å®ƒï¼Œè¿™ æ ·æ˜¯ä¸ºäº†ä¿æŒæ•°æ®çš„ä¸€è‡´æ€§ã€‚ æ¯”å¦‚ä½ åœ¨5æœˆ29æ—¥çš„23:59:59ç§’å»è¯»è¯¥æ—¶é—´ã€TR/SSRã€‘ï¼Œæ­¤æ—¶29æ—¥å°±ä¼šè¢«é”å®šï¼Œè¿™æ ·ä½  å¯ä»¥æ‚ ç„¶åœ°å»è¯»æ—¥æœŸï¼Œæ—¥æœŸè¿˜æ˜¯æ­£ç¡®çš„29æ—¥ï¼Œå¦åˆ™1ç§’è¿‡åå»è¯»çš„è¯ï¼Œä½ è¯»åˆ°æ—¥æœŸå°±æ˜¯30æ—¥ äº†ï¼Œæ˜¾ç„¶æ•´ä¸ªè¯»è¿›æ¥çš„æ—¶é—´å°±ä¸å¯¹äº†ã€‚ &emsp;æœ¬ä¾‹ä¸­RTC_CRå¯„å­˜å™¨çš„BYPSHADä½è®¾ç½®ä¸º0ï¼Œå³æ—¥å†å€¼ï¼ˆä» RTC_SSRã€RTC_TR å’Œ RTC_DR è¯»å–æ—¶ï¼‰å–è‡ªå½±å­å¯„å­˜å™¨ï¼Œè¯¥å½±å­å¯„å­˜å™¨æ¯ä¸¤ä¸ª RTCCLK å‘¨æœŸæ›´æ–°ä¸€æ¬¡ï¼Œå¯¹åº”äº†ä¸Šè¿°æƒ…å†µï¼Œæ‰€ä»¥åº”è¯¥æŒ‰ç…§å…ˆè¯»TRå¯„å­˜å™¨ï¼Œå†è¯»DRå¯„å­˜å™¨çš„æ–¹å¼ã€‚","categories":[{"name":"åµŒå…¥å¼","slug":"åµŒå…¥å¼","permalink":"http://jiaodi.tech/categories/åµŒå…¥å¼/"}],"tags":[{"name":"STM32F7","slug":"STM32F7","permalink":"http://jiaodi.tech/tags/STM32F7/"},{"name":"RTC","slug":"RTC","permalink":"http://jiaodi.tech/tags/RTC/"}]},{"title":"STM32F767 DMAçš„åŸºæœ¬ç”¨æ³•","slug":"stm32f767-uart-dma","date":"2018-05-19T12:19:51.000Z","updated":"2018-05-21T15:01:43.353Z","comments":true,"path":"2018/05/19/stm32f767-uart-dma/","link":"","permalink":"http://jiaodi.tech/2018/05/19/stm32f767-uart-dma/","excerpt":"æœ¬æ–‡ä»‹ç»STM32F767 DMA(Direct memory access controller)çš„åŸºæœ¬ç”¨æ³•ã€‚","text":"æœ¬æ–‡ä»‹ç»STM32F767 DMA(Direct memory access controller)çš„åŸºæœ¬ç”¨æ³•ã€‚ å¼€å‘ç¯å¢ƒç¡¬ä»¶ç¯å¢ƒ ç”µè„‘ï¼šWindows 10 Home x64 Apollo STM32F767å¼€å‘æ¿(ST-LINK V2ä»¿çœŸå™¨) è½¯ä»¶ç¯å¢ƒ Keil Version 5.24.1 (Pack Installerï¼šKeil.STM32F7xx_DFP.2.9.0.pack) STM32CubeMX Version 4.25.0(Packages Managerï¼šSTM32CubeF7) DMAçš„åŸºæœ¬ç‰¹æ€§&emsp;ç›´æ¥å­˜å‚¨å™¨è®¿é—® (DMA) ç”¨äºåœ¨å¤–è®¾ä¸å­˜å‚¨å™¨ä¹‹é—´ä»¥åŠå­˜å‚¨å™¨ä¸å­˜å‚¨å™¨ä¹‹é—´æä¾›é«˜é€Ÿæ•°æ®ä¼ è¾“ã€‚å¯ä»¥åœ¨æ— éœ€ä»»ä½• CPU æ“ä½œçš„æƒ…å†µä¸‹é€šè¿‡ DMA å¿«é€Ÿç§»åŠ¨æ•°æ®ã€‚è¿™æ ·èŠ‚çœçš„ CPU èµ„æºå¯ä¾›å…¶å®ƒæ“ä½œä½¿ç”¨ã€‚ &emsp;ä¸¤ä¸ª DMA æ§åˆ¶å™¨æ€»å…±æœ‰ 16 ä¸ªæ•°æ®æµï¼ˆæ¯ä¸ªæ§åˆ¶å™¨ 8 ä¸ªï¼‰ï¼Œæ¯ä¸€ä¸ª DMA æ§åˆ¶å™¨éƒ½ç”¨äºç®¡ç†ä¸€ä¸ªæˆ–å¤šä¸ªå¤–è®¾çš„å­˜å‚¨å™¨è®¿é—®è¯·æ±‚ã€‚æ¯ä¸ªæ•°æ®æµæ€»å…±å¯ä»¥æœ‰å¤šè¾¾ 8 ä¸ªé€šé“ï¼ˆæˆ–ç§°è¯·æ±‚ï¼‰ã€‚æ¯ä¸ªé€šé“éƒ½æœ‰ä¸€ä¸ªä»²è£å™¨ï¼Œç”¨äºå¤„ç† DMA è¯·æ±‚é—´çš„ä¼˜å…ˆçº§ã€‚ ç³»ç»Ÿæ¡†å›¾&emsp;DMAçš„ç³»ç»Ÿæ¡†å›¾å¦‚ä¸‹æ‰€ç¤ºã€‚ ä¸»è¦ç‰¹æ€§&emsp;DMAçš„ç‰¹æ€§è¾ƒä¸ºå¤æ‚ï¼Œé‡ç‚¹å¦‚ä¸‹ï¼š STM32F767å…·æœ‰2ä¸ªDMAæ§åˆ¶å™¨ï¼› æ¯ä¸ª DMA æ§åˆ¶å™¨æœ‰ 8 ä¸ªæ•°æ®æµï¼Œæ¯ä¸ªæ•°æ®æµæœ‰å¤šè¾¾ 8 ä¸ªé€šé“(æˆ–ç§°è¯·æ±‚)ï¼› æ¯ä¸ªæ•°æ®æµæœ‰4çº§32ä½å…ˆè¿›å…ˆå‡ºFIFOï¼› é€šè¿‡ç¡¬ä»¶å¯ä»¥å°†æ¯ä¸ªæ•°æ®æµé…ç½®ä¸ºï¼šæ”¯æŒå¤–è®¾åˆ°å­˜å‚¨å™¨ã€å­˜å‚¨å™¨åˆ°å¤–è®¾å’Œå­˜å‚¨å™¨åˆ°å­˜å‚¨å™¨ä¼ è¾“çš„å¸¸è§„é€šé“ï¼›åœ¨å­˜å‚¨å™¨ç«¯æ”¯æŒåŒç¼“å†²çš„åŒç¼“å†²åŒºé€šé“ï¼› DMA æ•°æ®æµè¯·æ±‚ä¹‹é—´çš„ä¼˜å…ˆçº§å¯ç”¨è½¯ä»¶ç¼–ç¨‹ï¼ˆ4 ä¸ªçº§åˆ«ï¼šéå¸¸é«˜ã€é«˜ã€ä¸­ã€ä½ï¼‰ï¼› å¯ä¾›æ¯ä¸ªæ•°æ®æµé€‰æ‹©çš„é€šé“è¯·æ±‚å¤šè¾¾ 8 ä¸ªï¼› è¦ä¼ è¾“çš„æ•°æ®é¡¹çš„æ•°ç›®å¯ä»¥ç”± DMA æ§åˆ¶å™¨æˆ–å¤–è®¾ç®¡ç†ï¼› DMA æµæ§åˆ¶å™¨ï¼šè¦ä¼ è¾“çš„æ•°æ®é¡¹çš„æ•°ç›®å¯ç”¨è½¯ä»¶ç¼–ç¨‹ï¼Œä» 1 è‡³ 65535ï¼› å¯¹æºå’Œç›®æ ‡çš„å¢é‡æˆ–éå¢é‡å¯»å€ï¼› 5 ä¸ªäº‹ä»¶æ ‡å¿—ï¼ˆDMA åŠä¼ è¾“ã€DMA ä¼ è¾“å®Œæˆã€DMA ä¼ è¾“é”™è¯¯ã€DMA FIFO é”™è¯¯ã€ç›´æ¥æ¨¡å¼é”™è¯¯ï¼‰ï¼Œè¿›è¡Œé€»è¾‘æˆ–è¿ç®—ï¼Œä»è€Œäº§ç”Ÿæ¯ä¸ªæ•°æ®æµçš„å•ä¸ªä¸­æ–­è¯·æ±‚ã€‚ DMAé€šé“é€‰æ‹©&emsp;DMAä¸­æ¯ä¸€ä¸ªæ•°æ®æµå‡æœ‰ä¸€ä¸ªDMAè¯·æ±‚ã€‚DMAè¯·æ±‚æ˜ å°„çš„åˆ—è¡¨å¦‚ä¸‹æ‰€ç¤ºã€‚ DMAçš„åŸºæœ¬è®¾ç½®&emsp;DMAçš„å…·ä½“åº”ç”¨æ–¹å¼å¾ˆå¤šï¼Œæœ¬æ–‡ä»¥ç”¨DMAå®ç°UART1æ•°æ®å‘é€ä¸ºä¾‹è®²è§£DMAçš„ç”¨æ³•ã€‚ DMAé€šé“é€‰æ‹©&emsp;USART1_TXè¯·æ±‚ä½äºDMA2çš„æ•°æ®æµ7ï¼Œé€šé“4ã€‚ DMAæ—¶é’Ÿä¸NVICåˆå§‹åŒ–&emsp;åˆå§‹åŒ–ä»£ç å¦‚ä¸‹æ‰€ç¤ºã€‚ 1234567891011121314/** * Enable DMA controller clock */void MX_DMA_Init(void) &#123; /* DMA controller clock enable */ __HAL_RCC_DMA2_CLK_ENABLE(); /* DMA interrupt init */ /* DMA2_Stream7_IRQn interrupt configuration */ HAL_NVIC_SetPriority(DMA2_Stream7_IRQn, 0, 0); HAL_NVIC_EnableIRQ(DMA2_Stream7_IRQn);&#125; &emsp;ä»£ç çš„ä¸»è¦åŠŸèƒ½ä¸ºï¼š ä½¿èƒ½DMA2æ—¶é’Ÿï¼› è®¾å®šDMA2æ•°æ®æµ7çš„NVICä¼˜å…ˆçº§å¹¶ä½¿èƒ½ï¼›DMAä¸­æ–­ä¼˜å…ˆçº§éœ€è¦æ ¹æ®ç³»ç»Ÿæ•´ä½“è¿›è¡Œç¡®å®šï¼Œæœ¬å¤„è®¾ç½®åªæ˜¯ç¤ºä¾‹ã€‚ UARTåˆå§‹åŒ–12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/* USART1 init function */void MX_USART1_UART_Init(void)&#123; huart1.Instance = USART1; huart1.Init.BaudRate = 115200; huart1.Init.WordLength = UART_WORDLENGTH_8B; huart1.Init.StopBits = UART_STOPBITS_1; huart1.Init.Parity = UART_PARITY_NONE; huart1.Init.Mode = UART_MODE_TX_RX; huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart1.Init.OverSampling = UART_OVERSAMPLING_16; huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE; huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT; if (HAL_UART_Init(&amp;huart1) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125;&#125;void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)&#123; GPIO_InitTypeDef GPIO_InitStruct; if(uartHandle-&gt;Instance==USART1) &#123; /* USER CODE BEGIN USART1_MspInit 0 */ /* USER CODE END USART1_MspInit 0 */ /* USART1 clock enable */ __HAL_RCC_USART1_CLK_ENABLE(); /**USART1 GPIO Configuration PA9 ------&gt; USART1_TX PA10 ------&gt; USART1_RX */ GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH; GPIO_InitStruct.Alternate = GPIO_AF7_USART1; HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct); /* USART1 DMA Init */ /* USART1_TX Init */ hdma_usart1_tx.Instance = DMA2_Stream7; hdma_usart1_tx.Init.Channel = DMA_CHANNEL_4; hdma_usart1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH; hdma_usart1_tx.Init.PeriphInc = DMA_PINC_DISABLE; hdma_usart1_tx.Init.MemInc = DMA_MINC_ENABLE; hdma_usart1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE; hdma_usart1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE; hdma_usart1_tx.Init.Mode = DMA_NORMAL; hdma_usart1_tx.Init.Priority = DMA_PRIORITY_LOW; hdma_usart1_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE; if (HAL_DMA_Init(&amp;hdma_usart1_tx) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; __HAL_LINKDMA(uartHandle,hdmatx,hdma_usart1_tx); /* USART1 interrupt Init */ HAL_NVIC_SetPriority(USART1_IRQn, 0, 0); HAL_NVIC_EnableIRQ(USART1_IRQn); /* USER CODE BEGIN USART1_MspInit 1 */ /* USER CODE END USART1_MspInit 1 */ &#125;&#125; &emsp;UARTçš„åˆå§‹åŒ–ä¸²å£éƒ¨åˆ†ä¹‹å‰å·²ç»ä»‹ç»è¿‡ï¼Œè¿™é‡Œä¸å†å¤è¿°ï¼ŒDMAç›¸å…³éƒ¨åˆ†åŠŸèƒ½å¦‚ä¸‹ï¼š åˆå§‹åŒ–å®ä¾‹é€‰æ‹©ä¸ºDMA2æ•°æ®æµ7ï¼Œé€šé“4ï¼› æ–¹å‘ä¸ºï¼šå­˜å‚¨å™¨åˆ°å¤–è®¾ï¼› DMAå¤–è®¾ï¼šéå¢é‡æ¨¡å¼ï¼› å­˜å‚¨å™¨å¤–è®¾ï¼šå¢é‡æ¨¡å¼ï¼› å¤–è®¾æ•°æ®å¯¹é½ï¼šbyteï¼Œå³ä¸º8bitï¼› å­˜å‚¨å™¨æ•°æ®å¯¹é½ï¼šbyteï¼Œå³ä¸º8bitï¼› DMAæ¨¡å¼ï¼šnormalï¼› DMAä¼˜å…ˆçº§ï¼šä½ï¼› DMA FIFOæ¨¡å¼ï¼šç¦ç”¨ï¼› é€šè¿‡HAL_DMA_Init()å‡½æ•°åˆå§‹åŒ–DMAï¼› é€šè¿‡__HAL_LINKDMA()å‡½æ•°å»ºç«‹huart1ä¸hdma_usart1_txå…³è”ï¼› è®¾ç½®USART1 NVICä¼˜å…ˆçº§å¹¶ä½¿èƒ½ä¸­æ–­ã€‚ HAL_DMA_Init()å®ç°&emsp;ä»¥ä¸Šè®¾ç½®é€šè¿‡HAL_DMA_Init()å‡½æ•°å®ç°ï¼Œè¯¥å‡½æ•°å…·ä½“å¦‚ä¸‹ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139/** * @brief Initialize the DMA according to the specified * parameters in the DMA_InitTypeDef and create the associated handle. * @param hdma Pointer to a DMA_HandleTypeDef structure that contains * the configuration information for the specified DMA Stream. * @retval HAL status */HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)&#123; uint32_t tmp = 0U; uint32_t tickstart = HAL_GetTick(); DMA_Base_Registers *regs; /* Check the DMA peripheral state */ if(hdma == NULL) &#123; return HAL_ERROR; &#125; /* Check the parameters */ assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma-&gt;Instance)); assert_param(IS_DMA_CHANNEL(hdma-&gt;Init.Channel)); assert_param(IS_DMA_DIRECTION(hdma-&gt;Init.Direction)); assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma-&gt;Init.PeriphInc)); assert_param(IS_DMA_MEMORY_INC_STATE(hdma-&gt;Init.MemInc)); assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma-&gt;Init.PeriphDataAlignment)); assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma-&gt;Init.MemDataAlignment)); assert_param(IS_DMA_MODE(hdma-&gt;Init.Mode)); assert_param(IS_DMA_PRIORITY(hdma-&gt;Init.Priority)); assert_param(IS_DMA_FIFO_MODE_STATE(hdma-&gt;Init.FIFOMode)); /* Check the memory burst, peripheral burst and FIFO threshold parameters only when FIFO mode is enabled */ if(hdma-&gt;Init.FIFOMode != DMA_FIFOMODE_DISABLE) &#123; assert_param(IS_DMA_FIFO_THRESHOLD(hdma-&gt;Init.FIFOThreshold)); assert_param(IS_DMA_MEMORY_BURST(hdma-&gt;Init.MemBurst)); assert_param(IS_DMA_PERIPHERAL_BURST(hdma-&gt;Init.PeriphBurst)); &#125; /* Allocate lock resource */ __HAL_UNLOCK(hdma); /* Change DMA peripheral state */ hdma-&gt;State = HAL_DMA_STATE_BUSY; /* Disable the peripheral */ __HAL_DMA_DISABLE(hdma); /* Check if the DMA Stream is effectively disabled */ while((hdma-&gt;Instance-&gt;CR &amp; DMA_SxCR_EN) != RESET) &#123; /* Check for the Timeout */ if((HAL_GetTick() - tickstart ) &gt; HAL_TIMEOUT_DMA_ABORT) &#123; /* Update error code */ hdma-&gt;ErrorCode = HAL_DMA_ERROR_TIMEOUT; /* Change the DMA state */ hdma-&gt;State = HAL_DMA_STATE_TIMEOUT; return HAL_TIMEOUT; &#125; &#125; /* Get the CR register value */ tmp = hdma-&gt;Instance-&gt;CR; /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */ tmp &amp;= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \\ DMA_SxCR_PL | DMA_SxCR_MSIZE | DMA_SxCR_PSIZE | \\ DMA_SxCR_MINC | DMA_SxCR_PINC | DMA_SxCR_CIRC | \\ DMA_SxCR_DIR | DMA_SxCR_CT | DMA_SxCR_DBM)); /* Prepare the DMA Stream configuration */ tmp |= hdma-&gt;Init.Channel | hdma-&gt;Init.Direction | hdma-&gt;Init.PeriphInc | hdma-&gt;Init.MemInc | hdma-&gt;Init.PeriphDataAlignment | hdma-&gt;Init.MemDataAlignment | hdma-&gt;Init.Mode | hdma-&gt;Init.Priority; /* the Memory burst and peripheral burst are not used when the FIFO is disabled */ if(hdma-&gt;Init.FIFOMode == DMA_FIFOMODE_ENABLE) &#123; /* Get memory burst and peripheral burst */ tmp |= hdma-&gt;Init.MemBurst | hdma-&gt;Init.PeriphBurst; &#125; /* Write to DMA Stream CR register */ hdma-&gt;Instance-&gt;CR = tmp; /* Get the FCR register value */ tmp = hdma-&gt;Instance-&gt;FCR; /* Clear Direct mode and FIFO threshold bits */ tmp &amp;= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH); /* Prepare the DMA Stream FIFO configuration */ tmp |= hdma-&gt;Init.FIFOMode; /* The FIFO threshold is not used when the FIFO mode is disabled */ if(hdma-&gt;Init.FIFOMode == DMA_FIFOMODE_ENABLE) &#123; /* Get the FIFO threshold */ tmp |= hdma-&gt;Init.FIFOThreshold; /* Check compatibility between FIFO threshold level and size of the memory burst */ /* for INCR4, INCR8, INCR16 bursts */ if (hdma-&gt;Init.MemBurst != DMA_MBURST_SINGLE) &#123; if (DMA_CheckFifoParam(hdma) != HAL_OK) &#123; /* Update error code */ hdma-&gt;ErrorCode = HAL_DMA_ERROR_PARAM; /* Change the DMA state */ hdma-&gt;State = HAL_DMA_STATE_READY; return HAL_ERROR; &#125; &#125; &#125; /* Write to DMA Stream FCR */ hdma-&gt;Instance-&gt;FCR = tmp; /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */ regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma); /* Clear all interrupt flags */ regs-&gt;IFCR = 0x3FU &lt;&lt; hdma-&gt;StreamIndex; /* Initialize the error code */ hdma-&gt;ErrorCode = HAL_DMA_ERROR_NONE; /* Initialize the DMA state */ hdma-&gt;State = HAL_DMA_STATE_READY; return HAL_OK;&#125; &emsp;è¯¥å‡½æ•°çš„ä¸»è¦åŠŸèƒ½æœ‰ï¼š é€šè¿‡DMAé…ç½®å¯„å­˜å™¨DMA_SxCR ENä½å¤ä½ç¦æ­¢æ•°æ®æµï¼Œå¹¶ç­‰å¾…ç¡®è®¤æ•°æ®æµå·²å…³é—­ï¼› tmpé¦–å…ˆè¯»å–DMA_SxCRå¯„å­˜å™¨çš„å€¼ï¼ŒåŒæ—¶å¤ä½æ‰€æœ‰éœ€è¦é…ç½®çš„æ§åˆ¶ä½ï¼› tmpä¸­å†™å…¥CHSELã€DIRã€PINCã€MINCã€PSIZEã€MINCã€CIRCã€PFCTRLã€PLç­‰é…ç½®ä½ï¼› å°†tmpå€¼å†™å…¥åˆ°DMA_SxCRå¯„å­˜å™¨ï¼› tmpè¯»å–FIFOæ§åˆ¶å¯„å­˜å™¨DMA_SxFCRçš„å€¼ï¼Œå¤ä½ç›´æ¥æ¨¡å¼ç¦æ­¢ä½DMDISä¸FIFOé˜ˆå€¼é€‰æ‹©ä½FTHï¼› tmpå†™å…¥FIFOæ¨¡å¼ä½ï¼Œæœ¬ä¾‹ä¸­ä½¿ç”¨ç›´æ¥æ¨¡å¼ï¼Œç¦ç”¨FIFOï¼› å°†tmpå€¼å†™å…¥åˆ°DMA_SxFCRå¯„å­˜å™¨ï¼› é€šè¿‡DMA_HIFCR/DMA_LIFCRå¯„å­˜å™¨æ¸…é™¤DMAæ‰€æœ‰ä¸­æ–­æ ‡å¿—ä½ï¼› è‡³æ­¤ï¼Œå®ŒæˆDMAåˆå§‹åŒ–ã€‚ æºä»£ç ä¸­é€šè¿‡0x3Fæ¸…é™¤ä¸­æ–­æ ‡å¿—ä½å¯èƒ½å­˜åœ¨é—®é¢˜ï¼ŒDMA_HIFCR/DMA_LIFCRå¯„å­˜å™¨ä¸­æ–­æ¸…é™¤æ ‡å¿—ä½ä»…æœ‰5ä¸ªï¼Œæ­¤å¤„æˆ‘è®¤ä¸ºå†™å…¥0x3Dæ‰æ˜¯åˆç†å€¼ã€‚ STå®˜æ–¹å›å¤ï¼šè¿™ä¸ªé¢„ç•™ä½ï¼Œè½¯ä»¶ä¸Šå†™0/å†™1å¯¹å®ƒæ²¡æœ‰å½±å“ï¼Œè¿™ä¸ªé¢„ç•™åŠ¨ä½œæ—¶é ç¡¬ä»¶ä¿è¯çš„ã€‚ __HAL_LINKDMA()å®ç°&emsp;è¯¥å‡½æ•°å…·ä½“å¦‚ä¸‹ã€‚ 1234567__HAL_LINKDMA(uartHandle,hdmatx,hdma_usart1_tx);#define __HAL_LINKDMA(__HANDLE__, __PPP_DMA_FIELD__, __DMA_HANDLE__) \\ do&#123; \\ (__HANDLE__)-&gt;__PPP_DMA_FIELD__ = &amp;(__DMA_HANDLE__); \\ (__DMA_HANDLE__).Parent = (__HANDLE__); \\ &#125; while(0) &emsp;è¯¥å‡½æ•°çš„åŠŸèƒ½å¦‚ä¸‹ï¼š __HAL_LINKDMA()ä¼ å…¥çš„å‚æ•°ä¸ºhuart1ï¼Œhdmatxä»£è¡¨huart1ç»“æ„ä½“UART_HandleTypeDefå®šä¹‰ä¸­çš„å…·ä½“æˆå‘˜å˜é‡ï¼Œå³å°†hdma_usart1_txä½œä¸ºhuart1çš„hdmatxæˆå‘˜å˜é‡ï¼›åŒæ—¶huart1ä½œä¸ºhdma_usart1_txçš„Parentæˆå‘˜å˜é‡ã€‚ åŸºäºDMAçš„UARTå‘é€å®ç°HAL_UART_Transmit_DMA()å®ç°&emsp;DMAè®¾ç½®å®Œæˆåï¼Œå³å¯åŸºäºDMAè¿›è¡ŒUARTå‘é€ï¼Œå…·ä½“é€šè¿‡HAL_UART_Transmit_DMA()å‡½æ•°å®ç°ï¼Œä½¿ç”¨æ–¹æ³•å¦‚ä¸‹ã€‚ 12uint8 sendStr[65535] = \"1234567890\";HAL_UART_Transmit_DMA(&amp;huart1,sendStr,sizeof(sendStr)); &emsp;HAL_UART_Transmit_DMA()å‡½æ•°çš„å®šä¹‰å¦‚ä¸‹ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * @brief Send an amount of data in DMA mode. * @param huart UART handle. * @param pData pointer to data buffer. * @param Size amount of data to be sent. * @retval HAL status */HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)&#123; uint32_t *tmp; /* Check that a Tx process is not already ongoing */ if(huart-&gt;gState == HAL_UART_STATE_READY) &#123; if((pData == NULL ) || (Size == 0U)) &#123; return HAL_ERROR; &#125; /* Process Locked */ __HAL_LOCK(huart); huart-&gt;pTxBuffPtr = pData; huart-&gt;TxXferSize = Size; huart-&gt;TxXferCount = Size; huart-&gt;ErrorCode = HAL_UART_ERROR_NONE; huart-&gt;gState = HAL_UART_STATE_BUSY_TX; /* Set the UART DMA transfer complete callback */ huart-&gt;hdmatx-&gt;XferCpltCallback = UART_DMATransmitCplt; /* Set the UART DMA Half transfer complete callback */ huart-&gt;hdmatx-&gt;XferHalfCpltCallback = UART_DMATxHalfCplt; /* Set the DMA error callback */ huart-&gt;hdmatx-&gt;XferErrorCallback = UART_DMAError; /* Set the DMA abort callback */ huart-&gt;hdmatx-&gt;XferAbortCallback = NULL; /* Enable the UART transmit DMA channel */ tmp = (uint32_t*)&amp;pData; HAL_DMA_Start_IT(huart-&gt;hdmatx, *(uint32_t*)tmp, (uint32_t)&amp;huart-&gt;Instance-&gt;TDR, Size); /* Clear the TC flag in the SR register by writing 0 to it */ __HAL_UART_CLEAR_IT(huart, UART_FLAG_TC); /* Process Unlocked */ __HAL_UNLOCK(huart); /* Enable the DMA transfer for transmit request by setting the DMAT bit in the UART CR3 register */ SET_BIT(huart-&gt;Instance-&gt;CR3, USART_CR3_DMAT); return HAL_OK; &#125; else &#123; return HAL_BUSY; &#125;&#125; &emsp;è¯¥å‡½æ•°å®ç°çš„åŠŸèƒ½ä¸ºï¼š huart1çš„æˆå‘˜å˜é‡pTxBuffPträ¸ºå‘é€æ•°æ®bufferæŒ‡é’ˆï¼Œå°†å…¶æŒ‡å‘å¾…å‘é€æ•°æ®ï¼› huart1çš„æˆå‘˜å˜é‡TxXferSizeä»£è¡¨å‘é€æ•°æ®æ•°ç›®ï¼Œæˆå‘˜å˜é‡TxXferCountä»£è¡¨å‘é€æ•°æ®è®¡æ•°å™¨ï¼Œåˆå§‹å€¼éƒ½å°†å…¶è®¾ç½®ä¸ºå¾…å‘é€æ•°æ®ä¸ªæ•°ï¼› huart1çš„æˆå‘˜å˜é‡hdmatxä¹Ÿä¸ºä¸€ä¸ªç»“æ„ä½“ï¼Œå…¶æˆå‘˜å˜é‡ä¸ºDMAç›¸å…³ä¸­æ–­çš„å‡½æ•°æŒ‡é’ˆï¼šXferCpltCallbackä¸ºDMAä¼ è¾“å®Œæˆå›è°ƒå‡½æ•°ï¼ŒXferHalfCpltCallbackä¸ºDMAåŠä¼ è¾“å®Œæˆå›è°ƒå‡½æ•°ï¼ŒXferErrorCallbackä¸ºDMAæ•…éšœå›è°ƒå‡½æ•°ï¼ŒXferAbortCallbackä¸ºDMAä¸­æ­¢å›è°ƒå‡½æ•°ï¼› é€šè¿‡HAL_DMA_Start_IT()ä½¿èƒ½DMAå‘é€é€šé“ï¼› æ¸…é™¤UARTå‘é€å®Œæˆä¸­æ–­æ ‡å¿—ä½TCï¼› ç½®ä½USARTx_CR3å¯„å­˜å™¨DMATä½ï¼Œä½¿èƒ½DMAå‘é€æ¨¡å¼ã€‚ &emsp;æ‰§è¡Œè¯¥å‡½æ•°åï¼ŒUARTå°†åŸºäºDMAæ¨¡å¼è¿›è¡Œå‘é€ã€‚ HAL_DMA_Start_IT()å®ç°&emsp;HAL_UART_Transmit_DMA()ä¸­è°ƒç”¨çš„æ ¸å¿ƒå‡½æ•°HAL_DMA_Start_IT()å®ç°å¦‚ä¸‹ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/** * @brief Start the DMA Transfer with interrupt enabled. * @param hdma pointer to a DMA_HandleTypeDef structure that contains * the configuration information for the specified DMA Stream. * @param SrcAddress The source memory Buffer address * @param DstAddress The destination memory Buffer address * @param DataLength The length of data to be transferred from source to destination * @retval HAL status */HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)&#123; HAL_StatusTypeDef status = HAL_OK; /* calculate DMA base and stream number */ DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma-&gt;StreamBaseAddress; /* Check the parameters */ assert_param(IS_DMA_BUFFER_SIZE(DataLength)); /* Process locked */ __HAL_LOCK(hdma); if(HAL_DMA_STATE_READY == hdma-&gt;State) &#123; /* Change DMA peripheral state */ hdma-&gt;State = HAL_DMA_STATE_BUSY; /* Initialize the error code */ hdma-&gt;ErrorCode = HAL_DMA_ERROR_NONE; /* Configure the source, destination address and the data length */ DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength); /* Clear all interrupt flags at correct offset within the register */ regs-&gt;IFCR = 0x3FU &lt;&lt; hdma-&gt;StreamIndex; /* Enable Common interrupts*/ hdma-&gt;Instance-&gt;CR |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME; hdma-&gt;Instance-&gt;FCR |= DMA_IT_FE; if(hdma-&gt;XferHalfCpltCallback != NULL) &#123; hdma-&gt;Instance-&gt;CR |= DMA_IT_HT; &#125; /* Enable the Peripheral */ __HAL_DMA_ENABLE(hdma); &#125; else &#123; /* Process unlocked */ __HAL_UNLOCK(hdma); /* Return error status */ status = HAL_BUSY; &#125; return status;&#125;/** * @brief Sets the DMA Transfer parameter. * @param hdma pointer to a DMA_HandleTypeDef structure that contains * the configuration information for the specified DMA Stream. * @param SrcAddress The source memory Buffer address * @param DstAddress The destination memory Buffer address * @param DataLength The length of data to be transferred from source to destination * @retval HAL status */static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)&#123; /* Clear DBM bit */ hdma-&gt;Instance-&gt;CR &amp;= (uint32_t)(~DMA_SxCR_DBM); /* Configure DMA Stream data length */ hdma-&gt;Instance-&gt;NDTR = DataLength; /* Memory to Peripheral */ if((hdma-&gt;Init.Direction) == DMA_MEMORY_TO_PERIPH) &#123; /* Configure DMA Stream destination address */ hdma-&gt;Instance-&gt;PAR = DstAddress; /* Configure DMA Stream source address */ hdma-&gt;Instance-&gt;M0AR = SrcAddress; &#125; /* Peripheral to Memory */ else &#123; /* Configure DMA Stream source address */ hdma-&gt;Instance-&gt;PAR = SrcAddress; /* Configure DMA Stream destination address */ hdma-&gt;Instance-&gt;M0AR = DstAddress; &#125;&#125;/** * @brief Enable the specified DMA Stream. * @param __HANDLE__ DMA handle * @retval None */#define __HAL_DMA_ENABLE(__HANDLE__) ((__HANDLE__)-&gt;Instance-&gt;CR |= DMA_SxCR_EN) &emsp;è¯¥å‡½æ•°å®ç°çš„åŠŸèƒ½ä¸ºï¼š æ£€æŸ¥DMAå‘é€æ•°æ®é•¿åº¦æ˜¯å¦åˆç†ï¼Œåœ¨1~65535èŒƒå›´å†…å‡å¯ï¼› é€šè¿‡DMA_SetConfig()å‡½æ•°è®¾ç½®DMAå‘é€çš„DMAæ•°æ®æµã€æ•°æ®é¡¹æ•°ç›®ï¼Œè®¾ç½®å¤–è®¾åœ°å€ä¸ºç›®æ ‡åœ°å€ï¼Œè®¾ç½®å­˜å‚¨å™¨åœ°å€ä¸ºæºåœ°å€ï¼› æ¸…ç©ºDMAæ•°æ®æµç›¸å…³ä¸­æ–­æ ‡å¿—ä½ï¼› ç½®ä½DMAé…ç½®å¯„å­˜å™¨DMA_SxCR TCIEã€TEIEã€DMEIEä½ï¼Œåˆ†åˆ«ä½¿èƒ½ä¼ è¾“å®Œæˆä¸­æ–­ã€ä¼ è¾“é”™è¯¯ä¸­æ–­ä¸ç›´æ¥æ¨¡å¼é”™è¯¯ä¸­æ–­ï¼› ç½®ä½DMA FIFOæ§åˆ¶å¯„å­˜å™¨FEIEä½ï¼Œä½¿èƒ½FIFOé”™è¯¯ä¸­æ–­ï¼›æœ¬ä¾‹ä¸­æœªä½¿èƒ½FIFOï¼› XferHalfCpltCallbackä¸ºDMAåŠä¼ è¾“å®Œæˆå›è°ƒå‡½æ•°ï¼Œå…¶ä¸ä¸ºNULLæ—¶ä½¿èƒ½DMAåŠä¼ è¾“å®Œæˆä¸­æ–­ï¼› ç½®ä½DMA_SxCRå¯„å­˜å™¨ENä½ï¼Œä½¿èƒ½DMAæ•°æ®æµï¼Œéšå³å¼€å§‹DMAä¼ è¾“ã€‚ DMAä¸­æ–­æœåŠ¡å‡½æ•°&emsp;DMAä¸­æ–­æœåŠ¡å‡½æ•°å¦‚ä¸‹æ‰€ç¤ºã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230/*** @brief This function handles DMA2 stream7 global interrupt.*/void DMA2_Stream7_IRQHandler(void)&#123; /* USER CODE BEGIN DMA2_Stream7_IRQn 0 */ /* USER CODE END DMA2_Stream7_IRQn 0 */ HAL_DMA_IRQHandler(&amp;hdma_usart1_tx); /* USER CODE BEGIN DMA2_Stream7_IRQn 1 */ /* USER CODE END DMA2_Stream7_IRQn 1 */&#125;/** * @brief Handles DMA interrupt request. * @param hdma pointer to a DMA_HandleTypeDef structure that contains * the configuration information for the specified DMA Stream. * @retval None */void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)&#123; uint32_t tmpisr; __IO uint32_t count = 0; uint32_t timeout = SystemCoreClock / 9600; /* calculate DMA base and stream number */ DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma-&gt;StreamBaseAddress; tmpisr = regs-&gt;ISR; /* Transfer Error Interrupt management ***************************************/ if ((tmpisr &amp; (DMA_FLAG_TEIF0_4 &lt;&lt; hdma-&gt;StreamIndex)) != RESET) &#123; if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET) &#123; /* Disable the transfer error interrupt */ hdma-&gt;Instance-&gt;CR &amp;= ~(DMA_IT_TE); /* Clear the transfer error flag */ regs-&gt;IFCR = DMA_FLAG_TEIF0_4 &lt;&lt; hdma-&gt;StreamIndex; /* Update error code */ hdma-&gt;ErrorCode |= HAL_DMA_ERROR_TE; &#125; &#125; /* FIFO Error Interrupt management ******************************************/ if ((tmpisr &amp; (DMA_FLAG_FEIF0_4 &lt;&lt; hdma-&gt;StreamIndex)) != RESET) &#123; if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET) &#123; /* Clear the FIFO error flag */ regs-&gt;IFCR = DMA_FLAG_FEIF0_4 &lt;&lt; hdma-&gt;StreamIndex; /* Update error code */ hdma-&gt;ErrorCode |= HAL_DMA_ERROR_FE; &#125; &#125; /* Direct Mode Error Interrupt management ***********************************/ if ((tmpisr &amp; (DMA_FLAG_DMEIF0_4 &lt;&lt; hdma-&gt;StreamIndex)) != RESET) &#123; if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET) &#123; /* Clear the direct mode error flag */ regs-&gt;IFCR = DMA_FLAG_DMEIF0_4 &lt;&lt; hdma-&gt;StreamIndex; /* Update error code */ hdma-&gt;ErrorCode |= HAL_DMA_ERROR_DME; &#125; &#125; /* Half Transfer Complete Interrupt management ******************************/ if ((tmpisr &amp; (DMA_FLAG_HTIF0_4 &lt;&lt; hdma-&gt;StreamIndex)) != RESET) &#123; if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET) &#123; /* Clear the half transfer complete flag */ regs-&gt;IFCR = DMA_FLAG_HTIF0_4 &lt;&lt; hdma-&gt;StreamIndex; /* Multi_Buffering mode enabled */ if(((hdma-&gt;Instance-&gt;CR) &amp; (uint32_t)(DMA_SxCR_DBM)) != RESET) &#123; /* Current memory buffer used is Memory 0 */ if((hdma-&gt;Instance-&gt;CR &amp; DMA_SxCR_CT) == RESET) &#123; if(hdma-&gt;XferHalfCpltCallback != NULL) &#123; /* Half transfer callback */ hdma-&gt;XferHalfCpltCallback(hdma); &#125; &#125; /* Current memory buffer used is Memory 1 */ else &#123; if(hdma-&gt;XferM1HalfCpltCallback != NULL) &#123; /* Half transfer callback */ hdma-&gt;XferM1HalfCpltCallback(hdma); &#125; &#125; &#125; else &#123; /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */ if((hdma-&gt;Instance-&gt;CR &amp; DMA_SxCR_CIRC) == RESET) &#123; /* Disable the half transfer interrupt */ hdma-&gt;Instance-&gt;CR &amp;= ~(DMA_IT_HT); &#125; if(hdma-&gt;XferHalfCpltCallback != NULL) &#123; /* Half transfer callback */ hdma-&gt;XferHalfCpltCallback(hdma); &#125; &#125; &#125; &#125; /* Transfer Complete Interrupt management ***********************************/ if ((tmpisr &amp; (DMA_FLAG_TCIF0_4 &lt;&lt; hdma-&gt;StreamIndex)) != RESET) &#123; if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET) &#123; /* Clear the transfer complete flag */ regs-&gt;IFCR = DMA_FLAG_TCIF0_4 &lt;&lt; hdma-&gt;StreamIndex; if(HAL_DMA_STATE_ABORT == hdma-&gt;State) &#123; /* Disable all the transfer interrupts */ hdma-&gt;Instance-&gt;CR &amp;= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME); hdma-&gt;Instance-&gt;FCR &amp;= ~(DMA_IT_FE); if((hdma-&gt;XferHalfCpltCallback != NULL) || (hdma-&gt;XferM1HalfCpltCallback != NULL)) &#123; hdma-&gt;Instance-&gt;CR &amp;= ~(DMA_IT_HT); &#125; /* Clear all interrupt flags at correct offset within the register */ regs-&gt;IFCR = 0x3FU &lt;&lt; hdma-&gt;StreamIndex; /* Process Unlocked */ __HAL_UNLOCK(hdma); /* Change the DMA state */ hdma-&gt;State = HAL_DMA_STATE_READY; if(hdma-&gt;XferAbortCallback != NULL) &#123; hdma-&gt;XferAbortCallback(hdma); &#125; return; &#125; if(((hdma-&gt;Instance-&gt;CR) &amp; (uint32_t)(DMA_SxCR_DBM)) != RESET) &#123; /* Current memory buffer used is Memory 0 */ if((hdma-&gt;Instance-&gt;CR &amp; DMA_SxCR_CT) == RESET) &#123; if(hdma-&gt;XferM1CpltCallback != NULL) &#123; /* Transfer complete Callback for memory1 */ hdma-&gt;XferM1CpltCallback(hdma); &#125; &#125; /* Current memory buffer used is Memory 1 */ else &#123; if(hdma-&gt;XferCpltCallback != NULL) &#123; /* Transfer complete Callback for memory0 */ hdma-&gt;XferCpltCallback(hdma); &#125; &#125; &#125; /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */ else &#123; if((hdma-&gt;Instance-&gt;CR &amp; DMA_SxCR_CIRC) == RESET) &#123; /* Disable the transfer complete interrupt */ hdma-&gt;Instance-&gt;CR &amp;= ~(DMA_IT_TC); /* Process Unlocked */ __HAL_UNLOCK(hdma); /* Change the DMA state */ hdma-&gt;State = HAL_DMA_STATE_READY; &#125; if(hdma-&gt;XferCpltCallback != NULL) &#123; /* Transfer complete callback */ hdma-&gt;XferCpltCallback(hdma); &#125; &#125; &#125; &#125; /* manage error case */ if(hdma-&gt;ErrorCode != HAL_DMA_ERROR_NONE) &#123; if((hdma-&gt;ErrorCode &amp; HAL_DMA_ERROR_TE) != RESET) &#123; hdma-&gt;State = HAL_DMA_STATE_ABORT; /* Disable the stream */ __HAL_DMA_DISABLE(hdma); do &#123; if (++count &gt; timeout) &#123; break; &#125; &#125; while((hdma-&gt;Instance-&gt;CR &amp; DMA_SxCR_EN) != RESET); /* Process Unlocked */ __HAL_UNLOCK(hdma); /* Change the DMA state */ hdma-&gt;State = HAL_DMA_STATE_READY; &#125; if(hdma-&gt;XferErrorCallback != NULL) &#123; /* Transfer error callback */ hdma-&gt;XferErrorCallback(hdma); &#125; &#125;&#125; &emsp;è¯¥å‡½æ•°ä¸­ä¸»è¦å…³æ³¨åŠä¼ è¾“å®Œæˆä¸­æ–­ä»¥åŠä¼ è¾“å®Œæˆä¸­æ–­ã€‚ &emsp;å¯¹äºåŠä¼ è¾“å®Œæˆä¸­æ–­ç›¸å…³å‡½æ•°ï¼Œå…¶ä¸»è¦åŠŸèƒ½æœ‰ï¼š æ¸…é™¤åŠä¼ è¾“å®Œæˆä¸­æ–­æ ‡å¿—ä½ï¼› DMA_SxCRå¯„å­˜å™¨DBMä½ä¸ºå¤ä½çŠ¶æ€ï¼ŒåŒç¼“å†²å™¨æ¨¡å¼æœªä½¿èƒ½ï¼› DMA_SxCRå¯„å­˜å™¨CIRCä½ä¸ºå¤ä½çŠ¶æ€ï¼Œå¾ªç¯æ¨¡å¼ä¸ºç¦æ­¢çŠ¶æ€ï¼›ç¦ç”¨DMAåŠä¼ è¾“ä¸­æ–­ï¼› æœ¬ä¾‹ä¸­åŠä¼ è¾“å®Œæˆä¸­æ–­å›è°ƒå‡½æ•°ä¸ºç©ºå‡½æ•°ï¼Œä¸æ‰§è¡Œä»»ä½•æ“ä½œã€‚ &emsp;å¯¹äºä¼ è¾“å®Œæˆä¸­æ–­ç›¸å…³å‡½æ•°ï¼Œå…¶ä¸»è¦åŠŸèƒ½æœ‰ï¼š æ¸…é™¤ä¼ è¾“å®Œæˆä¸­æ–­æ ‡å¿—ä½ï¼› å¦‚æœDMAçŠ¶æ€ä¸ºABORTï¼Œç¦ç”¨æ‰€æœ‰DMAä¸­æ–­ï¼Œæ¸…é™¤æ‰€æœ‰ä¸­æ–­æ ‡å¿—ä½ï¼Œå¹¶è°ƒç”¨ABORTå›è°ƒå‡½æ•°ï¼› DMA_SxCRå¯„å­˜å™¨DBMä½ä¸ºå¤ä½çŠ¶æ€ï¼ŒåŒç¼“å†²å™¨æ¨¡å¼æœªä½¿èƒ½ï¼› DMA_SxCRå¯„å­˜å™¨CIRCä½ä¸ºå¤ä½çŠ¶æ€ï¼Œå¾ªç¯æ¨¡å¼ä¸ºç¦æ­¢çŠ¶æ€ï¼› è°ƒç”¨ä¼ è¾“å®Œæˆä¸­æ–­å›è°ƒå‡½æ•°UART_DMATransmitCplt()ï¼Œè¯¥å‡½æ•°å…·ä½“å¦‚ä¸‹ã€‚ 123456789101112131415161718192021222324252627/** * @brief DMA UART transmit process complete callback * @param hdma DMA handle * @retval None */static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)&#123; UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)-&gt;Parent; /* DMA Normal mode*/ if((hdma-&gt;Instance-&gt;CR &amp; DMA_SxCR_CIRC) == 0U) &#123; huart-&gt;TxXferCount = 0U; /* Disable the DMA transfer for transmit request by setting the DMAT bit in the UART CR3 register */ CLEAR_BIT(huart-&gt;Instance-&gt;CR3, USART_CR3_DMAT); /* Enable the UART Transmit Complete Interrupt */ SET_BIT(huart-&gt;Instance-&gt;CR1, USART_CR1_TCIE); &#125; /* DMA Circular mode */ else &#123; HAL_UART_TxCpltCallback(huart); &#125;&#125; &emsp;UART_DMATransmitCplt()çš„åŠŸèƒ½å¦‚ä¸‹ï¼š æœ¬ä¾‹ä¸­DMAæ¨¡å¼ä¸ºNormalï¼› DMAå‘é€è®¡æ•°å™¨ç½®é›¶ï¼› ç¦æ­¢DMAå‘é€æ¨¡å¼ï¼› é€šè¿‡ç½®ä½USARTx_CR1å¯„å­˜å™¨TCIEä½ï¼Œè½¯ä»¶äº§ç”Ÿä¸€ä¸ªUARTä¼ è¾“å®Œæˆä¸­æ–­ã€‚ UARTä¸­æ–­æœåŠ¡å‡½æ•°&emsp;UARTä¸­æ–­æœåŠ¡å‡½æ•°å¦‚ä¸‹æ‰€ç¤ºã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185/*** @brief This function handles USART1 global interrupt.*/void USART1_IRQHandler(void)&#123; /* USER CODE BEGIN USART1_IRQn 0 */ /* USER CODE END USART1_IRQn 0 */ HAL_UART_IRQHandler(&amp;huart1); /* USER CODE BEGIN USART1_IRQn 1 */ /* USER CODE END USART1_IRQn 1 */&#125;/** * @brief This function handles UART interrupt request. * @param huart uart handle * @retval None */void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)&#123; uint32_t isrflags = READ_REG(huart-&gt;Instance-&gt;ISR); uint32_t cr1its = READ_REG(huart-&gt;Instance-&gt;CR1); uint32_t cr3its = READ_REG(huart-&gt;Instance-&gt;CR3); uint32_t errorflags; /* If no error occurs */ errorflags = (isrflags &amp; (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE)); if (errorflags == RESET) &#123; /* UART in mode Receiver ---------------------------------------------------*/ if(((isrflags &amp; USART_ISR_RXNE) != RESET) &amp;&amp; ((cr1its &amp; USART_CR1_RXNEIE) != RESET)) &#123; UART_Receive_IT(huart); return; &#125; &#125; /* If some errors occur */ if( (errorflags != RESET) &amp;&amp; ( ((cr3its &amp; USART_CR3_EIE) != RESET) || ((cr1its &amp; (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)) ) &#123; /* UART parity error interrupt occurred -------------------------------------*/ if(((isrflags &amp; USART_ISR_PE) != RESET) &amp;&amp; ((cr1its &amp; USART_CR1_PEIE) != RESET)) &#123; __HAL_UART_CLEAR_IT(huart, UART_CLEAR_PEF); huart-&gt;ErrorCode |= HAL_UART_ERROR_PE; &#125; /* UART frame error interrupt occurred --------------------------------------*/ if(((isrflags &amp; USART_ISR_FE) != RESET) &amp;&amp; ((cr3its &amp; USART_CR3_EIE) != RESET)) &#123; __HAL_UART_CLEAR_IT(huart, UART_CLEAR_FEF); huart-&gt;ErrorCode |= HAL_UART_ERROR_FE; &#125; /* UART noise error interrupt occurred --------------------------------------*/ if(((isrflags &amp; USART_ISR_NE) != RESET) &amp;&amp; ((cr3its &amp; USART_CR3_EIE) != RESET)) &#123; __HAL_UART_CLEAR_IT(huart, UART_CLEAR_NEF); huart-&gt;ErrorCode |= HAL_UART_ERROR_NE; &#125; /* UART Over-Run interrupt occurred -----------------------------------------*/ if(((isrflags &amp; USART_ISR_ORE) != RESET) &amp;&amp; (((cr1its &amp; USART_CR1_RXNEIE) != RESET) || ((cr3its &amp; USART_CR3_EIE) != RESET))) &#123; __HAL_UART_CLEAR_IT(huart, UART_CLEAR_OREF); huart-&gt;ErrorCode |= HAL_UART_ERROR_ORE; &#125; /* Call UART Error Call back function if need be --------------------------*/ if(huart-&gt;ErrorCode != HAL_UART_ERROR_NONE) &#123; /* UART in mode Receiver ---------------------------------------------------*/ if(((isrflags &amp; USART_ISR_RXNE) != RESET) &amp;&amp; ((cr1its &amp; USART_CR1_RXNEIE) != RESET)) &#123; UART_Receive_IT(huart); &#125; /* If Overrun error occurs, or if any error occurs in DMA mode reception, consider error as blocking */ if (((huart-&gt;ErrorCode &amp; HAL_UART_ERROR_ORE) != RESET) || (HAL_IS_BIT_SET(huart-&gt;Instance-&gt;CR3, USART_CR3_DMAR))) &#123; /* Blocking error : transfer is aborted Set the UART state ready to be able to start again the process, Disable Rx Interrupts, and disable Rx DMA request, if ongoing */ UART_EndRxTransfer(huart); /* Disable the UART DMA Rx request if enabled */ if (HAL_IS_BIT_SET(huart-&gt;Instance-&gt;CR3, USART_CR3_DMAR)) &#123; CLEAR_BIT(huart-&gt;Instance-&gt;CR3, USART_CR3_DMAR); /* Abort the UART DMA Rx channel */ if(huart-&gt;hdmarx != NULL) &#123; /* Set the UART DMA Abort callback : will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */ huart-&gt;hdmarx-&gt;XferAbortCallback = UART_DMAAbortOnError; /* Abort DMA RX */ if(HAL_DMA_Abort_IT(huart-&gt;hdmarx) != HAL_OK) &#123; /* Call Directly huart-&gt;hdmarx-&gt;XferAbortCallback function in case of error */ huart-&gt;hdmarx-&gt;XferAbortCallback(huart-&gt;hdmarx); &#125; &#125; else &#123; /* Call user error callback */ HAL_UART_ErrorCallback(huart); &#125; &#125; else &#123; /* Call user error callback */ HAL_UART_ErrorCallback(huart); &#125; &#125; else &#123; /* Non Blocking error : transfer could go on. Error is notified to user through user error callback */ HAL_UART_ErrorCallback(huart); huart-&gt;ErrorCode = HAL_UART_ERROR_NONE; &#125; &#125; return; &#125; /* End if some error occurs */ /* UART in mode Transmitter ------------------------------------------------*/ if(((isrflags &amp; USART_ISR_TXE) != RESET) &amp;&amp; ((cr1its &amp; USART_CR1_TXEIE) != RESET)) &#123; UART_Transmit_IT(huart); return; &#125; /* UART in mode Transmitter (transmission end) -----------------------------*/ if(((isrflags &amp; USART_ISR_TC) != RESET) &amp;&amp; ((cr1its &amp; USART_CR1_TCIE) != RESET)) &#123; UART_EndTransmit_IT(huart); return; &#125;&#125;/** * @brief Wrap up transmission in non-blocking mode. * @param huart pointer to a UART_HandleTypeDef structure that contains * the configuration information for the specified UART module. * @retval HAL status */static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)&#123; /* Disable the UART Transmit Complete Interrupt */ CLEAR_BIT(huart-&gt;Instance-&gt;CR1, USART_CR1_TCIE); /* Tx process is ended, restore huart-&gt;gState to Ready */ huart-&gt;gState = HAL_UART_STATE_READY; HAL_UART_TxCpltCallback(huart); return HAL_OK;&#125;/** * @brief Tx Transfer completed callbacks * @param huart uart handle * @retval None */extern uint8_t uartReady;void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)&#123; uartReady = 1;&#125; &emsp;è¿™é‡Œä¸»è¦å…³æ³¨ä¸­æ–­ä¼ è¾“å®Œæˆä¸­æ–­ï¼š TCè½¯ä»¶ç½®ä½äº§ç”Ÿçš„ä¸­æ–­ä¼ è¾“å®Œæˆä¸­æ–­ä¸­è°ƒç”¨UART_EndTransmit_IT()å‡½æ•°ï¼› UART_EndTransmit_IT()å‡½æ•°å¤ä½USARTx_CR1å¯„å­˜å™¨TCIEä½ï¼Œç¦æ­¢ä¼ è¾“å®Œæˆä¸­æ–­ï¼›ç»§è€Œè°ƒç”¨HAL_UART_TxCpltCallback()å‡½æ•°ï¼› HAL_UART_TxCpltCallback()å‡½æ•°ä¸ºè‡ªå®šä¹‰å‡½æ•°ã€‚ å®éªŒéªŒè¯&emsp;éªŒè¯ç¨‹åºè®¾ç½®å¦‚ä¸‹ï¼š 12345678910111213141516uint8 sendStr[65535] = \"1234567890\";uint8 uartReady = 1;while (1)&#123; mainloop++; oled_putuint32(0, 2, mainloop); oled_putuint32(0, 3, __HAL_DMA_GET_COUNTER(&amp;hdma_usart1_tx)); if (uartReady == TRUE) &#123; uartReady = FALSE; test = HAL_UART_Transmit_DMA(&amp;huart1,sendStr,sizeof(sendStr)); &#125; &#125; &emsp;å…¶åŸºæœ¬åŸç†ä¸ºè°ƒç”¨HAL_UART_Transmit_DMA()å‡½æ•°è¿›è¡Œå‘é€ï¼ŒåŒæ—¶é€šè¿‡__HAL_DMA_GET_COUNTER()è·å–DMAæ•°æ®æµä¼ è¾“ä¸­çš„å‰©ä½™æ•°æ®æ•°ç›®å¹¶å®æ—¶æ˜¾ç¤ºã€‚å½“DMAå‘é€å®Œæˆå¹¶é€šè¿‡TCä¸ºè§¦å‘UARTä¸­æ–­åï¼Œå°†uartReadyç½®ä½ï¼Œæ­¤æ—¶å¯ä»¥è¿›è¡Œæ–°ä¸€è½®DMAä¼ è¾“ã€‚ &emsp;å®éªŒç»“æœä¸ºï¼šOLEDæ˜¾ç¤ºå™¨å®æ—¶æ˜¾ç¤ºDMAæ•°æ®æµä¼ è¾“çš„å‰©ä½™æ•°æ®æ•°ç›®ï¼›ä¸²å£æ¥æ”¶è½¯ä»¶å¯ä»¥æ¥æ”¶åˆ°å‘é€çš„æ•°æ®(ä½†æ˜¯ç”±äºæ•°æ®æµé€Ÿç‡è¿‡é«˜ï¼Œä¸²å£è½¯ä»¶æœ‰æ—¶æ— æ³•æ­£å¸¸æ˜¾ç¤º)ã€‚","categories":[{"name":"åµŒå…¥å¼","slug":"åµŒå…¥å¼","permalink":"http://jiaodi.tech/categories/åµŒå…¥å¼/"}],"tags":[{"name":"STM32F7","slug":"STM32F7","permalink":"http://jiaodi.tech/tags/STM32F7/"},{"name":"DMA","slug":"DMA","permalink":"http://jiaodi.tech/tags/DMA/"}]},{"title":"STM32F767 PWMçš„åŸºæœ¬ç”¨æ³•","slug":"stm32f767-pwm","date":"2018-05-07T12:18:11.000Z","updated":"2018-05-12T16:28:42.383Z","comments":true,"path":"2018/05/07/stm32f767-pwm/","link":"","permalink":"http://jiaodi.tech/2018/05/07/stm32f767-pwm/","excerpt":"&emsp;æœ¬æ–‡ä»‹ç»STM32F767 PWMçš„åŸºæœ¬ç”¨æ³•ã€‚","text":"&emsp;æœ¬æ–‡ä»‹ç»STM32F767 PWMçš„åŸºæœ¬ç”¨æ³•ã€‚ å¼€å‘ç¯å¢ƒç¡¬ä»¶ç¯å¢ƒ ç”µè„‘ï¼šWindows 10 Home x64 Apollo STM32F767å¼€å‘æ¿(ST-LINK V2ä»¿çœŸå™¨) è½¯ä»¶ç¯å¢ƒ Keil Version 5.24.1 (Pack Installerï¼šKeil.STM32F7xx_DFP.2.9.0.pack) STM32CubeMX Version 4.25.0(Packages Managerï¼šSTM32CubeF7) TIM1ä¸»è¦ç‰¹æ€§&emsp;TIM1/TIM8ä¸ºé«˜çº§æ§åˆ¶å®šæ—¶å™¨ï¼Œæ”¯æŒçš„PWMåŠŸèƒ½æœ€ä¸ºå®Œå–„ã€‚æœ¬ä¾‹å°†ä½¿ç”¨TIM1å®ŒæˆPWMå®éªŒï¼šè¾“å‡º3å¯¹äº’è¡¥å¹¶å¸¦æœ‰æ­»åŒºçš„PWMã€‚ ç³»ç»Ÿæ¡†å›¾ ä¸»è¦ç‰¹æ€§&emsp;æœ¬æ¬¡ä¸»è¦åˆ—å‡ºPWMçš„ç›¸å…³ç‰¹æ€§ã€‚ å¤šè¾¾6ä¸ªç‹¬ç«‹é€šé“ï¼Œå¯ä»¥ç”¨äºPWMç”Ÿæˆ(è¾¹æ²¿ä¸ä¸­å¿ƒå¯¹é½æ¨¡å¼)ï¼› å¸¦å¯ç¼–ç¨‹æ­»åŒºçš„äº’è¡¥è¾“å‡ºï¼› 2ä¸ªæ–­è·¯è¾“å‡ºï¼Œç”¨äºå°†å®šæ—¶å™¨çš„è¾“å‡ºä¿¡å·ç½®äºç”¨æˆ·å¯é€‰çš„å®‰å…¨é…ç½®ä¸­ã€‚ PWMçš„åŸºæœ¬ç”¨æ³•PWMå‚æ•°è®¾ç½®&emsp;PWMçš„åˆå§‹åŒ–ä»£ç æ€»ä½“å¦‚ä¸‹æ‰€ç¤ºã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/* TIM1 init function */void MX_TIM1_Init(void)&#123; TIM_ClockConfigTypeDef sClockSourceConfig; TIM_MasterConfigTypeDef sMasterConfig; TIM_OC_InitTypeDef sConfigOC; TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig; htim1.Instance = TIM1; htim1.Init.Prescaler = 216-1; htim1.Init.CounterMode = TIM_COUNTERMODE_UP; htim1.Init.Period = 100-1; htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1; htim1.Init.RepetitionCounter = 0; htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE; if (HAL_TIM_Base_Init(&amp;htim1) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL; if (HAL_TIM_ConfigClockSource(&amp;htim1, &amp;sClockSourceConfig) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; if (HAL_TIM_PWM_Init(&amp;htim1) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET; sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET; sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE; if (HAL_TIMEx_MasterConfigSynchronization(&amp;htim1, &amp;sMasterConfig) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; sConfigOC.OCMode = TIM_OCMODE_PWM1; sConfigOC.Pulse = 20; sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH; sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH; sConfigOC.OCFastMode = TIM_OCFAST_DISABLE; sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET; sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET; if (HAL_TIM_PWM_ConfigChannel(&amp;htim1, &amp;sConfigOC, TIM_CHANNEL_1) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; sConfigOC.Pulse = 30; if (HAL_TIM_PWM_ConfigChannel(&amp;htim1, &amp;sConfigOC, TIM_CHANNEL_2) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; sConfigOC.Pulse = 40; sConfigOC.OCPolarity = TIM_OCPOLARITY_LOW; sConfigOC.OCNPolarity = TIM_OCPOLARITY_LOW; if (HAL_TIM_PWM_ConfigChannel(&amp;htim1, &amp;sConfigOC, TIM_CHANNEL_3) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE; sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE; sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF; sBreakDeadTimeConfig.DeadTime = 100; sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE; sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH; sBreakDeadTimeConfig.BreakFilter = 0; sBreakDeadTimeConfig.Break2State = TIM_BREAK2_DISABLE; sBreakDeadTimeConfig.Break2Polarity = TIM_BREAK2POLARITY_HIGH; sBreakDeadTimeConfig.Break2Filter = 0; sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE; if (HAL_TIMEx_ConfigBreakDeadTime(&amp;htim1, &amp;sBreakDeadTimeConfig) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; HAL_TIM_MspPostInit(&amp;htim1);&#125; &emsp;ä»¥ä¸‹å°†å¯¹ä»£ç è¿›è¡Œåˆ†æã€‚ æ—¶åŸºåˆå§‹åŒ–&emsp;æ—¶åŸºåˆå§‹åŒ–å‡½æ•°å¦‚ä¸‹æ‰€ç¤ºã€‚ 1234567891011htim1.Instance = TIM1;htim1.Init.Prescaler = 216-1;htim1.Init.CounterMode = TIM_COUNTERMODE_UP;htim1.Init.Period = 100-1;htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;htim1.Init.RepetitionCounter = 0;htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;if (HAL_TIM_Base_Init(&amp;htim1) != HAL_OK)&#123; _Error_Handler(__FILE__, __LINE__);&#125; &emsp;æ—¶åŸºå•å…ƒçš„åˆå§‹åŒ–åœ¨timerå®éªŒä¸­å·²ç»ä»‹ç»ï¼Œè¿™é‡Œä¸å†å™è¿°ï¼Œå…¶åŠŸèƒ½å¦‚ä¸‹ï¼š TIM1ä½¿ç”¨APB2æ—¶é’Ÿï¼Œæœ¬ä¾‹ä¸­APB2æ—¶é’Ÿé¢‘ç‡ä¸º216MHzï¼› å®šæ—¶å™¨å‘¨æœŸå€¼ä¸º100-1ï¼Œåˆ™ä¸€ä¸ªå‘¨æœŸå†…å…±è®¡æ•°100æ¬¡ï¼› å®šæ—¶å™¨é¢„åˆ†é¢‘å™¨å€¼ä¸º216-1ï¼Œåˆ™æ—¶é’Ÿé¢‘ç‡ä¸º1MHzï¼› å®šæ—¶å™¨æ—¶é’Ÿé¢‘ç‡ä¸º1MHzï¼Œè®¡æ•°å€¼ä¸º100ï¼Œåˆ™å®šæ—¶å™¨å‘¨æœŸ/PWMé¢‘ç‡ä¸º10kHzï¼› TIMx_CR1å¯„å­˜å™¨CKDä½ä¸º0ï¼Œåˆ™æ­»åŒºæ—¶é’Ÿç›¸å¯¹äºTIMè¾“å…¥æ—¶é’Ÿä¸åˆ†é¢‘ã€‚ æ—¶é’Ÿæºé€‰æ‹©&emsp;æ—¶é’Ÿæºçš„é€‰æ‹©é€šè¿‡å¦‚ä¸‹å‡½æ•°å®ç°ã€‚æœ¬ä¾‹ä¸­æ—¶é’Ÿé€‰æ‹©ä¸ºå†…éƒ¨æ—¶é’Ÿï¼Œå³å°†TIMx_SMCRå¯„å­˜å™¨SMSæ§åˆ¶ä½è®¾ç½®ä¸º0000ã€‚ 12345sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;if (HAL_TIM_ConfigClockSource(&amp;htim1, &amp;sClockSourceConfig) != HAL_OK)&#123; _Error_Handler(__FILE__, __LINE__);&#125; PWMåˆå§‹åŒ–&emsp;PWMåˆå§‹åŒ–ä»£ç å¦‚ä¸‹æ‰€ç¤ºã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657if (HAL_TIM_PWM_Init(&amp;htim1) != HAL_OK)&#123; _Error_Handler(__FILE__, __LINE__);&#125;/** * @brief Initializes the TIM PWM Time Base according to the specified * parameters in the TIM_HandleTypeDef and create the associated handle. * @param htim pointer to a TIM_HandleTypeDef structure that contains * the configuration information for TIM module. * @retval HAL status */HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)&#123; /* Check the TIM handle allocation */ if(htim == NULL) &#123; return HAL_ERROR; &#125; /* Check the parameters */ assert_param(IS_TIM_INSTANCE(htim-&gt;Instance)); assert_param(IS_TIM_COUNTER_MODE(htim-&gt;Init.CounterMode)); assert_param(IS_TIM_CLOCKDIVISION_DIV(htim-&gt;Init.ClockDivision)); assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim-&gt;Init.AutoReloadPreload)); if(htim-&gt;State == HAL_TIM_STATE_RESET) &#123; /* Allocate lock resource and initialize it */ htim-&gt;Lock = HAL_UNLOCKED;#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1) /* Reset interrupt callbacks to legacy week callbacks */ TIM_ResetCallback(htim); if(htim-&gt;PWM_MspInitCallback == NULL) &#123; htim-&gt;PWM_MspInitCallback = HAL_TIM_PWM_MspInit; &#125; /* Init the low level hardware : GPIO, CLOCK, NVIC */ htim-&gt;PWM_MspInitCallback(htim);#else /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */ HAL_TIM_PWM_MspInit(htim);#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */ &#125; /* Set the TIM state */ htim-&gt;State= HAL_TIM_STATE_BUSY; /* Init the base time for the PWM */ TIM_Base_SetConfig(htim-&gt;Instance, &amp;htim-&gt;Init); /* Initialize the TIM state*/ htim-&gt;State= HAL_TIM_STATE_READY; return HAL_OK;&#125; &emsp;å®é™…ä¸Šè¯¥å‡½æ•°å¹¶æ— å®é™…æ„ä¹‰ã€‚ htim-&gt;Stateåœ¨TIMæ—¶åŸºåˆå§‹åŒ–ä¸­å·²ç»æ›´æ”¹ä¸ºHAL_TIM_STATE_READYï¼Œæ‰€ä»¥åˆ¤å®šæ¡ä»¶ä»¥å†…å‡½æ•°ä¸æ‰§è¡Œï¼› TIM_Base_SetConfig()å‡½æ•°å·²ç»åœ¨HAL_TIM_Base_Init()ä¸­é¦–æ¬¡è°ƒç”¨ï¼Œè¿™é‡Œä¸ºäºŒæ¬¡è°ƒç”¨ï¼Œè¿™æœŸé—´æ—¶åŸºé…ç½®å¹¶æœªè¿›è¡Œä»»ä½•æ›´æ–°ã€‚ ä¸»æ¨¡å¼è®¾ç½®&emsp;ä¸»æ¨¡å¼è®¾ç½®ä»£ç å¦‚ä¸‹æ‰€ç¤ºã€‚ 1234567sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;if (HAL_TIMEx_MasterConfigSynchronization(&amp;htim1, &amp;sMasterConfig) != HAL_OK)&#123; _Error_Handler(__FILE__, __LINE__);&#125; &emsp;TIM1çš„ä¸»æ¨¡å¼è¾“å‡ºå‡ä¸ºRESETçŠ¶æ€ï¼Œå³åªèƒ½é€šè¿‡å¯„å­˜å™¨TIMx_EGRçš„UGä½ç”Ÿæˆæ›´æ–°äº‹ä»¶ã€‚TIM1ä¸è¿›è¡Œä¸»ä»æ¨¡å¼æ§åˆ¶ã€‚ PWMé€šé“é…ç½®&emsp;PWMé€šé“é…ç½®ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼Œè¿™é‡Œä»¥channel1ä¸ºä¾‹ã€‚ 12345678910111213141516171819202122232425sConfigOC.OCMode = TIM_OCMODE_PWM1;sConfigOC.Pulse = 20;sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;if (HAL_TIM_PWM_ConfigChannel(&amp;htim1, &amp;sConfigOC, TIM_CHANNEL_1) != HAL_OK)&#123; _Error_Handler(__FILE__, __LINE__);&#125;sConfigOC.Pulse = 30;if (HAL_TIM_PWM_ConfigChannel(&amp;htim1, &amp;sConfigOC, TIM_CHANNEL_2) != HAL_OK)&#123; _Error_Handler(__FILE__, __LINE__);&#125;sConfigOC.Pulse = 40;sConfigOC.OCPolarity = TIM_OCPOLARITY_LOW;sConfigOC.OCNPolarity = TIM_OCPOLARITY_LOW;if (HAL_TIM_PWM_ConfigChannel(&amp;htim1, &amp;sConfigOC, TIM_CHANNEL_3) != HAL_OK)&#123; _Error_Handler(__FILE__, __LINE__);&#125; &emsp;åˆå§‹åŒ–ä»£ç é…ç½®äº†PWMçš„åŸºæœ¬å‚æ•°ï¼š æ¨¡å¼ä¸ºTIM_OCMODE_PWM1ï¼› è„‰å†²å®½åº¦ä¸º20ï¼Œè€ƒè™‘åˆ°å‘¨æœŸå€¼ä¸º100ï¼Œå¦‚æœä¸è€ƒè™‘æ­»åŒºå³å ç©ºæ¯”ä¸º20%ï¼› OCä¸OCNçš„ææ€§å‡ä¸ºé«˜ç”µå¹³ï¼› ç¦ç”¨FastModeï¼› ç©ºé—²çŠ¶æ€ä¸‹ä¸ºä½ç”µå¹³ã€‚ &emsp;PWMå‚æ•°çš„é…ç½®é€šè¿‡HAL_TIM_PWM_ConfigChannel()å‡½æ•°å®ç°ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163/** * @brief Initializes the TIM PWM channels according to the specified * parameters in the TIM_OC_InitTypeDef. * @param htim pointer to a TIM_HandleTypeDef structure that contains * the configuration information for TIM module. * @param sConfig TIM PWM configuration structure * @param Channel TIM Channels to be enabled. * This parameter can be one of the following values: * @arg TIM_CHANNEL_1: TIM Channel 1 selected * @arg TIM_CHANNEL_2: TIM Channel 2 selected * @arg TIM_CHANNEL_3: TIM Channel 3 selected * @arg TIM_CHANNEL_4: TIM Channel 4 selected * @retval HAL status */__weak HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)&#123; __HAL_LOCK(htim); /* Check the parameters */ assert_param(IS_TIM_CHANNELS(Channel)); assert_param(IS_TIM_PWM_MODE(sConfig-&gt;OCMode)); assert_param(IS_TIM_OC_POLARITY(sConfig-&gt;OCPolarity)); assert_param(IS_TIM_FAST_STATE(sConfig-&gt;OCFastMode)); htim-&gt;State = HAL_TIM_STATE_BUSY; switch (Channel) &#123; case TIM_CHANNEL_1: &#123; assert_param(IS_TIM_CC1_INSTANCE(htim-&gt;Instance)); /* Configure the Channel 1 in PWM mode */ TIM_OC1_SetConfig(htim-&gt;Instance, sConfig); /* Set the Preload enable bit for channel1 */ htim-&gt;Instance-&gt;CCMR1 |= TIM_CCMR1_OC1PE; /* Configure the Output Fast mode */ htim-&gt;Instance-&gt;CCMR1 &amp;= ~TIM_CCMR1_OC1FE; htim-&gt;Instance-&gt;CCMR1 |= sConfig-&gt;OCFastMode; &#125; break; case TIM_CHANNEL_2: &#123; assert_param(IS_TIM_CC2_INSTANCE(htim-&gt;Instance)); /* Configure the Channel 2 in PWM mode */ TIM_OC2_SetConfig(htim-&gt;Instance, sConfig); /* Set the Preload enable bit for channel2 */ htim-&gt;Instance-&gt;CCMR1 |= TIM_CCMR1_OC2PE; /* Configure the Output Fast mode */ htim-&gt;Instance-&gt;CCMR1 &amp;= ~TIM_CCMR1_OC2FE; htim-&gt;Instance-&gt;CCMR1 |= sConfig-&gt;OCFastMode &lt;&lt; 8; &#125; break; case TIM_CHANNEL_3: &#123; assert_param(IS_TIM_CC3_INSTANCE(htim-&gt;Instance)); /* Configure the Channel 3 in PWM mode */ TIM_OC3_SetConfig(htim-&gt;Instance, sConfig); /* Set the Preload enable bit for channel3 */ htim-&gt;Instance-&gt;CCMR2 |= TIM_CCMR2_OC3PE; /* Configure the Output Fast mode */ htim-&gt;Instance-&gt;CCMR2 &amp;= ~TIM_CCMR2_OC3FE; htim-&gt;Instance-&gt;CCMR2 |= sConfig-&gt;OCFastMode; &#125; break; case TIM_CHANNEL_4: &#123; assert_param(IS_TIM_CC4_INSTANCE(htim-&gt;Instance)); /* Configure the Channel 4 in PWM mode */ TIM_OC4_SetConfig(htim-&gt;Instance, sConfig); /* Set the Preload enable bit for channel4 */ htim-&gt;Instance-&gt;CCMR2 |= TIM_CCMR2_OC4PE; /* Configure the Output Fast mode */ htim-&gt;Instance-&gt;CCMR2 &amp;= ~TIM_CCMR2_OC4FE; htim-&gt;Instance-&gt;CCMR2 |= sConfig-&gt;OCFastMode &lt;&lt; 8; &#125; break; default: break; &#125; htim-&gt;State = HAL_TIM_STATE_READY; __HAL_UNLOCK(htim); return HAL_OK;&#125;/** * @brief Time Output Compare 1 configuration * @param TIMx to select the TIM peripheral * @param OC_Config The output configuration structure * @retval None */void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)&#123; uint32_t tmpccmrx = 0; uint32_t tmpccer = 0; uint32_t tmpcr2 = 0; /* Disable the Channel 1: Reset the CC1E Bit */ TIMx-&gt;CCER &amp;= ~TIM_CCER_CC1E; /* Get the TIMx CCER register value */ tmpccer = TIMx-&gt;CCER; /* Get the TIMx CR2 register value */ tmpcr2 = TIMx-&gt;CR2; /* Get the TIMx CCMR1 register value */ tmpccmrx = TIMx-&gt;CCMR1; /* Reset the Output Compare Mode Bits */ tmpccmrx &amp;= ~TIM_CCMR1_OC1M; tmpccmrx &amp;= ~TIM_CCMR1_CC1S; /* Select the Output Compare Mode */ tmpccmrx |= OC_Config-&gt;OCMode; /* Reset the Output Polarity level */ tmpccer &amp;= ~TIM_CCER_CC1P; /* Set the Output Compare Polarity */ tmpccer |= OC_Config-&gt;OCPolarity; if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET) &#123; /* Reset the Output N Polarity level */ tmpccer &amp;= ~TIM_CCER_CC1NP; /* Set the Output N Polarity */ tmpccer |= OC_Config-&gt;OCNPolarity; /* Reset the Output N State */ tmpccer &amp;= ~TIM_CCER_CC1NE; /* Reset the Output Compare and Output Compare N IDLE State */ tmpcr2 &amp;= ~TIM_CR2_OIS1; tmpcr2 &amp;= ~TIM_CR2_OIS1N; /* Set the Output Idle state */ tmpcr2 |= OC_Config-&gt;OCIdleState; /* Set the Output N Idle state */ tmpcr2 |= OC_Config-&gt;OCNIdleState; &#125; /* Write to TIMx CR2 */ TIMx-&gt;CR2 = tmpcr2; /* Write to TIMx CCMR1 */ TIMx-&gt;CCMR1 = tmpccmrx; /* Set the Capture Compare Register value */ TIMx-&gt;CCR1 = OC_Config-&gt;Pulse; /* Write to TIMx CCER */ TIMx-&gt;CCER = tmpccer; &#125; &emsp;ä»£ç åŠŸèƒ½å¦‚ä¸‹ï¼š TIMx-&gt;CCERå¯„å­˜å™¨CC1Eä½å¤ä½ï¼Œç¦ç”¨OC1ï¼› tmpccerä¿å­˜TIMx-&gt;CCERå€¼ï¼Œtmpcr2ä¿å­˜TIMx-&gt;CR2å€¼ï¼Œtmpccmrxä¿å­˜TIMx-&gt;CCMR1å€¼ï¼› tmpccmrxå¤ä½OC1Mä¸CC1Sä½ï¼›CC1Sè¢«å¤ä½åï¼Œä»£è¡¨OC1é€šé“è¢«è®¾ç½®ä¸ºè¾“å‡ºæ¨¡å¼ï¼› tmpccmrxå†™å…¥OCModeï¼Œæœ¬ä¾‹ä¸­OCModeé…ç½®ä¸ºTIM_OCMODE_PWM1ï¼Œå³å¯¹åº”OC1Mé…ç½®ä¸º0b0110ï¼Œå³ä¸ºPWMæ¨¡å¼1ï¼šå½“è®¡æ•°å™¨å¤„äºå¢è®¡æ•°æ—¶ï¼ŒTIMx_CNT&lt;TIMx_CCR1æ—¶channel1ä¸ºactiveï¼› tmpccerå¤ä½CC1Pï¼Œå¹¶å†™å…¥activeçŠ¶æ€çš„ç”µå¹³ï¼Œæœ¬ä¾‹ä¸ºactiveå¯¹åº”é«˜ç”µå¹³ï¼› TIM1ä¸ºé«˜çº§æ§åˆ¶å®šæ—¶å™¨ï¼Œå¯ä»¥è¾“å‡ºäº’è¡¥PWMï¼Œåˆ™æœ‰tmpccerå¤ä½CC1NPä½ï¼Œå¹¶å†™å…¥activeçŠ¶æ€çš„ç”µå¹³ï¼Œæœ¬ä¾‹ä¸ºactiveå¯¹åº”é«˜ç”µå¹³ï¼› tmpccerå¤ä½CC1NEä½ï¼Œåˆ™OC1Nè¾“å‡ºå…³é—­ï¼› tmpcr2å¤ä½OIS1ä¸OIS1Nä½ï¼Œå¹¶å†™å…¥OCè¾“å‡ºç©ºé—²çš„çŠ¶æ€ï¼Œæœ¬ä¾‹å¯¹åº”å‡ä¸ºè¾“å‡ºç©ºé—²çŠ¶æ€ä¸ºå¤ä½çŠ¶æ€ï¼› TIMx-&gt;CR2å¯„å­˜å™¨å†™å…¥tmpcr2å€¼ï¼› TIMx-&gt;CCMR1å¯„å­˜å™¨å†™å…¥tmpccmrxå€¼ï¼› TIMx-&gt;CCR1å¯„å­˜å™¨å†™å…¥è„‰å®½å€¼ï¼Œå†³å®šäº†PWMçš„å ç©ºæ¯”ï¼› TIMx-&gt;CCERå¯„å­˜å™¨å†™å…¥tmpccerå€¼ï¼› TIMx-&gt;CCMR1å¯„å­˜å™¨ç½®ä½OC1PEä½ï¼Œä½¿èƒ½OC1é¢„è£…è½½ï¼› TIMx-&gt;CCMR1å¯„å­˜å™¨å¤ä½OC1PEå¹¶å†™å…¥OCFastModeå€¼ï¼Œæœ¬ä¾‹ä¸ºç¦æ­¢fastæ¨¡å¼ã€‚fastæ¨¡å¼è¿›å¯¹äºè¾“å…¥æ¯”è¾ƒæœ‰æ•ˆï¼Œæ­¤å¤„é…ç½®æ— æ„ä¹‰ï¼› æ³¨æ„channel1ä¸channel2é…ç½®OCæœ‰æ•ˆç”µå¹³ä¸ºé«˜ç”µå¹³ï¼Œchannel3é…ç½®OCæœ‰æ•ˆç”µå¹³ä¸ºä½ç”µå¹³ï¼› Breakä¸DeadTimeé…ç½®&emsp;Breakä¸DeadTimeé…ç½®ä»£ç å¦‚ä¸‹æ‰€ç¤ºã€‚å…¶ä¸­æœ€ä¸»è¦çš„è®¾ç½®ä¸ºè®¾ç½®æ­»åŒºæ—¶é—´ä¸º100ã€‚ &emsp;åœ¨æ—¶åŸºåˆå§‹åŒ–ä¸­ï¼ŒPWMæ­»åŒºçš„æ—¶é’Ÿç›¸å¯¹TIMè¾“å…¥æ—¶é’Ÿä¸è¿›è¡Œåˆ†é¢‘ï¼Œæœ¬ä¾‹ä¸­å³ä¸º216MHz(PWMæ­»åŒºçš„æ—¶é’Ÿå‘¨æœŸå®šä¹‰ä¸ºTdts)ã€‚æ­»åŒºçš„è®¾ç½®é€šè¿‡TIMx_BDTRå¯„å­˜å™¨çš„DTGä½å®ç°ï¼š $DTG[7:5]=0xx$æ—¶ï¼Œ$DT=DTG[7:0] \\cdot Tdt$gï¼Œå…¶ä¸­ $Tdtg=Tdts$ï¼Œåˆ™ç­‰æ•ˆå¯ä»¥è®¾ç½®çš„$Tdts$å‘¨æœŸæ•°ä¸º0~127ï¼› $DTG[7:5]=10x$æ—¶ï¼Œ$DT=(64+DTG[5:0]) \\cdot Tdtg$ï¼Œå…¶ä¸­$Tdtg=2 \\cdot Tdts$ï¼Œåˆ™ç­‰æ•ˆå¯ä»¥è®¾ç½®çš„$Tdts$å‘¨æœŸæ•°ä¸º128~254ï¼› $DTG[7:5]=11x$æ—¶ï¼Œ$DT=(32+DTG[ 4:0]) \\cdot Tdtg$ï¼Œå…¶ä¸­$Tdtg=8 \\cdot Tdts$ï¼Œåˆ™ç­‰æ•ˆå¯ä»¥è®¾ç½®çš„$Tdts$å‘¨æœŸæ•°ä¸º256~504ï¼› $DTG[7:5]=111$æ—¶ï¼Œ$DT=(32+DTG[ 4:0]) \\cdot Tdtg$ï¼Œå…¶ä¸­$Tdtg= 16 \\cdot Tdts$ï¼Œåˆ™ç­‰æ•ˆå¯ä»¥è®¾ç½®çš„$Tdts$å‘¨æœŸæ•°ä¸º512~1008ï¼› 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;sBreakDeadTimeConfig.DeadTime = 100;sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;sBreakDeadTimeConfig.BreakFilter = 0;sBreakDeadTimeConfig.Break2State = TIM_BREAK2_DISABLE;sBreakDeadTimeConfig.Break2Polarity = TIM_BREAK2POLARITY_HIGH;sBreakDeadTimeConfig.Break2Filter = 0;sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;if (HAL_TIMEx_ConfigBreakDeadTime(&amp;htim1, &amp;sBreakDeadTimeConfig) != HAL_OK)&#123; _Error_Handler(__FILE__, __LINE__);&#125;/** * @brief Configures the Break feature, dead time, Lock level, OSSI/OSSR State * and the AOE(automatic output enable). * @param htim pointer to a TIM_HandleTypeDef structure that contains * the configuration information for TIM module. * @param sBreakDeadTimeConfig pointer to a TIM_ConfigBreakDeadConfig_TypeDef structure that * contains the BDTR Register configuration information for the TIM peripheral. * @retval HAL status */ HAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim, TIM_BreakDeadTimeConfigTypeDef * sBreakDeadTimeConfig)&#123; uint32_t tmpbdtr = 0; /* Check the parameters */ assert_param(IS_TIM_BREAK_INSTANCE(htim-&gt;Instance)); assert_param(IS_TIM_OSSR_STATE(sBreakDeadTimeConfig-&gt;OffStateRunMode)); assert_param(IS_TIM_OSSI_STATE(sBreakDeadTimeConfig-&gt;OffStateIDLEMode)); assert_param(IS_TIM_LOCK_LEVEL(sBreakDeadTimeConfig-&gt;LockLevel)); assert_param(IS_TIM_DEADTIME(sBreakDeadTimeConfig-&gt;DeadTime)); assert_param(IS_TIM_BREAK_STATE(sBreakDeadTimeConfig-&gt;BreakState)); assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig-&gt;BreakPolarity)); assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig-&gt;BreakFilter)); assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig-&gt;AutomaticOutput)); assert_param(IS_TIM_BREAK2_STATE(sBreakDeadTimeConfig-&gt;Break2State)); assert_param(IS_TIM_BREAK2_POLARITY(sBreakDeadTimeConfig-&gt;Break2Polarity)); assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig-&gt;Break2Filter)); /* Check input state */ __HAL_LOCK(htim); /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State, the OSSI State, the dead time value and the Automatic Output Enable Bit */ /* Set the BDTR bits */ MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig-&gt;DeadTime); MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig-&gt;LockLevel); MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig-&gt;OffStateIDLEMode); MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig-&gt;OffStateRunMode); MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig-&gt;BreakState); MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig-&gt;BreakPolarity); MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig-&gt;AutomaticOutput); MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, sBreakDeadTimeConfig-&gt;AutomaticOutput); MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, (sBreakDeadTimeConfig-&gt;BreakFilter &lt;&lt; BDTR_BKF_SHIFT)); if (IS_TIM_BKIN2_INSTANCE(htim-&gt;Instance)) &#123; assert_param(IS_TIM_BREAK2_STATE(sBreakDeadTimeConfig-&gt;Break2State)); assert_param(IS_TIM_BREAK2_POLARITY(sBreakDeadTimeConfig-&gt;Break2Polarity)); assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig-&gt;Break2Filter)); /* Set the BREAK2 input related BDTR bits */ MODIFY_REG(tmpbdtr, TIM_BDTR_BK2F, (sBreakDeadTimeConfig-&gt;Break2Filter &lt;&lt; BDTR_BK2F_SHIFT)); MODIFY_REG(tmpbdtr, TIM_BDTR_BK2E, sBreakDeadTimeConfig-&gt;Break2State); MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, sBreakDeadTimeConfig-&gt;Break2Polarity); &#125; /* Set TIMx_BDTR */ htim-&gt;Instance-&gt;BDTR = tmpbdtr; __HAL_UNLOCK(htim); return HAL_OK;&#125; &emsp;å¯¹ä»£ç çš„åˆ†æå¦‚ä¸‹ï¼š æ­»åŒºæ—¶é—´è®¾ç½®ä¸º100ï¼Œå³ä¸º0b0110 0100ï¼Œæ‰€ä»¥å¯¹åº”çš„æ­»åŒºæ—¶é—´ä¸º100ä¸ª$Tdts$å‘¨æœŸæ•°ï¼Œå³ä¸º463nsï¼› è¿è¡Œæ¨¡å¼ä¸‹ä¸ç©ºé—²æ¨¡å¼ä¸‹å¤„äºæ— æ•ˆçŠ¶æ€æ—¶ï¼Œè®¾ç½®ä¸ºç¦æ­¢OC/OCNè¾“å‡ºï¼› é”å®šé…ç½®ä¸ç”Ÿæ•ˆï¼› BreakåŠŸèƒ½æœ¬ä¾‹ä¸æ¶‰åŠï¼Œå…¨éƒ¨ç¦ç”¨çŠ¶æ€ã€‚ ç¡¬ä»¶åˆå§‹åŒ–&emsp;ç¡¬ä»¶åˆå§‹åŒ–å‡½æ•°å¦‚ä¸‹æ‰€ç¤ºã€‚ç¡¬ä»¶åˆå§‹åŒ–å³ä¸ºå¯¹PWM IOçš„åˆå§‹åŒ–ï¼Œè¿™é‡Œä¸å†è¯´æ˜ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445void HAL_TIM_MspPostInit(TIM_HandleTypeDef* timHandle)&#123; GPIO_InitTypeDef GPIO_InitStruct; if(timHandle-&gt;Instance==TIM1) &#123; /* USER CODE BEGIN TIM1_MspPostInit 0 */ /* USER CODE END TIM1_MspPostInit 0 */ /**TIM1 GPIO Configuration PE11 ------&gt; TIM1_CH2 PE13 ------&gt; TIM1_CH3 PB13 ------&gt; TIM1_CH1N PB14 ------&gt; TIM1_CH2N PB15 ------&gt; TIM1_CH3N PA8 ------&gt; TIM1_CH1 */ GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_13; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; GPIO_InitStruct.Alternate = GPIO_AF1_TIM1; HAL_GPIO_Init(GPIOE, &amp;GPIO_InitStruct); GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; GPIO_InitStruct.Alternate = GPIO_AF1_TIM1; HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct); GPIO_InitStruct.Pin = GPIO_PIN_8; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; GPIO_InitStruct.Alternate = GPIO_AF1_TIM1; HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct); /* USER CODE BEGIN TIM1_MspPostInit 1 */ /* USER CODE END TIM1_MspPostInit 1 */ &#125;&#125; ä½¿èƒ½PWMè¾“å‡º&emsp;ä½¿èƒ½PWMè¾“å‡ºçš„å‡½æ•°å¦‚ä¸‹æ‰€ç¤ºã€‚ 12345678HAL_TIM_PWM_Start(&amp;htim1, TIM_CHANNEL_1);HAL_TIMEx_PWMN_Start(&amp;htim1, TIM_CHANNEL_1); // turn on complementary channel HAL_TIM_PWM_Start(&amp;htim1, TIM_CHANNEL_2);HAL_TIMEx_PWMN_Start(&amp;htim1, TIM_CHANNEL_2); // turn on complementary channel HAL_TIM_PWM_Start(&amp;htim1, TIM_CHANNEL_3);HAL_TIMEx_PWMN_Start(&amp;htim1, TIM_CHANNEL_3); // turn on complementary channel &emsp;ä»¥channel1ä¸ºä¾‹ï¼Œå…¶å…·ä½“å®ç°å¦‚ä¸‹ã€‚é¦–å…ˆä¸ºPWMä¿¡å·ç”Ÿæˆä½¿èƒ½ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * @brief Starts the PWM signal generation. * @param htim pointer to a TIM_HandleTypeDef structure that contains * the configuration information for TIM module. * @param Channel TIM Channels to be enabled. * This parameter can be one of the following values: * @arg TIM_CHANNEL_1: TIM Channel 1 selected * @arg TIM_CHANNEL_2: TIM Channel 2 selected * @arg TIM_CHANNEL_3: TIM Channel 3 selected * @arg TIM_CHANNEL_4: TIM Channel 4 selected * @retval HAL status */HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)&#123; /* Check the parameters */ assert_param(IS_TIM_CCX_INSTANCE(htim-&gt;Instance, Channel)); /* Enable the Capture compare channel */ TIM_CCxChannelCmd(htim-&gt;Instance, Channel, TIM_CCx_ENABLE); if(IS_TIM_ADVANCED_INSTANCE(htim-&gt;Instance) != RESET) &#123; /* Enable the main output */ __HAL_TIM_MOE_ENABLE(htim); &#125; /* Enable the Peripheral */ __HAL_TIM_ENABLE(htim); /* Return function status */ return HAL_OK;&#125; void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)&#123; uint32_t tmp = 0; /* Check the parameters */ assert_param(IS_TIM_CC1_INSTANCE(TIMx)); assert_param(IS_TIM_CHANNELS(Channel)); tmp = TIM_CCER_CC1E &lt;&lt; Channel; /* Reset the CCxE Bit */ TIMx-&gt;CCER &amp;= ~tmp; /* Set or reset the CCxE Bit */ TIMx-&gt;CCER |= (uint32_t)(ChannelState &lt;&lt; Channel);&#125;/** * @brief Enable the TIM main Output. * @param __HANDLE__ TIM handle * @retval None */#define __HAL_TIM_MOE_ENABLE(__HANDLE__) ((__HANDLE__)-&gt;Instance-&gt;BDTR|=(TIM_BDTR_MOE))/** * @brief Enable the TIM peripheral. * @param __HANDLE__ TIM handle * @retval None */#define __HAL_TIM_ENABLE(__HANDLE__) ((__HANDLE__)-&gt;Instance-&gt;CR1|=(TIM_CR1_CEN)) &emsp;ä»£ç åŠŸèƒ½ä¸»è¦ä¸ºï¼š TIMx_CCERå¯„å­˜å™¨CCxEä½ç½®ä½ï¼Œä»£è¡¨OCå¼€å¯ï¼Œä¿¡å·è¾“å‡ºåˆ°å¯¹åº”å¼•è„šï¼› TIMx_BDTRå¯„å­˜å™¨MOEä½ç½®ä½ï¼Œä¸»è¾“å‡ºä½¿èƒ½å¼€å¯ï¼Œå½“CCxEä¸CCxNEä½¿èƒ½æ—¶ï¼Œåˆ™ä½¿èƒ½OCä¸OCNï¼› TIMx_CR1å¯„å­˜å™¨CENç½®ä½ï¼Œä½¿èƒ½è®¡æ•°å™¨ï¼› &emsp;PWMçš„äº’è¡¥å¯¹ä½¿èƒ½å¦‚ä¸‹ã€‚ 12345678910111213141516171819202122232425262728/** * @brief Starts the PWM signal generation on the complementary output. * @param htim pointer to a TIM_HandleTypeDef structure that contains * the configuration information for TIM module. * @param Channel TIM Channel to be enabled. * This parameter can be one of the following values: * @arg TIM_CHANNEL_1: TIM Channel 1 selected * @arg TIM_CHANNEL_2: TIM Channel 2 selected * @arg TIM_CHANNEL_3: TIM Channel 3 selected * @retval HAL status */HAL_StatusTypeDef HAL_TIMEx_PWMN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)&#123; /* Check the parameters */ assert_param(IS_TIM_CCXN_INSTANCE(htim-&gt;Instance, Channel)); /* Enable the complementary PWM output */ TIM_CCxNChannelCmd(htim-&gt;Instance, Channel, TIM_CCxN_ENABLE); /* Enable the Main Output */ __HAL_TIM_MOE_ENABLE(htim); /* Enable the Peripheral */ __HAL_TIM_ENABLE(htim); /* Return function status */ return HAL_OK;&#125; &emsp;ä»£ç åŠŸèƒ½ä¸»è¦ä¸ºï¼š TIMx_CCERå¯„å­˜å™¨CCxNEä½ç½®ä½ï¼Œä»£è¡¨OCNå¼€å¯ï¼Œä¿¡å·è¾“å‡ºåˆ°å¯¹åº”å¼•è„šï¼› ä¸PWMä¸»ä¿¡å·ä¸€è‡´ï¼Œä½¿èƒ½MOEä½å¹¶ä½¿èƒ½å®šæ—¶å™¨ã€‚ æµ‹è¯•ç¨‹åº&emsp;æŒ‰ç…§ä¸Šè¿°é…ç½®è¿›è¡Œæµ‹è¯•ï¼Œå¾—åˆ°çš„æ³¢å½¢ä¿¡æ¯å¦‚ä¸‹ã€‚ å…¶ä¸­å ç©ºæ¯”åˆ†åˆ«æ¥è¿‘20%ã€30%ã€60%(channel3ä¸ºåç›¸)ï¼› æ­»åŒºæ—¶é—´çº¦ä¸º460nsï¼Œä¸ç†è®ºå€¼æ¥è¿‘ã€‚","categories":[{"name":"åµŒå…¥å¼","slug":"åµŒå…¥å¼","permalink":"http://jiaodi.tech/categories/åµŒå…¥å¼/"}],"tags":[{"name":"STM32F7","slug":"STM32F7","permalink":"http://jiaodi.tech/tags/STM32F7/"},{"name":"PWM","slug":"PWM","permalink":"http://jiaodi.tech/tags/PWM/"}]},{"title":"ä¼˜åŒ–å‰é¦ˆç”µå®¹æ”¹å–„DCDCçš„ç¬æ€å“åº”(æœªå®Œæˆ)","slug":"feedforward-cap","date":"2018-04-28T11:53:05.000Z","updated":"2018-05-07T12:22:06.764Z","comments":true,"path":"2018/04/28/feedforward-cap/","link":"","permalink":"http://jiaodi.tech/2018/04/28/feedforward-cap/","excerpt":"&emsp;æœ¬æ–‡ä»‹ç»å¦‚ä½•åˆ©ç”¨å‰é¦ˆç”µå®¹ä¼˜åŒ–DCDCçš„ç¬æ€å“åº”èƒ½åŠ›ã€‚","text":"&emsp;æœ¬æ–‡ä»‹ç»å¦‚ä½•åˆ©ç”¨å‰é¦ˆç”µå®¹ä¼˜åŒ–DCDCçš„ç¬æ€å“åº”èƒ½åŠ›ã€‚ ç®€ä»‹&emsp;æŒ‰ç…§æ§åˆ¶å¯¹è±¡åŒºåˆ†ï¼ŒDCDCå˜æ¢å™¨é€šå¸¸å¯ä»¥åˆ†ä¸ºç”µå‹å‹ä¸ç”µæµå‹æ§åˆ¶ã€‚ç›®å‰å¸¸è§çš„é›†æˆå‹DCDCå˜æ¢å™¨é€šå¸¸åœ¨å†…éƒ¨å®Œæˆè¡¥å¿å›è·¯ï¼Œä»¥ä¾¿äºç”¨æˆ·ç›´æ¥ä½¿ç”¨ï¼›ä½†ç”±äºè¡¥å¿å›è·¯æ— æ³•è‡ªè¡Œä¿®æ”¹ï¼Œä¹Ÿç›¸çŸ¥äº†ç”¨æˆ·å¯¹å˜æ¢å™¨ç¬æ€å“åº”è¿›è¡Œè°ƒèŠ‚çš„èƒ½åŠ›ã€‚ &emsp;è€ƒè™‘åˆ°å¯è°ƒè¾“å‡ºDCDCå˜æ¢å™¨éœ€è¦è®¾ç½®åˆ†å‹åé¦ˆç½‘ç»œï¼Œåé¦ˆç½‘ç»œä¸­çš„å‰é¦ˆç”µå®¹å¯ä»¥å½±å“ç³»ç»Ÿç¯è·¯ç¨³å®šæ€§ã€‚æœ¬æ–‡å°†ç®€è¦ä»‹ç»é€šè¿‡ä¼˜åŒ–å‰é¦ˆç”µå®¹æ”¹å–„DCDCç¬æ€å“åº”çš„æ–¹æ³•ã€‚ æ§åˆ¶æ¡†å›¾&emsp;å…¸å‹çš„DCDCå˜æ¢å™¨æ§åˆ¶æ¡†å›¾å¦‚ä¸‹æ‰€ç¤ºï¼Œå…±åˆ†ä¸ºmodulator(è°ƒåˆ¶å™¨)ã€filter(æ»¤æ³¢å™¨)ä¸compensator(è¡¥å¿å™¨)ä¸‰éƒ¨åˆ†ã€‚","categories":[{"name":"ç”µæº","slug":"ç”µæº","permalink":"http://jiaodi.tech/categories/ç”µæº/"}],"tags":[{"name":"DCDC","slug":"DCDC","permalink":"http://jiaodi.tech/tags/DCDC/"},{"name":"å‰é¦ˆç”µå®¹","slug":"å‰é¦ˆç”µå®¹","permalink":"http://jiaodi.tech/tags/å‰é¦ˆç”µå®¹/"},{"name":"åŠ¨æ€å“åº”","slug":"åŠ¨æ€å“åº”","permalink":"http://jiaodi.tech/tags/åŠ¨æ€å“åº”/"}]},{"title":"STM32F767 WWDGçš„åŸºæœ¬ç”¨æ³•","slug":"stm32f767-wwdg","date":"2018-04-25T12:55:35.000Z","updated":"2018-05-07T12:16:18.757Z","comments":true,"path":"2018/04/25/stm32f767-wwdg/","link":"","permalink":"http://jiaodi.tech/2018/04/25/stm32f767-wwdg/","excerpt":"&emsp;æœ¬æ–‡ä»‹ç»STM32F767 WWDG(System window watchdog)çš„åŸºæœ¬ç”¨æ³•ã€‚","text":"&emsp;æœ¬æ–‡ä»‹ç»STM32F767 WWDG(System window watchdog)çš„åŸºæœ¬ç”¨æ³•ã€‚ å¼€å‘ç¯å¢ƒç¡¬ä»¶ç¯å¢ƒ ç”µè„‘ï¼šWindows 10 Home x64 Apollo STM32F767å¼€å‘æ¿(ST-LINK V2ä»¿çœŸå™¨) è½¯ä»¶ç¯å¢ƒ Keil Version 5.24.1 (Pack Installerï¼šKeil.STM32F7xx_DFP.2.9.0.pack) STM32CubeMX Version 4.25.0(Packages Managerï¼šSTM32CubeF7) WWDGä¸»è¦ç‰¹æ€§ç³»ç»Ÿæ¡†å›¾ ä¸»è¦ç‰¹æ€§ è‡ªç”±è®¡æ•°é€’å‡è®¡æ•°å™¨ æ—¶é’Ÿæºä¸ºAPB1æ—¶é’Ÿ å¤ä½æ¡ä»¶ é€’å‡è®¡æ•°å™¨å€¼å°äº0x40æ—¶(çœ‹é—¨ç‹—æ¿€æ´»çŠ¶æ€ä¸‹) é€’å‡è®¡æ•°å™¨åœ¨çª—å£ä¹‹å¤–æ—¶è¢«é‡è½½(çœ‹é—¨ç‹—æ¿€æ´»çŠ¶æ€ä¸‹) æå‰å”¤é†’ä¸­æ–­(EWI)ï¼šå½“é€’å‡è®¡æ•°å™¨ç­‰äº0x40æ—¶è§¦å‘(å¦‚å·²ä½¿èƒ½ä¸”çœ‹é—¨ç‹—æ¿€æ´»çŠ¶æ€ä¸‹) WWDGæº¢å‡ºæ—¶é—´è®¡ç®—&emsp;WWDGä½¿ç”¨APB1ä½œä¸ºæ—¶é’Ÿæºï¼Œç»è¿‡4096ä¸WWDG_CFRå¯„å­˜å™¨çš„WDGTBä½æ§åˆ¶çš„å…±2æ¬¡åˆ†é¢‘ã€‚æœ¬ä¾‹ä¸­APB1çš„æ—¶é’Ÿé¢‘ç‡ä¸º54MHzï¼Œåˆ™WWDGçš„æ—¶é’Ÿå‘¨æœŸè®¡ç®—å¦‚ä¸‹ï¼š $$T{WWDG}=T{APB1}\\cdot 4096\\cdot 2^{WDGTB}$$ ä¸¾ä¾‹è®¡ç®—ï¼Œè®¾å®šWDGTBä¸º3ï¼Œåˆ™WWDGçš„æ—¶é’Ÿå‘¨æœŸçº¦ä¸º0.6068msã€‚ é€’å‡è®¡æ•°å™¨å€¼å°äº0x40(ç­‰äº0x39)æ—¶WWDGå¤ä½ï¼› è®¾å®šWWDG_CFRå¯„å­˜å™¨ä¸­W[6:0]çª—å£å€¼ä¸º0x50ï¼› è®¾å®šWWDG_CRå¯„å­˜å™¨ä¸­T[6:0]è®¡æ•°å™¨å€¼ä¸º0x60ï¼› &emsp;åˆ™WWDGçš„å…è®¸åˆ·æ–°æ—¶é—´ä½äºè®¡æ•°å™¨å€¼åœ¨çª—å£å€¼ä¸0x40ä¹‹é—´ï¼Œåœ¨çª—å£ä¹‹å¤–æˆ–è€…è®¡æ•°å€¼å°äº0x40æ—¶éƒ½å°†å¼•èµ·å¤ä½ã€‚ç”±ä»¥ä¸Šçº¦æŸæ—¶é—´ï¼Œåˆ™åœ¨WWDGè®¡æ•°å™¨å¯åŠ¨ä¹‹åï¼Œè®¡æ•°å€¼ä»0x60åˆ°0x50ä¹‹é—´ç¦æ­¢åˆ·æ–°çœ‹é—¨ç‹—ï¼Œè®¡æ•°å€¼åœ¨0x50åˆ°0x39ä¹‹é—´å…è®¸åˆ·æ–°çœ‹é—¨ç‹—ï¼Œåœ¨è®¡æ•°å™¨åˆ°è¾¾0x39æ—¶å°†å¼•èµ·çœ‹é—¨ç‹—å¤ä½ã€‚å¯¹åº”åœ°ï¼Œåœ¨9.71~20.02mså†…åˆ·æ–°å‡å¯ä»¥é‡è½½çœ‹é—¨ç‹—ï¼Œåœ¨æ­¤æ—¶é—´çª—ä»¥å¤–åˆ·æ–°IWDGéƒ½å·²ç»æ— æ³•é¿å…ç³»ç»Ÿå¤ä½ã€‚ WWDGçš„åŸºæœ¬ç”¨æ³•WWDGå‚æ•°è®¾ç½®&emsp;WWDGçš„åˆå§‹åŒ–ä»£ç å¦‚ä¸‹æ‰€ç¤ºã€‚ 1234567891011121314151617WWDG_HandleTypeDef hwwdg;/* WWDG init function */void MX_WWDG_Init(void)&#123; hwwdg.Instance = WWDG; hwwdg.Init.Prescaler = WWDG_PRESCALER_8; hwwdg.Init.Window = 0x50; hwwdg.Init.Counter = 0x60; hwwdg.Init.EWIMode = WWDG_EWI_DISABLE; if (HAL_WWDG_Init(&amp;hwwdg) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125;&#125; &emsp;å…¶å‚æ•°è®¾ç½®å¦‚ä¸‹ï¼š é¢„åˆ†é¢‘ç³»æ•°è®¾ç½®ä¸º8ï¼Œçª—å£å€¼è®¾ç½®ä¸º0x50ï¼Œè®¡æ•°å™¨å€¼è®¾ç½®ä¸º0x60ï¼› ç¦æ­¢EWIä¸­æ–­ã€‚ WWDGåˆå§‹åŒ–&emsp;WWDGåˆå§‹åŒ–ä»£ç å¦‚ä¸‹ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * @brief Initialize the WWDG according to the specified. * parameters in the WWDG_InitTypeDef of associated handle. * @param hwwdg pointer to a WWDG_HandleTypeDef structure that contains * the configuration information for the specified WWDG module. * @retval HAL status */HAL_StatusTypeDef HAL_WWDG_Init(WWDG_HandleTypeDef *hwwdg)&#123; /* Check the WWDG handle allocation */ if(hwwdg == NULL) &#123; return HAL_ERROR; &#125; /* Check the parameters */ assert_param(IS_WWDG_ALL_INSTANCE(hwwdg-&gt;Instance)); assert_param(IS_WWDG_PRESCALER(hwwdg-&gt;Init.Prescaler)); assert_param(IS_WWDG_WINDOW(hwwdg-&gt;Init.Window)); assert_param(IS_WWDG_COUNTER(hwwdg-&gt;Init.Counter)); assert_param(IS_WWDG_EWI_MODE(hwwdg-&gt;Init.EWIMode)); /* Init the low level hardware */ HAL_WWDG_MspInit(hwwdg); /* Set WWDG Counter */ WRITE_REG(hwwdg-&gt;Instance-&gt;CR, (WWDG_CR_WDGA | hwwdg-&gt;Init.Counter)); /* Set WWDG Prescaler and Window */ WRITE_REG(hwwdg-&gt;Instance-&gt;CFR, (hwwdg-&gt;Init.EWIMode | hwwdg-&gt;Init.Prescaler | hwwdg-&gt;Init.Window)); /* Return function status */ return HAL_OK;&#125;void HAL_WWDG_MspInit(WWDG_HandleTypeDef* wwdgHandle)&#123; if(wwdgHandle-&gt;Instance==WWDG) &#123; /* USER CODE BEGIN WWDG_MspInit 0 */ /* USER CODE END WWDG_MspInit 0 */ /* WWDG clock enable */ __HAL_RCC_WWDG_CLK_ENABLE(); /* USER CODE BEGIN WWDG_MspInit 1 */ /* USER CODE END WWDG_MspInit 1 */ &#125;&#125; &emsp;WWDGåˆå§‹åŒ–æµç¨‹å¦‚ä¸‹ï¼š ä½¿èƒ½WWDGæ—¶é’Ÿï¼› è®¾ç½®WWDG_CRå¯„å­˜å™¨WDGAä½ä¸º1ï¼Œä½¿èƒ½çœ‹é—¨ç‹—ï¼›å‘T[6:0]ä½å†™å…¥è®¡æ•°å™¨å€¼ï¼› è®¾ç½®WWDG_CFRå¯„å­˜å™¨EWIä½ä¸º0ï¼Œç¦æ­¢EWIåŠŸèƒ½ï¼›å‘WDGTB[1:0]ä½å†™å…¥é¢„åˆ†é¢‘å€¼ï¼›å‘W[6:0]ä½å†™å…¥çª—å£å€¼ã€‚ åˆ·æ–°WWDGå‡½æ•°&emsp;åˆ·æ–°WWDGå‡½æ•°å¦‚ä¸‹æ‰€ç¤ºã€‚ 1234567891011121314/** * @brief Refresh the WWDG. * @param hwwdg pointer to a WWDG_HandleTypeDef structure that contains * the configuration information for the specified WWDG module. * @retval HAL status */HAL_StatusTypeDef HAL_WWDG_Refresh(WWDG_HandleTypeDef *hwwdg)&#123; /* Write to WWDG CR the WWDG Counter value to refresh with */ WRITE_REG(hwwdg-&gt;Instance-&gt;CR, (hwwdg-&gt;Init.Counter)); /* Return function status */ return HAL_OK;&#125; æµ‹è¯•ç¨‹åº&emsp;åœ¨ä¸»ç¨‹åºä¸­æµ‹è¯•WWDGï¼Œç¨‹åºè®¾ç½®å¦‚ä¸‹ï¼š 1234567while (1)&#123; mainloop++; //oled_putuint32(0, 2, mainloop); SYS_Delay_US(9.7*1000); HAL_WWDG_Refresh(&amp;hwwdg); &#125; &emsp;å®éªŒç»“æœå¦‚ä¸‹æ‰€ç¤ºï¼š delayæ—¶é—´ä¸º9.6msï¼Œç³»ç»Ÿå¤ä½ï¼Œç¬¦åˆé¢„æœŸï¼› delayæ—¶é—´ä¸º9.8msï¼Œç³»ç»Ÿæ­£å¸¸ï¼Œç¬¦åˆé¢„æœŸï¼› delayæ—¶é—´ä¸º19.9msï¼Œç³»ç»Ÿå¤ä½ï¼Œä¸ç¬¦åˆé¢„æœŸï¼› delayæ—¶é—´ä¸º20.1msï¼Œç³»ç»Ÿå¤ä½ï¼Œç¬¦åˆé¢„æœŸï¼› &emsp;å®éªŒç»“æœä¸é¢„æœŸä¸ç¬¦åˆï¼Œé™ä½delayæ—¶é—´ç»§ç»­è¿›è¡ŒéªŒè¯ï¼š delayæ—¶é—´è®¾ç½®ä¸º19.5msï¼Œç³»ç»Ÿå¤ä½ï¼› delayæ—¶é—´è®¾ç½®ä¸º19.4msï¼Œç³»ç»Ÿæ­£å¸¸ã€‚ ç”±æ­¤å¯è§ï¼Œå®éªŒç»“æœè¡¨ç¤ºä¸ç†è®ºå€¼æœ‰è¾ƒå¤§è¯¯å·®ã€‚å…·ä½“å·²ç»è”ç³»STè¿›è¡Œè§£å†³ã€‚","categories":[{"name":"åµŒå…¥å¼","slug":"åµŒå…¥å¼","permalink":"http://jiaodi.tech/categories/åµŒå…¥å¼/"}],"tags":[{"name":"STM32F7","slug":"STM32F7","permalink":"http://jiaodi.tech/tags/STM32F7/"},{"name":"WWDG","slug":"WWDG","permalink":"http://jiaodi.tech/tags/WWDG/"}]},{"title":"STM32F767 IWDGçš„åŸºæœ¬ç”¨æ³•","slug":"stm32f767-iwdg","date":"2018-04-21T10:15:04.000Z","updated":"2018-04-27T15:02:39.769Z","comments":true,"path":"2018/04/21/stm32f767-iwdg/","link":"","permalink":"http://jiaodi.tech/2018/04/21/stm32f767-iwdg/","excerpt":"&emsp;æœ¬æ–‡ä»‹ç»STM32F767 IWDG(Independent watchdog)çš„åŸºæœ¬ç”¨æ³•ã€‚","text":"&emsp;æœ¬æ–‡ä»‹ç»STM32F767 IWDG(Independent watchdog)çš„åŸºæœ¬ç”¨æ³•ã€‚ å¼€å‘ç¯å¢ƒç¡¬ä»¶ç¯å¢ƒ ç”µè„‘ï¼šWindows 10 Home x64 Apollo STM32F767å¼€å‘æ¿(ST-LINK V2ä»¿çœŸå™¨) è½¯ä»¶ç¯å¢ƒ Keil Version 5.24.1 (Pack Installerï¼šKeil.STM32F7xx_DFP.2.9.0.pack) STM32CubeMX Version 4.25.0(Packages Managerï¼šSTM32CubeF7) IWDGçš„åŸºæœ¬ç‰¹æ€§ç³»ç»Ÿæ¡†å›¾&emsp;IWDGçš„ç³»ç»Ÿæ¡†å›¾å¦‚ä¸‹æ‰€ç¤ºã€‚ ä¸»è¦ç‰¹æ€§ è‡ªç”±è®¡æ•°é€’å‡è®¡æ•°å™¨ æ—¶é’Ÿæºä¸ºç‹¬ç«‹LSI RCæŒ¯è¡å™¨(å¯ä»¥åœ¨å¾…æœºä¸åœæ­¢æ¨¡å¼ä¸‹è¿è¡Œ) å¤ä½æ¡ä»¶ é€’å‡è®¡æ•°å™¨å€¼å°äº0x000æ—¶(çœ‹é—¨ç‹—æ¿€æ´»çŠ¶æ€ä¸‹) é€’å‡è®¡æ•°å™¨åœ¨çª—å£ä¹‹å¤–æ—¶è¢«é‡è½½(çœ‹é—¨ç‹—æ¿€æ´»çŠ¶æ€ä¸‹) LSIç‰¹æ€§&emsp;IWDGä½¿ç”¨LSIä½œä¸ºæ—¶é’Ÿæºï¼ŒLSIçš„åŸºæœ¬ç‰¹æ€§å¦‚ä¸‹æ‰€ç¤ºã€‚ &emsp;ç”±LSIå‚æ•°å¯ä»¥ï¼Œå…¶æ—¶é’Ÿé¢‘ç‡å¹¶ä¸å‡†ç¡®ã€‚å› æ­¤å…¶ä½œä¸ºæ—¶é’Ÿæºæ—¶å¿…é¡»å……åˆ†è€ƒè™‘å…¶å‚æ•°èŒƒå›´ï¼Œè®¡ç®—å‡ºIWDGå¤ä½çš„æœ€çŸ­æ—¶é—´ï¼Œå¹¶åœ¨æ­¤æ—¶é—´å†…è¿›è¡Œé‡è½½æ“ä½œã€‚ IWDGæº¢å‡ºæ—¶é—´è®¡ç®—&emsp;ç‹¬ç«‹çœ‹é—¨ç‹—çš„æº¢å‡ºæ—¶é—´è®¡ç®—å…¬å¼å¦‚ä¸‹æ‰€ç¤ºï¼š $$T_{overflow}=\\frac{1}{f_{IWDG}}\\cdot Period=\\frac{1}{\\frac{f_{LSI}}{Prescaler}}\\cdot Period$$ &emsp;å³ä¸ºï¼š $$T_{overflow}=\\frac{Prescaler}{f_{LSI}}\\cdot Period$$ &emsp;ä¸¾ä¾‹æ¥è¯´ï¼Œå‡å®šLSIæ—¶é’Ÿé¢‘ç‡ä¸º32kHzï¼Œè®¾ç½®é¢„åˆ†é¢‘å€¼ä¸º64ï¼ŒPeriodå€¼ä¸º500ï¼Œåˆ™IWDGå‘¨æœŸä¸º1sï¼›å¦‚æœLSIæ—¶é’Ÿé¢‘ç‡ä¸º17kHzï¼Œåˆ™IWDGå‘¨æœŸä¸º1.882sï¼›å¦‚æœLSIæ—¶é’Ÿé¢‘ç‡ä¸º47kHzï¼Œåˆ™IWDGå‘¨æœŸä¸º0.681sã€‚ &emsp;è€ƒè™‘åˆ°å¿…é¡»å–æœ€å°æº¢å‡ºæ—¶é—´ï¼Œåˆ™éœ€è¦åœ¨0.681må†…å®Œæˆå–‚ç‹—æ“ä½œã€‚ IWDGçš„åŸºæœ¬ç”¨æ³•IWDGå‚æ•°è®¾ç½®&emsp;IWDGçš„åˆå§‹åŒ–ä»£ç å¦‚ä¸‹æ‰€ç¤ºã€‚ 12345678910111213141516IWDG_HandleTypeDef hiwdg;/* IWDG init function */void MX_IWDG_Init(void)&#123; hiwdg.Instance = IWDG; hiwdg.Init.Prescaler = IWDG_PRESCALER_64; hiwdg.Init.Window = IWDG_WINDOW_DISABLE; hiwdg.Init.Reload = 500; if (HAL_IWDG_Init(&amp;hiwdg) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125;&#125; &emsp;å…¶å‚æ•°è®¾ç½®å¦‚ä¸‹ï¼š é¢„åˆ†é¢‘ç³»æ•°è®¾ç½®ä¸º64ï¼Œå‘¨æœŸå€¼è®¾ç½®ä¸º500ï¼Œåˆ™IWDGæº¢å‡ºæ—¶é—´ä¸º0.681~1.882sï¼› çª—å£å€¼è®¾ç½®ä¸º0xfffï¼Œåˆ™ç­‰æ•ˆäºç¦ç”¨çœ‹é—¨ç‹—çª—å£åŠŸèƒ½ã€‚ IWDGåˆå§‹åŒ–123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * @brief Initialize the IWDG according to the specified parameters in the * IWDG_InitTypeDef and start watchdog. Before exiting function, * watchdog is refreshed in order to have correct time base. * @param hiwdg pointer to a IWDG_HandleTypeDef structure that contains * the configuration information for the specified IWDG module. * @retval HAL status */HAL_StatusTypeDef HAL_IWDG_Init(IWDG_HandleTypeDef *hiwdg)&#123; uint32_t tickstart; /* Check the IWDG handle allocation */ if(hiwdg == NULL) &#123; return HAL_ERROR; &#125; /* Check the parameters */ assert_param(IS_IWDG_ALL_INSTANCE(hiwdg-&gt;Instance)); assert_param(IS_IWDG_PRESCALER(hiwdg-&gt;Init.Prescaler)); assert_param(IS_IWDG_RELOAD(hiwdg-&gt;Init.Reload)); assert_param(IS_IWDG_WINDOW(hiwdg-&gt;Init.Window)); /* Enable IWDG. LSI is turned on automaticaly */ __HAL_IWDG_START(hiwdg); /* Enable write access to IWDG_PR, IWDG_RLR and IWDG_WINR registers by writing 0x5555 in KR */ IWDG_ENABLE_WRITE_ACCESS(hiwdg); /* Write to IWDG registers the Prescaler &amp; Reload values to work with */ hiwdg-&gt;Instance-&gt;PR = hiwdg-&gt;Init.Prescaler; hiwdg-&gt;Instance-&gt;RLR = hiwdg-&gt;Init.Reload; /* Check pending flag, if previous update not done, return timeout */ tickstart = HAL_GetTick(); /* Wait for register to be updated */ while(hiwdg-&gt;Instance-&gt;SR != RESET) &#123; if((HAL_GetTick() - tickstart ) &gt; HAL_IWDG_DEFAULT_TIMEOUT) &#123; return HAL_TIMEOUT; &#125; &#125; /* If window parameter is different than current value, modify window register */ if(hiwdg-&gt;Instance-&gt;WINR != hiwdg-&gt;Init.Window) &#123; /* Write to IWDG WINR the IWDG_Window value to compare with. In any case, even if window feature is disabled, Watchdog will be reloaded by writing windows register */ hiwdg-&gt;Instance-&gt;WINR = hiwdg-&gt;Init.Window; &#125; else &#123; /* Reload IWDG counter with value defined in the reload register */ __HAL_IWDG_RELOAD_COUNTER(hiwdg); &#125; /* Return function status */ return HAL_OK;&#125; * @brief Enable the IWDG peripheral. * @param __HANDLE__ IWDG handle * @retval None */#define __HAL_IWDG_START(__HANDLE__) WRITE_REG((__HANDLE__)-&gt;Instance-&gt;KR, IWDG_KEY_ENABLE) * @brief Enable write access to IWDG_PR, IWDG_RLR and IWDG_WINR registers. * @param __HANDLE__ IWDG handle * @retval None */#define IWDG_ENABLE_WRITE_ACCESS(__HANDLE__) WRITE_REG((__HANDLE__)-&gt;Instance-&gt;KR, IWDG_KEY_WRITE_ACCESS_ENABLE) * @brief Reload IWDG counter with value defined in the reload register * (write access to IWDG_PR, IWDG_RLR &amp; IWDG_WINR registers disabled). * @param __HANDLE__ IWDG handle * @retval None */#define __HAL_IWDG_RELOAD_COUNTER(__HANDLE__) WRITE_REG((__HANDLE__)-&gt;Instance-&gt;KR, IWDG_KEY_RELOAD) 1234567/** * @brief IWDG Key Register BitMask */#define IWDG_KEY_RELOAD 0x0000AAAAu /*!&lt; IWDG Reload Counter Enable */#define IWDG_KEY_ENABLE 0x0000CCCCu /*!&lt; IWDG Peripheral Enable */#define IWDG_KEY_WRITE_ACCESS_ENABLE 0x00005555u /*!&lt; IWDG KR Write Access Enable */#define IWDG_KEY_WRITE_ACCESS_DISABLE 0x00000000u /*!&lt; IWDG KR Write Access Disable */ &emsp;IWDGåˆå§‹åŒ–æµç¨‹å¦‚ä¸‹ï¼š å‘IWDG_KRå¯„å­˜å™¨å†™å…¥IWDG_KEY_ENABLE(0x0000CCCCu)å€¼ï¼Œåˆ™å¯åŠ¨IWDGï¼Œè®¡æ•°å™¨å¼€å§‹ä»å¤ä½å€¼0xfffé€’å‡æŠ€æœ¯ï¼› å‘IWDG_KRå¯„å­˜å™¨å†™å…¥IWDG_KEY_WRITE_ACCESS_ENABLE(0x00005555u)å€¼ï¼Œåˆ™ä½¿èƒ½å¯„å­˜å™¨è®¿é—®ï¼› å‘IWDG_PRå¯„å­˜å™¨å†™å…¥Prescalerå€¼ï¼› å‘IWDG_RLRå¯„å­˜å™¨å†™å…¥Period(Reload)å€¼ï¼› é€šè¿‡è¯»å–IWDG_SRå¯„å­˜å™¨å€¼ï¼Œç­‰å¾…å¯„å­˜å™¨æ›´æ–°å®Œæˆï¼› å‘IWDG_KRå¯„å­˜å™¨å†™å…¥IWDG_KEY_RELOAD(0x0000AAAAu)å€¼ï¼Œåˆ·æ–°IWDGè®¡æ•°å™¨å€¼ã€‚ åˆ·æ–°IWDGå‡½æ•°&emsp;åˆ·æ–°IWDGçš„å‡½æ•°å¦‚ä¸‹ï¼Œå³é€šè¿‡å‘IWDG_KRå¯„å­˜å™¨å†™å…¥IWDG_KEY_RELOAD(0x0000AAAAu)å€¼ï¼Œåˆ·æ–°IWDGè®¡æ•°å™¨å€¼ã€‚ 12345678910111213141516171819202122/** * @brief Refresh the IWDG. * @param hiwdg pointer to a IWDG_HandleTypeDef structure that contains * the configuration information for the specified IWDG module. * @retval HAL status */HAL_StatusTypeDef HAL_IWDG_Refresh(IWDG_HandleTypeDef *hiwdg)&#123; /* Reload IWDG counter with value defined in the reload register */ __HAL_IWDG_RELOAD_COUNTER(hiwdg); /* Return function status */ return HAL_OK;&#125;/** * @brief Reload IWDG counter with value defined in the reload register * (write access to IWDG_PR, IWDG_RLR &amp; IWDG_WINR registers disabled). * @param __HANDLE__ IWDG handle * @retval None */#define __HAL_IWDG_RELOAD_COUNTER(__HANDLE__) WRITE_REG((__HANDLE__)-&gt;Instance-&gt;KR, IWDG_KEY_RELOAD) æµ‹è¯•ç¨‹åº&emsp;åœ¨ä¸»ç¨‹åºä¸­æµ‹è¯•IWDGï¼Œç¨‹åºè®¾è®¡å¦‚ä¸‹ï¼š 12345678910while (1)&#123; mainloop++; oled_putuint32(0, 2, mainloop); HAL_IWDG_Refresh(&amp;hiwdg); SYS_Delay_US(600*1000); &#125; Delayæ—¶é—´è®¾ç½®ä¸º600msï¼Œè¿è¡Œæµ‹è¯•ç¨‹åºï¼Œå¯ä»¥çœ‹åˆ°mainloopä¸æ–­å¢åŠ ï¼Œç¨‹åºæ­£å¸¸è¿è¡Œã€‚è¯´æ˜åœ¨IWDGè®¡æ•°å€¼æº¢å‡ºå‰å®Œæˆåˆ·æ–°ï¼Œçœ‹é—¨ç‹—æœªå¯¼è‡´ç³»ç»Ÿå¤ä½ï¼› Delayæ—¶é—´è®¾ç½®ä¸º1900msï¼Œè¿è¡Œæµ‹è¯•ç¨‹åºï¼Œå¯ä»¥çœ‹åˆ°mainloopæ˜¾ç¤ºä¸º1åç³»ç»Ÿå¤ä½ï¼Œå¦‚æ­¤åå¤ã€‚è¯´æ˜æœªåœ¨IWDGè®¡æ•°å€¼æº¢å‡ºå‰å®Œæˆåˆ·æ–°ï¼Œçœ‹é—¨ç‹—å¯¼è‡´äº†ç³»ç»Ÿå¤ä½ã€‚","categories":[{"name":"åµŒå…¥å¼","slug":"åµŒå…¥å¼","permalink":"http://jiaodi.tech/categories/åµŒå…¥å¼/"}],"tags":[{"name":"STM32F7","slug":"STM32F7","permalink":"http://jiaodi.tech/tags/STM32F7/"},{"name":"IWDG","slug":"IWDG","permalink":"http://jiaodi.tech/tags/IWDG/"}]},{"title":"STM32F767 Timerä¸­æ–­çš„åŸºæœ¬ç”¨æ³•","slug":"stm32f767-timer","date":"2018-04-16T14:52:17.000Z","updated":"2018-05-09T14:58:23.164Z","comments":true,"path":"2018/04/16/stm32f767-timer/","link":"","permalink":"http://jiaodi.tech/2018/04/16/stm32f767-timer/","excerpt":"&emsp;æœ¬æ–‡ä»‹ç»STM32F767 Timerä¸­æ–­çš„åŸºæœ¬ç”¨æ³•ã€‚","text":"&emsp;æœ¬æ–‡ä»‹ç»STM32F767 Timerä¸­æ–­çš„åŸºæœ¬ç”¨æ³•ã€‚ å¼€å‘ç¯å¢ƒç¡¬ä»¶ç¯å¢ƒ ç”µè„‘ï¼šWindows 10 Home x64 Apollo STM32F767å¼€å‘æ¿(ST-LINK V2ä»¿çœŸå™¨) è½¯ä»¶ç¯å¢ƒ Keil Version 5.24.1 (Pack Installerï¼šKeil.STM32F7xx_DFP.2.9.0.pack) STM32CubeMX Version 4.25.0(Packages Managerï¼šSTM32CubeF7) TIMçš„åŸºæœ¬ç‰¹æ€§TIMåˆ†ç±»&emsp;åœ¨STM32F767ä¸­ï¼ŒTIMå®šæ—¶å™¨å…±åˆ†ä¸º3ç±»ï¼šåŸºæœ¬å®šæ—¶å™¨ã€åŸºæœ¬é€šç”¨å®šæ—¶å™¨ã€é€šç”¨å®šæ—¶å™¨ã€é«˜çº§æ§åˆ¶å®šæ—¶å™¨ä¸ä½åŠŸè€—å®šæ—¶å™¨ã€‚ åŸºæœ¬å®šæ—¶å™¨&emsp;TIM6/TIM7ä¸ºåŸºæœ¬å®šæ—¶å™¨ï¼Œå…·å¤‡çš„åŠŸèƒ½æœ‰ï¼š 16 ä½è‡ªåŠ¨é‡è½½é€’å¢è®¡æ•°å™¨ 16 ä½å¯ç¼–ç¨‹é¢„åˆ†é¢‘å™¨ï¼Œç”¨äºå¯¹è®¡æ•°å™¨æ—¶é’Ÿé¢‘ç‡è¿›è¡Œåˆ†é¢‘ï¼ˆå¯åœ¨è¿è¡Œæ—¶ä¿®æ”¹ï¼‰ï¼Œåˆ†é¢‘ç³»æ•°ä»‹äº 1 å’Œ 65536 ä¹‹é—´ ç”¨äºè§¦å‘ DAC çš„åŒæ­¥ç”µè·¯ å‘ç”Ÿå¦‚ä¸‹æ›´æ–°äº‹ä»¶æ—¶ä¼šç”Ÿæˆä¸­æ–­/DMA è¯·æ±‚ï¼šè®¡æ•°å™¨ä¸Šæº¢ åŸºæœ¬é€šç”¨å®šæ—¶å™¨&emsp;TIM9/TIM10/TIM11/TIM12/TIM13/TIM14ä¸ºåŸºæœ¬é€šç”¨å®šæ—¶å™¨ï¼Œå…·å¤‡çš„åŠŸèƒ½æœ‰ï¼š 16 ä½è‡ªåŠ¨é‡è½½é€’å¢è®¡æ•°å™¨ 16 ä½å¯ç¼–ç¨‹é¢„åˆ†é¢‘å™¨ï¼Œç”¨äºå¯¹è®¡æ•°å™¨æ—¶é’Ÿé¢‘ç‡è¿›è¡Œåˆ†é¢‘ï¼ˆå¯åœ¨è¿è¡Œæ—¶ä¿®æ”¹ï¼‰ï¼Œåˆ†é¢‘ç³»æ•°ä»‹äº 1 å’Œ 65536 ä¹‹é—´ å¤šè¾¾ 2 ä¸ªç‹¬ç«‹é€šé“ï¼Œå¯ç”¨äºï¼šè¾“å…¥æ•è·ã€è¾“å‡ºæ¯”è¾ƒã€PWMç”Ÿæˆ(è¾¹æ²¿å¯¹é½)ã€å•è„‰å†²æ¨¡å¼è¾“å‡º ä½¿ç”¨å¤–éƒ¨ä¿¡å·æ§åˆ¶å®šæ—¶å™¨ä¸”å¯å®ç°å¤šä¸ªå®šæ—¶å™¨äº’è¿çš„åŒæ­¥ç”µè·¯ å‘ç”Ÿå¦‚ä¸‹äº‹ä»¶æ—¶ç”Ÿæˆä¸­æ–­ï¼šæ›´æ–°(è®¡æ•°å™¨ä¸Šæº¢ã€è®¡æ•°å™¨åˆå§‹åŒ–(é€šè¿‡è½¯ä»¶æˆ–å†…éƒ¨è§¦å‘))ã€è§¦å‘äº‹ä»¶(è®¡æ•°å™¨å¯åŠ¨ã€åœæ­¢ã€åˆå§‹åŒ–æˆ–è€…ç”±å†…éƒ¨è§¦å‘è®¡æ•°)ã€è¾“å…¥æ•è·ã€è¾“å‡ºæ¯”è¾ƒ é€šç”¨å®šæ—¶å™¨&emsp;TIM2/TIM3/TIM4/TIM5ä¸ºé€šç”¨å®šæ—¶å™¨ï¼Œå…·å¤‡çš„åŠŸèƒ½æœ‰ï¼š 16 ä½ï¼ˆTIM3 å’Œ TIM4ï¼‰æˆ– 32 ä½ï¼ˆTIM2 å’Œ TIM5ï¼‰é€’å¢ã€é€’å‡å’Œé€’å¢/é€’å‡è‡ªåŠ¨é‡è½½è®¡æ•°å™¨ 16 ä½å¯ç¼–ç¨‹é¢„åˆ†é¢‘å™¨ï¼Œç”¨äºå¯¹è®¡æ•°å™¨æ—¶é’Ÿé¢‘ç‡è¿›è¡Œåˆ†é¢‘(å¯åœ¨è¿è¡Œæ—¶ä¿®æ”¹)ï¼Œåˆ†é¢‘ç³»æ•°ä»‹äº 1 åˆ° 65535 ä¹‹é—´ å¤šè¾¾ 4 ä¸ªç‹¬ç«‹é€šé“ï¼Œå¯ç”¨äºï¼šè¾“å…¥æ•è·ã€è¾“å‡ºæ¯”è¾ƒã€PWMç”Ÿæˆ(è¾¹æ²¿å’Œä¸­å¿ƒå¯¹é½)ã€å•è„‰å†²æ¨¡å¼è¾“å‡º ä½¿ç”¨å¤–éƒ¨ä¿¡å·æ§åˆ¶å®šæ—¶å™¨ä¸”å¯å®ç°å¤šä¸ªå®šæ—¶å™¨äº’è¿çš„åŒæ­¥ç”µè·¯ å‘ç”Ÿå¦‚ä¸‹äº‹ä»¶æ—¶ç”Ÿæˆä¸­æ–­ï¼šæ›´æ–°(è®¡æ•°å™¨ä¸Šæº¢/ä¸‹æº¢ã€è®¡æ•°å™¨åˆå§‹åŒ–(é€šè¿‡è½¯ä»¶æˆ–å†…éƒ¨/å¤–éƒ¨è§¦å‘))ã€è§¦å‘äº‹ä»¶(è®¡æ•°å™¨å¯åŠ¨ã€åœæ­¢ã€åˆå§‹åŒ–æˆ–è€…ç”±å†…éƒ¨/å¤–éƒ¨è§¦å‘è®¡æ•°)ã€è¾“å…¥æ•è·ã€è¾“å‡ºæ¯”è¾ƒ æ”¯æŒå®šä½ç”¨å¢é‡ï¼ˆæ­£äº¤ï¼‰ç¼–ç å™¨å’Œéœå°”ä¼ æ„Ÿå™¨ç”µè·¯ è§¦å‘è¾“å…¥ä½œä¸ºå¤–éƒ¨æ—¶é’Ÿæˆ–è€…é€å‘¨æœŸç”µæµç®¡ç† é«˜çº§æ§åˆ¶å®šæ—¶å™¨&emsp;TIM1/TIM8ä¸ºé«˜çº§æ§åˆ¶å®šæ—¶å™¨ï¼Œå…·å¤‡çš„åŠŸèƒ½æœ‰ï¼š 16 ä½é€’å¢ã€é€’å‡ã€é€’å¢/é€’å‡è‡ªåŠ¨é‡è½½è®¡æ•°å™¨ 16 ä½å¯ç¼–ç¨‹é¢„åˆ†é¢‘å™¨ï¼Œç”¨äºå¯¹è®¡æ•°å™¨æ—¶é’Ÿé¢‘ç‡è¿›è¡Œåˆ†é¢‘(å¯åœ¨è¿è¡Œæ—¶ä¿®æ”¹)ï¼Œåˆ†é¢‘ç³»æ•°ä»‹äº 1 åˆ° 65536 ä¹‹é—´ å¤šè¾¾ 6 ä¸ªç‹¬ç«‹é€šé“ï¼Œå¯ç”¨äºï¼šè¾“å…¥æ•è·(ä½†é€šé“ 5 å’Œé€šé“ 6 é™¤å¤–)ã€è¾“å‡ºæ¯”è¾ƒã€PWMç”Ÿæˆ(è¾¹æ²¿å’Œä¸­å¿ƒå¯¹é½)ã€å•è„‰å†²æ¨¡å¼è¾“å‡º å¸¦å¯ç¼–ç¨‹æ­»åŒºçš„äº’è¡¥è¾“å‡º ä½¿ç”¨å¤–éƒ¨ä¿¡å·æ§åˆ¶å®šæ—¶å™¨ä¸”å¯å®ç°å¤šä¸ªå®šæ—¶å™¨äº’è¿çš„åŒæ­¥ç”µè·¯ é‡å¤è®¡æ•°å™¨ï¼Œç”¨äºä»…åœ¨ç»™å®šæ•°ç›®çš„è®¡æ•°å™¨å‘¨æœŸåæ›´æ–°å®šæ—¶å™¨å¯„å­˜å™¨ å…·æœ‰2 ä¸ªæ–­è·¯è¾“å…¥ï¼Œç”¨äºå°†å®šæ—¶å™¨çš„è¾“å‡ºä¿¡å·ç½®äºç”¨æˆ·å¯é€‰çš„å®‰å…¨é…ç½®ä¸­ å‘ç”Ÿå¦‚ä¸‹äº‹ä»¶æ—¶ç”Ÿæˆä¸­æ–­/DMA è¯·æ±‚ï¼šæ›´æ–°(è®¡æ•°å™¨ä¸Šæº¢/ä¸‹æº¢ã€è®¡æ•°å™¨åˆå§‹åŒ–(é€šè¿‡è½¯ä»¶æˆ–å†…éƒ¨/å¤–éƒ¨è§¦å‘))ã€è§¦å‘äº‹ä»¶(è®¡æ•°å™¨å¯åŠ¨ã€åœæ­¢ã€åˆå§‹åŒ–æˆ–è€…ç”±å†…éƒ¨/å¤–éƒ¨è§¦å‘è®¡æ•°)ã€è¾“å…¥æ•è·ã€è¾“å‡ºæ¯”è¾ƒ æ”¯æŒå®šä½ç”¨å¢é‡ï¼ˆæ­£äº¤ï¼‰ç¼–ç å™¨å’Œéœå°”ä¼ æ„Ÿå™¨ç”µè·¯ è§¦å‘è¾“å…¥ä½œä¸ºå¤–éƒ¨æ—¶é’Ÿæˆ–è€…é€å‘¨æœŸç”µæµç®¡ç† TIM2åŸºæœ¬ç‰¹æ€§&emsp;æœ¬ä¾‹ä¸­ï¼Œä½¿ç”¨TIM2å®šæ—¶å™¨å®Œæˆå®éªŒã€‚TIM2çš„åŸºæœ¬ç‰¹æ€§å¦‚ä¸‹ï¼š ä¸ºé€šç”¨å®šæ—¶å™¨ï¼› 32 ä½é€’å¢ã€é€’å‡å’Œé€’å¢/é€’å‡è‡ªåŠ¨é‡è½½è®¡æ•°å™¨ï¼› æ—¶é’Ÿæºä¸ºAPB1ï¼Œé¢‘ç‡ä¸º108MHzã€‚ åŸºäºTIM2çš„timerä¸­æ–­åŸºæœ¬ç”¨æ³•ç³»ç»Ÿæ¡†å›¾&emsp;é€šç”¨å®šæ—¶å™¨çš„ç³»ç»Ÿæ¡†å›¾å¦‚å›¾æ‰€ç¤ºã€‚æœ¬æ¬¡è¿›è¡Œå®šæ—¶å™¨ä¸­æ–­å®éªŒåªéœ€è¦ç”¨åˆ°è®¡æ•°ä»¥åŠä¸­æ–­éƒ¨åˆ†ã€‚ Timerä»£ç è®¾ç½®ä»£ç æ¦‚è¿°&emsp;Timerçš„åˆå§‹åŒ–ä»£ç å¦‚ä¸‹æ‰€ç¤ºã€‚å…¶åˆå§‹åŒ–ä¸»è¦ç”±3ä¸ªå‡½æ•°å®Œæˆï¼Œä»¥ä¸‹å°†å¯¹è¿™3ä¸ªå‡½æ•°è¿›è¡Œç®€è¦è¯´æ˜ã€‚ 123456789101112131415161718192021222324252627282930313233TIM_HandleTypeDef htim2;/* TIM2 init function */void MX_TIM2_Init(void)&#123; TIM_ClockConfigTypeDef sClockSourceConfig; TIM_MasterConfigTypeDef sMasterConfig; htim2.Instance = TIM2; htim2.Init.Prescaler = 10800 - 1; htim2.Init.CounterMode = TIM_COUNTERMODE_UP; htim2.Init.Period = 5000 - 1; htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1; htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE; if (HAL_TIM_Base_Init(&amp;htim2) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL; if (HAL_TIM_ConfigClockSource(&amp;htim2, &amp;sClockSourceConfig) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE; sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE; if (HAL_TIMEx_MasterConfigSynchronization(&amp;htim2, &amp;sMasterConfig) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125;&#125; æ—¶åŸºå•å…ƒåˆå§‹åŒ–&emsp;æ—¶åŸºå•å…ƒåˆå§‹åŒ–é€šè¿‡HAL_TIM_Base_Init()å‡½æ•°å®ç°ï¼Œå…·ä½“å¦‚ä¸‹ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * @brief Initializes the TIM Time base Unit according to the specified * parameters in the TIM_HandleTypeDef and create the associated handle. * @param htim pointer to a TIM_HandleTypeDef structure that contains * the configuration information for TIM module. * @retval HAL status */HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)&#123; /* Check the TIM handle allocation */ if(htim == NULL) &#123; return HAL_ERROR; &#125; /* Check the parameters */ assert_param(IS_TIM_INSTANCE(htim-&gt;Instance)); assert_param(IS_TIM_COUNTER_MODE(htim-&gt;Init.CounterMode)); assert_param(IS_TIM_CLOCKDIVISION_DIV(htim-&gt;Init.ClockDivision)); assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim-&gt;Init.AutoReloadPreload)); if(htim-&gt;State == HAL_TIM_STATE_RESET) &#123; /* Allocate lock resource and initialize it */ htim-&gt;Lock = HAL_UNLOCKED;#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1) /* Reset interrupt callbacks to legacy week callbacks */ TIM_ResetCallback(htim); if(htim-&gt;Base_MspInitCallback == NULL) &#123; htim-&gt;Base_MspInitCallback = HAL_TIM_Base_MspInit; &#125; /* Init the low level hardware : GPIO, CLOCK, NVIC */ htim-&gt;Base_MspInitCallback(htim);#else /* Init the low level hardware : GPIO, CLOCK, NVIC */ HAL_TIM_Base_MspInit(htim);#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */ &#125; /* Set the TIM state */ htim-&gt;State= HAL_TIM_STATE_BUSY; /* Set the Time Base configuration */ TIM_Base_SetConfig(htim-&gt;Instance, &amp;htim-&gt;Init); /* Initialize the TIM state*/ htim-&gt;State= HAL_TIM_STATE_READY; return HAL_OK;&#125; &emsp;ç¨‹åºä¸­è°ƒç”¨äº†HAL_TIM_Base_MspInit()å‡½æ•°ï¼Œè¯¥å‡½æ•°å®ŒæˆTIM2 RCCæ—¶é’Ÿçš„ä½¿èƒ½ã€NVICçš„ä½¿èƒ½ä»¥åŠä¼˜å…ˆçº§è®¾ç½®ã€‚ 12345678910111213141516171819void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* tim_baseHandle)&#123; if(tim_baseHandle-&gt;Instance==TIM2) &#123; /* USER CODE BEGIN TIM2_MspInit 0 */ /* USER CODE END TIM2_MspInit 0 */ /* TIM2 clock enable */ __HAL_RCC_TIM2_CLK_ENABLE(); /* TIM2 interrupt Init */ HAL_NVIC_SetPriority(TIM2_IRQn, 1, 1); HAL_NVIC_EnableIRQ(TIM2_IRQn); /* USER CODE BEGIN TIM2_MspInit 1 */ /* USER CODE END TIM2_MspInit 1 */ &#125;&#125; &emsp;ç¨‹åºä¸­ä¹‹åè°ƒç”¨çš„TIM_Base_SetConfig()å‡½æ•°ä¸ºæ—¶åŸºå•å…ƒçš„è®¾ç½®ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * @brief Time Base configuration * @param TIMx TIM peripheral * @param Structure pointer on TIM Time Base required parameters * @retval None */void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)&#123; uint32_t tmpcr1 = 0; tmpcr1 = TIMx-&gt;CR1; /* Set TIM Time Base Unit parameters ---------------------------------------*/ if(IS_TIM_CC3_INSTANCE(TIMx) != RESET) &#123; /* Select the Counter Mode */ tmpcr1 &amp;= ~(TIM_CR1_DIR | TIM_CR1_CMS); tmpcr1 |= Structure-&gt;CounterMode; &#125; if(IS_TIM_CC1_INSTANCE(TIMx) != RESET) &#123; /* Set the clock division */ tmpcr1 &amp;= ~TIM_CR1_CKD; tmpcr1 |= (uint32_t)Structure-&gt;ClockDivision; &#125; /* Set the auto-reload preload */ MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure-&gt;AutoReloadPreload); TIMx-&gt;CR1 = tmpcr1; /* Set the Auto-reload value */ TIMx-&gt;ARR = (uint32_t)Structure-&gt;Period ; /* Set the Prescaler value */ TIMx-&gt;PSC = (uint32_t)Structure-&gt;Prescaler; if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET) &#123; /* Set the Repetition Counter value */ TIMx-&gt;RCR = Structure-&gt;RepetitionCounter; &#125; /* Generate an update event to reload the Prescaler and the repetition counter(only for TIM1 and TIM8) value immediately */ TIMx-&gt;EGR = TIM_EGR_UG;&#125; &emsp;è¯¥å‡½æ•°çš„åŠŸèƒ½ç®€ä»‹å¦‚ä¸‹ï¼š tmpcr1ä¸ºTIMx-&gt;CR1å¯„å­˜å™¨çš„å¾…å†™å…¥å€¼ï¼Œè¯¥å€¼é¦–å…ˆä¿å­˜TIMx-&gt;CR1å¯„å­˜å™¨å½“å‰å€¼ï¼› ç»è¿‡IS_TIM_CC3_INSTANCEå®ä¾‹æ£€æµ‹åï¼Œtmpcr1è®¾ç½®è®¡æ•°å™¨æ¨¡å¼ï¼Œæœ¬ä¾‹ä¸ºå¢è®¡æ•°ï¼› ç»è¿‡IS_TIM_CC1_INSTANCEå®ä¾‹æ£€æµ‹åï¼Œtmpcr1è®¾ç½®è®¡æ—¶å™¨ä¸­é¢‘ç‡ä¸æ•°å­—æ»¤æ³¢å™¨æ‰€ç”¨æ—¶é’ŸETRã€TIxçš„åˆ†é¢‘æ¯”ï¼Œæœ¬ä¾‹ä¸ºä¸åˆ†é¢‘ï¼› MODIFY_REG()å‡½æ•°è®¾ç½®tmpcr1çš„ARPEä½ï¼Œæœ¬ä¾‹ä¸ºTIMx_ARR å¯„å­˜å™¨ä¸è¿›è¡Œç¼“å†²ï¼› å°†tmpcr1å†™å…¥åˆ°TIMx-&gt;CR1å¯„å­˜å™¨ï¼› TIMx-&gt;ARRå†™å…¥å®šæ—¶å™¨å‘¨æœŸå€¼ï¼Œæœ¬ä¾‹å†™å…¥å€¼ä¸º5000-1ï¼Œè€ƒè™‘åˆ°è®¡æ•°å€¼ä»0å¼€å§‹ï¼Œæ‰€ä»¥ä¸€ä¸ªå‘¨æœŸå†…å…±è®¡æ•°5000æ¬¡ï¼› TIMx-&gt;PSCå†™å…¥å®šæ—¶å™¨é¢„åˆ†é¢‘å™¨å€¼ï¼Œè®¡æ•°å™¨æ—¶é’Ÿé¢‘ç‡ CK_CNT ç­‰äº $f_{CK_PSC} / (PSC[15:0] + 1)$ã€‚æœ¬ä¾‹å†™å…¥å€¼ä¸º10800 - 1ï¼Œåˆ™æ—¶é’Ÿé¢‘ç‡ä¸º108MHz/10800=10kHzï¼› å®šæ—¶å™¨æ—¶é’Ÿä¸º10kHzï¼Œè®¡æ•°å€¼ä¸º5000ï¼Œåˆ™å®šæ—¶å™¨å‘¨æœŸä¸º500msï¼› å‘TIMx-&gt;EGRå¯„å­˜å™¨UGä½å†™å…¥1ï¼Œç”Ÿæˆæ›´æ–°äº‹ä»¶ï¼Œæ›´æ–°è®¡æ•°å™¨å€¼ä»¥åŠé¢„åˆ†é¢‘è®¡æ•°å™¨ã€‚ æ—¶é’Ÿæºè®¾ç½®&emsp;æ—¶é’Ÿæºçš„é€‰æ‹©é€šè¿‡å¦‚ä¸‹å‡½æ•°å®ç°ã€‚æœ¬ä¾‹ä¸­æ—¶é’Ÿé€‰æ‹©ä¸ºå†…éƒ¨æ—¶é’Ÿï¼Œå³å°†TIMx_SMCRå¯„å­˜å™¨SMSæ§åˆ¶ä½è®¾ç½®ä¸º0000ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;if (HAL_TIM_ConfigClockSource(&amp;htim2, &amp;sClockSourceConfig) != HAL_OK)&#123; _Error_Handler(__FILE__, __LINE__);&#125;/** * @brief Configures the clock source to be used * @param htim pointer to a TIM_HandleTypeDef structure that contains * the configuration information for TIM module. * @param sClockSourceConfig pointer to a TIM_ClockConfigTypeDef structure that * contains the clock source information for the TIM peripheral. * @retval HAL status */ HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig) &#123; uint32_t tmpsmcr = 0; /* Process Locked */ __HAL_LOCK(htim); htim-&gt;State = HAL_TIM_STATE_BUSY; /* Check the parameters */ assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig-&gt;ClockSource)); /* Reset the SMS, TS, ECE, ETPS and ETRF bits */ tmpsmcr = htim-&gt;Instance-&gt;SMCR; tmpsmcr &amp;= ~(TIM_SMCR_SMS | TIM_SMCR_TS); tmpsmcr &amp;= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP); htim-&gt;Instance-&gt;SMCR = tmpsmcr; switch (sClockSourceConfig-&gt;ClockSource) &#123; case TIM_CLOCKSOURCE_INTERNAL: &#123; assert_param(IS_TIM_INSTANCE(htim-&gt;Instance)); /* Disable slave mode to clock the prescaler directly with the internal clock */ htim-&gt;Instance-&gt;SMCR &amp;= ~TIM_SMCR_SMS; &#125; break; case TIM_CLOCKSOURCE_ETRMODE1: &#123; assert_param(IS_TIM_ETR_INSTANCE(htim-&gt;Instance)); assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig-&gt;ClockPolarity)); assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig-&gt;ClockPrescaler)); assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig-&gt;ClockFilter)); /* Configure the ETR Clock source */ TIM_ETR_SetConfig(htim-&gt;Instance, sClockSourceConfig-&gt;ClockPrescaler, sClockSourceConfig-&gt;ClockPolarity, sClockSourceConfig-&gt;ClockFilter); /* Get the TIMx SMCR register value */ tmpsmcr = htim-&gt;Instance-&gt;SMCR; /* Reset the SMS and TS Bits */ tmpsmcr &amp;= ~(TIM_SMCR_SMS | TIM_SMCR_TS); /* Select the External clock mode1 and the ETRF trigger */ tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1); /* Write to TIMx SMCR */ htim-&gt;Instance-&gt;SMCR = tmpsmcr; &#125; break; case TIM_CLOCKSOURCE_ETRMODE2: &#123; assert_param(IS_TIM_ETR_INSTANCE(htim-&gt;Instance)); assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig-&gt;ClockPolarity)); assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig-&gt;ClockPrescaler)); assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig-&gt;ClockFilter)); /* Configure the ETR Clock source */ TIM_ETR_SetConfig(htim-&gt;Instance, sClockSourceConfig-&gt;ClockPrescaler, sClockSourceConfig-&gt;ClockPolarity, sClockSourceConfig-&gt;ClockFilter); /* Enable the External clock mode2 */ htim-&gt;Instance-&gt;SMCR |= TIM_SMCR_ECE; &#125; break; case TIM_CLOCKSOURCE_TI1: &#123; assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim-&gt;Instance)); /* Check TI1 input conditioning related parameters */ assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig-&gt;ClockPolarity)); assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig-&gt;ClockFilter)); TIM_TI1_ConfigInputStage(htim-&gt;Instance, sClockSourceConfig-&gt;ClockPolarity, sClockSourceConfig-&gt;ClockFilter); TIM_ITRx_SetConfig(htim-&gt;Instance, TIM_CLOCKSOURCE_TI1); &#125; break; case TIM_CLOCKSOURCE_TI2: &#123; assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim-&gt;Instance)); /* Check TI1 input conditioning related parameters */ assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig-&gt;ClockPolarity)); assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig-&gt;ClockFilter)); TIM_TI2_ConfigInputStage(htim-&gt;Instance, sClockSourceConfig-&gt;ClockPolarity, sClockSourceConfig-&gt;ClockFilter); TIM_ITRx_SetConfig(htim-&gt;Instance, TIM_CLOCKSOURCE_TI2); &#125; break; case TIM_CLOCKSOURCE_TI1ED: &#123; assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim-&gt;Instance)); /* Check TI1 input conditioning related parameters */ assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig-&gt;ClockPolarity)); assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig-&gt;ClockFilter)); TIM_TI1_ConfigInputStage(htim-&gt;Instance, sClockSourceConfig-&gt;ClockPolarity, sClockSourceConfig-&gt;ClockFilter); TIM_ITRx_SetConfig(htim-&gt;Instance, TIM_CLOCKSOURCE_TI1ED); &#125; break; case TIM_CLOCKSOURCE_ITR0: &#123; assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim-&gt;Instance)); TIM_ITRx_SetConfig(htim-&gt;Instance, TIM_CLOCKSOURCE_ITR0); &#125; break; case TIM_CLOCKSOURCE_ITR1: &#123; assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim-&gt;Instance)); TIM_ITRx_SetConfig(htim-&gt;Instance, TIM_CLOCKSOURCE_ITR1); &#125; break; case TIM_CLOCKSOURCE_ITR2: &#123; assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim-&gt;Instance)); TIM_ITRx_SetConfig(htim-&gt;Instance, TIM_CLOCKSOURCE_ITR2); &#125; break; case TIM_CLOCKSOURCE_ITR3: &#123; assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim-&gt;Instance)); TIM_ITRx_SetConfig(htim-&gt;Instance, TIM_CLOCKSOURCE_ITR3); &#125; break; default: break; &#125; htim-&gt;State = HAL_TIM_STATE_READY; __HAL_UNLOCK(htim); return HAL_OK;&#125; ä¸»æ¨¡å¼è®¾ç½®&emsp;è®¾ç½®æ—¶é’Ÿä¸»æ¨¡å¼çš„è®¾ç½®é€šè¿‡å¦‚ä¸‹ä»£ç å®ç°ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;if (HAL_TIMEx_MasterConfigSynchronization(&amp;htim2, &amp;sMasterConfig) != HAL_OK)&#123; _Error_Handler(__FILE__, __LINE__);&#125;/** * @brief Configures the TIM in master mode. * @param htim pointer to a TIM_HandleTypeDef structure that contains * the configuration information for TIM module. * @param sMasterConfig pointer to a TIM_MasterConfigTypeDef structure that * contains the selected trigger output (TRGO) and the Master/Slave * mode. * @retval HAL status */HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim, TIM_MasterConfigTypeDef * sMasterConfig)&#123; uint32_t tmpcr2; uint32_t tmpsmcr; /* Check the parameters */ assert_param(IS_TIM_SYNCHRO_INSTANCE(htim-&gt;Instance)); assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig-&gt;MasterOutputTrigger)); assert_param(IS_TIM_MSM_STATE(sMasterConfig-&gt;MasterSlaveMode)); /* Check input state */ __HAL_LOCK(htim); /* Get the TIMx CR2 register value */ tmpcr2 = htim-&gt;Instance-&gt;CR2; /* Get the TIMx SMCR register value */ tmpsmcr = htim-&gt;Instance-&gt;SMCR; /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */ if (IS_TIM_TRGO2_INSTANCE(htim-&gt;Instance)) &#123; /* Check the parameters */ assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig-&gt;MasterOutputTrigger2)); /* Clear the MMS2 bits */ tmpcr2 &amp;= ~TIM_CR2_MMS2; /* Select the TRGO2 source*/ tmpcr2 |= sMasterConfig-&gt;MasterOutputTrigger2; &#125; /* Reset the MMS Bits */ tmpcr2 &amp;= ~TIM_CR2_MMS; /* Select the TRGO source */ tmpcr2 |= sMasterConfig-&gt;MasterOutputTrigger; /* Reset the MSM Bit */ tmpsmcr &amp;= ~TIM_SMCR_MSM; /* Set master mode */ tmpsmcr |= sMasterConfig-&gt;MasterSlaveMode; /* Update TIMx CR2 */ htim-&gt;Instance-&gt;CR2 = tmpcr2; /* Update TIMx SMCR */ htim-&gt;Instance-&gt;SMCR = tmpsmcr; __HAL_UNLOCK(htim); return HAL_OK;&#125; &emsp;è¯¥å‡½æ•°çš„åŠŸèƒ½ç®€ä»‹å¦‚ä¸‹ï¼š tmpcr2é¦–å…ˆè¯»å–äº†TIMx_CR2å¯„å­˜å™¨å€¼ï¼Œæ¸…ç©ºMMSå€¼å¹¶å†™å…¥2ï¼Œå³ä»¥æ›´æ–°æ—¶é—´ä½œä¸ºè§¦å‘è¾“å‡º(TRGO)ï¼› tmpsmcré¦–å…ˆè¯»å–äº†TIMx_SMCRå¯„å­˜å™¨å€¼ï¼Œæ¸…ç©ºMSMå€¼å¹¶å†™å…¥0ï¼Œä»£è¡¨ä¸»ä»æ¨¡å¼ä¸æ‰§è¡Œä»»ä½•æ“ä½œã€‚ å°†tmpcr2ä¸tmpsmcråˆ†åˆ«å†™å…¥åˆ°TIMx_CR2ã€TIMx_SMCRå¯„å­˜å™¨ã€‚ Timerä¸­æ–­è®¾ç½®&emsp;åœ¨å®šæ—¶å™¨ä¸­æ–­ä¸­è®¾ç½®ç¿»è½¬GPIOB PIN1ã€‚ 1234567891011121314151617/** * @brief Period elapsed callback in non blocking mode * @param htim pointer to a TIM_HandleTypeDef structure that contains * the configuration information for TIM module. * @retval None */__weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)&#123; /* Prevent unused argument(s) compilation warning */ UNUSED(htim); HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1); /* NOTE : This function Should not be modified, when the callback is needed, the __HAL_TIM_PeriodElapsedCallback could be implemented in the user file */ &#125; å¯åŠ¨å®šæ—¶å™¨&emsp;å¯åŠ¨å®šæ—¶å™¨çš„ç¨‹åºå¦‚ä¸‹ã€‚ 1234567891011121314151617181920212223242526HAL_TIM_Base_Start_IT(&amp;htim2);/** * @brief Starts the TIM Base generation in interrupt mode. * @param htim pointer to a TIM_HandleTypeDef structure that contains * the configuration information for TIM module. * @retval HAL status */HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)&#123; /* Check the parameters */ assert_param(IS_TIM_INSTANCE(htim-&gt;Instance)); /* Enable the TIM Update interrupt */ __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE); /* Enable the Peripheral */ __HAL_TIM_ENABLE(htim); /* Return function status */ return HAL_OK;&#125;#define __HAL_TIM_ENABLE_IT(__HANDLE__, __INTERRUPT__) ((__HANDLE__)-&gt;Instance-&gt;DIER |= (__INTERRUPT__))#define __HAL_TIM_ENABLE(__HANDLE__) ((__HANDLE__)-&gt;Instance-&gt;CR1|=(TIM_CR1_CEN)) &emsp;è¯¥ç¨‹åºå‘TIMx_DIERå¯„å­˜å™¨UIEå†™å…¥1ï¼Œä½¿èƒ½æ›´æ–°ä¸­æ–­ï¼›å‘TIMx_CR1å¯„å­˜å™¨CENä½å†™å…¥1ï¼Œä½¿èƒ½è®¡æ•°å™¨ã€‚è‡³æ­¤ï¼Œåˆ™å®šæ—¶å™¨å¯åŠ¨ã€‚ è¿è¡Œç¨‹åº&emsp;è¿è¡Œç¨‹åºï¼Œå¯ä»¥çœ‹åˆ°GPIOB PIN1ç¿»è½¬ï¼Œé«˜ç”µå¹³ä¸ä½ç”µå¹³æŒç»­æ—¶é—´å‡ä¸º500msã€‚ æ—¶åŸºå•å…ƒçš„å‡†ç¡®æ€§ç¡®è®¤&emsp;ä¸ºäº†ç¡®è®¤æ—¶åŸºå•å…ƒå‡†ç¡®æ€§ï¼Œå¯¹å®šæ—¶å™¨åˆ†é¢‘å™¨ä¸å‘¨æœŸè¿›è¡Œä¸åŒè®¾ç½®å¹¶æµ‹é‡å‘¨æœŸæ—¶é•¿ã€‚ Prescaler TIMæ—¶é’Ÿé¢‘ç‡ TIMæ—¶é’Ÿå‘¨æœŸ Period TIMç†è®ºå‘¨æœŸ TIMå®æµ‹å‘¨æœŸ è¯´æ˜ 10800 - 1 10kHz 0.1ms 10 - 1 1ms 1.00025ms è¯¯å·®è¿œä½äºTIMæ—¶é’Ÿå‘¨æœŸï¼Œæ•…Periodè®¾ç½®æ–¹æ³•æ— è¯¯ã€‚ 10-1 10.8MHz 1/10.8us 10800-1 1ms 1.00024ms è¯¯å·®è¿œä½äºTIMç†è®ºå‘¨æœŸï¼Œæ•…Prescalerè®¾ç½®æ— è¯¯ã€‚ 108 - 1 1MHz 1us 2-1 2us 2.005us è¯¯å·®ä½äº1%ï¼Œç¡®è®¤æ— è¯¯ã€‚","categories":[{"name":"åµŒå…¥å¼","slug":"åµŒå…¥å¼","permalink":"http://jiaodi.tech/categories/åµŒå…¥å¼/"}],"tags":[{"name":"STM32F7","slug":"STM32F7","permalink":"http://jiaodi.tech/tags/STM32F7/"},{"name":"interrupt","slug":"interrupt","permalink":"http://jiaodi.tech/tags/interrupt/"},{"name":"Timer","slug":"Timer","permalink":"http://jiaodi.tech/tags/Timer/"}]},{"title":"STM32F767 GPIOä¸­æ–­çš„åŸºæœ¬ç”¨æ³•","slug":"stm32f767-gpio-it","date":"2018-04-08T15:28:48.000Z","updated":"2018-04-16T14:50:51.951Z","comments":true,"path":"2018/04/08/stm32f767-gpio-it/","link":"","permalink":"http://jiaodi.tech/2018/04/08/stm32f767-gpio-it/","excerpt":"&emsp;æœ¬æ–‡ä»‹ç»STM32F767 GPIOä¸­æ–­çš„åŸºæœ¬ç”¨æ³•ï¼ŒåŒæ—¶å€Ÿæ­¤å¯¹EXTI(Extended interrupts and events controller)è¿›è¡Œç®€è¦ä»‹ç»ã€‚","text":"&emsp;æœ¬æ–‡ä»‹ç»STM32F767 GPIOä¸­æ–­çš„åŸºæœ¬ç”¨æ³•ï¼ŒåŒæ—¶å€Ÿæ­¤å¯¹EXTI(Extended interrupts and events controller)è¿›è¡Œç®€è¦ä»‹ç»ã€‚ å¼€å‘ç¯å¢ƒç¡¬ä»¶ç¯å¢ƒ ç”µè„‘ï¼šWindows 10 Home x64 Apollo STM32F767å¼€å‘æ¿(ST-LINK V2ä»¿çœŸå™¨) è½¯ä»¶ç¯å¢ƒ Keil Version 5.24.1 (Pack Installerï¼šKeil.STM32F7xx_DFP.2.9.0.pack) STM32CubeMX Version 4.25.0(Packages Managerï¼šSTM32CubeF7) ä¸­æ–­ä¼˜å…ˆçº§è®¾ç½®Interrupt priority groupç®€ä»‹&emsp;STM32ä¸­ä¼˜å…ˆçº§åˆ†ä¸ºgroup priorityä»¥åŠsub priorityã€‚group priorityå³ä¸ºæŠ¢å ä¼˜å…ˆçº§(preempt priority)ï¼ŒæŠ¢å ä¼˜å…ˆçº§é«˜çš„ä¸­æ–­å¯ä»¥æ‰“æ–­æ­£åœ¨æ‰§è¡Œçš„ä¸­æ–­ï¼›sub priorityä¸ºæ¬¡è¦ä¼˜å…ˆçº§ï¼Œå½“ä¸¤ä¸ªæŠ¢å ä¼˜å…ˆçº§ç›¸åŒçš„ä¸­æ–­åŒæ—¶pendingæ—¶ï¼Œé¦–å…ˆæ‰§è¡Œsub priorityä¼˜å…ˆçº§é«˜çš„ä¸­æ–­ã€‚ æ³¨æ„ä¸­æ–­çš„ä¼˜å…ˆçº§æ•°å€¼è®¾ç½®è¶Šå°ä»£è¡¨ä¼˜å…ˆçº§è¶Šé«˜ã€‚ &emsp;ARM Cortex-M7å†…æ ¸æ ‡å‡†ä¸­ï¼Œé€šè¿‡AIRCR(Application Interrupt and Reset Control Register)å¯„å­˜å™¨ä¸­PRIGROUPä½æ§åˆ¶Interrupt priority groupè®¾ç½®ï¼Œå…·ä½“å¦‚ä¸‹ã€‚ &emsp;å¯çŸ¥PRIGROUPå…±æœ‰3ä¸ªbitï¼Œå…±8ä¸­ç»„åˆæ–¹æ³•ï¼Œå°†group priorityä»¥åŠsub priorityçš„æ§åˆ¶ä½ä¾æ¬¡åˆ’åˆ†ã€‚ä¾‹å¦‚PRIGROUPè®¾ç½®ä¸º0b100æ—¶ï¼ŒPRI_N[7:1]ä¸­[7:5]ä½ä¸ºgroup priorityæ§åˆ¶ä½ï¼Œ[4:0]ä¸ºsub priorityæ§åˆ¶ä½ï¼Œåˆ†åˆ«å¯¹åº”8ä¸32ä¸ªä¼˜å…ˆçº§è®¾ç½®åœ¨ã€‚ &emsp;ç³»ç»Ÿä¸­é€šå¸¸æŠ¢å ä¼˜å…ˆçº§æ›´ä¸ºå¸¸ç”¨ï¼Œå› æ­¤group priorityä»¥åŠsub priorityè®¾ç½®ä¸­é€šå¸¸æ›´å€¾å‘äºç»™äºˆgroup priorityæ›´å¤šæ§åˆ¶ä½ã€‚ &emsp;éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒARM Cortex-M7å†…æ ¸æ ‡å‡†ä¸­PRIGROUPçš„éƒ¨åˆ†è®¾ç½®æ˜¯opticalï¼Œä¹Ÿå°±æ˜¯å¯ä»¥ç”±å‚å•†è‡ªè¡Œé€‰ç”¨çš„ã€‚äº‹å®ä¸ŠSMT32F767å†…æ ¸å³å¯¹æ­¤è¿›è¡Œäº†ç²¾ç®€ã€‚å…·ä½“å‚ç…§HAL_NVIC_SetPriorityGrouping()å‡½æ•°ï¼Œå¦‚ä¸‹ã€‚å…¶NVIC_PRIORITYGROUPå…±åˆ†ä¸º5ç»„ï¼ŒNVIC-&gt;IPä¸ºgroup priorityä»¥åŠsub priorityå¯„å­˜å™¨ï¼Œä»…é«˜4ä½ç”¨äºè®¾ç½®ä¼˜å…ˆçº§ã€‚ 123456789101112131415161718192021222324252627/** * @brief Sets the priority grouping field (preemption priority and subpriority) * using the required unlock sequence. * @param PriorityGroup The priority grouping bits length. * This parameter can be one of the following values: * @arg NVIC_PRIORITYGROUP_0: 0 bits for preemption priority * 4 bits for subpriority * @arg NVIC_PRIORITYGROUP_1: 1 bits for preemption priority * 3 bits for subpriority * @arg NVIC_PRIORITYGROUP_2: 2 bits for preemption priority * 2 bits for subpriority * @arg NVIC_PRIORITYGROUP_3: 3 bits for preemption priority * 1 bits for subpriority * @arg NVIC_PRIORITYGROUP_4: 4 bits for preemption priority * 0 bits for subpriority * @note When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. * The pending IRQ priority will be managed only by the subpriority. * @retval None */void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)&#123; /* Check the parameters */ assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup)); /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */ NVIC_SetPriorityGrouping(PriorityGroup);&#125; &emsp;NVIC_SetPriorityGrouping()çš„å…·ä½“å®ç°å¦‚ä¸‹ã€‚æ³¨æ„å†™å…¥åˆ°SCB AIRCRå¯„å­˜å™¨æ—¶å¿…é¡»ä¿è¯VECTKEYä½å†™å…¥0x5FAï¼Œå¦åˆ™å†™å…¥ä¸ç”Ÿæ•ˆã€‚ 123456789101112131415161718192021/** \\brief Set Priority Grouping \\details Sets the priority grouping field using the required unlock sequence. The parameter PriorityGroup is assigned to the field SCB-&gt;AIRCR [10:8] PRIGROUP field. Only values from 0..7 are used. In case of a conflict between priority grouping and available priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set. \\param [in] PriorityGroup Priority grouping field. */__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)&#123; uint32_t reg_value; uint32_t PriorityGroupTmp = (PriorityGroup &amp; (uint32_t)0x07UL); /* only values 0..7 are used */ reg_value = SCB-&gt;AIRCR; /* read old register configuration */ reg_value &amp;= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change */ reg_value = (reg_value | ((uint32_t)0x5FAUL &lt;&lt; SCB_AIRCR_VECTKEY_Pos) | (PriorityGroupTmp &lt;&lt; 8U) ); /* Insert write key and priorty group */ SCB-&gt;AIRCR = reg_value;&#125; Interrupt priority groupè®¾ç½®&emsp;åœ¨æœ¬ä¾‹ä¸­ï¼ŒInterrupt priority groupè®¾ç½®å¦‚ä¸‹ï¼ŒåŒæ—¶è®¾ç½®äº†ç³»ç»Ÿé‡è¦ä¸­æ–­çš„ä¼˜å…ˆçº§ã€‚HAL_MspInit()å‡½æ•°åœ¨HAL_Init()ä¸­è°ƒç”¨ã€‚è®¾ç½®NVIC_PRIORITYGROUP_2ä¸º2ï¼Œåˆ™group priorityä»¥åŠsub priorityå„æœ‰2bitæ§åˆ¶ä½ï¼Œå„è‡ªæœ‰4ä¸ªä¼˜å…ˆçº§ã€‚ 12345678910111213141516171819202122232425/** * @brief Initializes the Global MSP. * @param None * @retval None */void HAL_MspInit(void)&#123; HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_2); /* System interrupt init*/ /* MemoryManagement_IRQn interrupt configuration */ HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0); /* BusFault_IRQn interrupt configuration */ HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0); /* UsageFault_IRQn interrupt configuration */ HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0); /* SVCall_IRQn interrupt configuration */ HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0); /* DebugMonitor_IRQn interrupt configuration */ HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0); /* PendSV_IRQn interrupt configuration */ HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0); /* SysTick_IRQn interrupt configuration */ HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);&#125; IOä¸­æ–­è®¾ç½®EXTIæ¡†å›¾&emsp;EXTI(Extended interrupts and events controller)çš„æ§åˆ¶æ¡†å›¾å¦‚ä¸‹æ‰€ç¤ºã€‚ &emsp;æ ¹æ®æ¡†å›¾å¯çŸ¥ï¼Œä¸­æ–­ä¿¡å·å¦‚æœè¦è¿›å…¥NVIC(Nested vectored interrupt controller)ä¸­ï¼Œéœ€è¦å¦‚ä¸‹æ¡ä»¶ï¼š è¾¹æ²¿é€‰æ‹©å¯„å­˜å™¨ç›¸åº”ä½ä½¿èƒ½ï¼› ä¸­æ–­maskå¯„å­˜å™¨ç›¸åº”ä½ä½¿èƒ½ã€‚ External interrupt/event line mapping&emsp;STM32F767çš„ä¸­æ–­çº¿æ˜ å°„æ–¹æ³•å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚ &emsp;ä¾‹å¦‚å¯¹äºEXTI0ï¼Œå¯ä»¥é€‰æ‹©PA0~PK0ç­‰IOä½œä¸ºä¸­æ–­ä¿¡å·æºï¼Œå¯ä»¥é€šè¿‡SYSCFG_EXTICRxå¯„å­˜å™¨é€‰æ‹©ä¸­æ–­çº¿å¯¹åº”åœ°IOç«¯å£ã€‚ GPIOåˆå§‹åŒ–&emsp;åŸºäºHALåº“å¯¹GPIOä¸­æ–­çš„åˆå§‹åŒ–éå¸¸ç®€æ˜ï¼Œä»£ç å¦‚ä¸‹ã€‚é…ç½®Port C PIN13ä¸ºä¸­æ–­æºï¼Œä¸Šæ‹‰å¤„ç†ï¼Œä¸‹é™æ²¿è§¦å‘ä¸­æ–­ã€‚ 1234GPIO_InitStruct.Pin = GPIO_PIN_13;GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;GPIO_InitStruct.Pull = GPIO_PULLUP;HAL_GPIO_Init(GPIOC, &amp;GPIO_InitStruct); &emsp;é‡ç‚¹è¯´æ˜ä¸€ä¸‹HAL_GPIO_Init()å‡½æ•°ä¸­å…³äºIOä¸­æ–­çš„é…ç½®éƒ¨åˆ†ï¼Œä»£ç å¦‚ä¸‹ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*--------------------- EXTI Mode Configuration ------------------------*//* Configure the External Interrupt or event for the current IO */if((GPIO_Init-&gt;Mode &amp; EXTI_MODE) == EXTI_MODE)&#123; /* Enable SYSCFG Clock */ __HAL_RCC_SYSCFG_CLK_ENABLE(); temp = SYSCFG-&gt;EXTICR[position &gt;&gt; 2]; temp &amp;= ~(((uint32_t)0x0F) &lt;&lt; (4 * (position &amp; 0x03))); temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) &lt;&lt; (4 * (position &amp; 0x03))); SYSCFG-&gt;EXTICR[position &gt;&gt; 2] = temp; /* Clear EXTI line configuration */ temp = EXTI-&gt;IMR; temp &amp;= ~((uint32_t)iocurrent); if((GPIO_Init-&gt;Mode &amp; GPIO_MODE_IT) == GPIO_MODE_IT) &#123; temp |= iocurrent; &#125; EXTI-&gt;IMR = temp; temp = EXTI-&gt;EMR; temp &amp;= ~((uint32_t)iocurrent); if((GPIO_Init-&gt;Mode &amp; GPIO_MODE_EVT) == GPIO_MODE_EVT) &#123; temp |= iocurrent; &#125; EXTI-&gt;EMR = temp; /* Clear Rising Falling edge configuration */ temp = EXTI-&gt;RTSR; temp &amp;= ~((uint32_t)iocurrent); if((GPIO_Init-&gt;Mode &amp; RISING_EDGE) == RISING_EDGE) &#123; temp |= iocurrent; &#125; EXTI-&gt;RTSR = temp; temp = EXTI-&gt;FTSR; temp &amp;= ~((uint32_t)iocurrent); if((GPIO_Init-&gt;Mode &amp; FALLING_EDGE) == FALLING_EDGE) &#123; temp |= iocurrent; &#125; EXTI-&gt;FTSR = temp; &#125; &emsp;GPIO_MODE_IT_FALLINGçš„å€¼ä¸º0x10210 000Uï¼ŒEXTI_MODEçš„å€¼ä¸º0x1000 0000Uï¼Œæ‰€ä»¥å°†è¿›å…¥ä¸­æ–­/äº‹ä»¶é…ç½®å‡½æ•°ã€‚ ä½¿èƒ½SYSCFGæ—¶é’Ÿï¼› positionä»£è¡¨IOçš„PINè„šå€¼ï¼Œä¸º0~15ï¼Œå¯¹åº”SYSCFG_EXTICR0~SYSCFG_EXTICR3ï¼Œå³ç§»2ä½åˆ™å¯ä»¥å¯¹åº”åˆ°SYSCFG_EXTICRxå¯„å­˜å™¨å·ï¼› tempé¦–å…ˆè¯»å–SYSCFG_EXTICRxå¯„å­˜å™¨çš„å€¼ï¼› å°†tempä¸­å¯¹åº”çš„EXTI xé…ç½®å€¼æ¸…ç©ºå¹¶å†™å…¥æ–°çš„å€¼ï¼› å°†tempå€¼å†™å…¥åˆ°SYSCFG_EXTICRxå¯„å­˜å™¨ï¼› ä½¿èƒ½EXTI-&gt;IMRæˆ–è€…EXTI-&gt;EMRå¯„å­˜å™¨å¯¹åº”ä½ï¼› ä½¿èƒ½EXTI-&gt;RTSRæˆ–è€…EXTI-&gt;FTSRå¯„å­˜å™¨å¯¹åº”ä½ã€‚ è®¾ç½®ä¸­æ–­ä¼˜å…ˆçº§&emsp;è®¾ç½®GPIOä¸­æ–­çš„group priorityä»¥åŠsub priorityå‡ä¸º2ã€‚ 123/* EXTI interrupt init*/HAL_NVIC_SetPriority(EXTI15_10_IRQn, 2, 2);HAL_NVIC_EnableIRQ(EXTI15_10_IRQn); &emsp;è®¾ç½®ä¼˜å…ˆçº§é€šè¿‡å‘NVIC-&gt;IPå†™å…¥ç”Ÿæ•ˆã€‚åœ¨STM32F767ä¸­ï¼ŒNVIC-&gt;IPçš„é«˜4ä½ç”¨äºè®¾ç½®group priorityä»¥åŠsub priorityã€‚ä»¥ä¸‹å‡½æ•°çš„åŠŸèƒ½ä¸ºé¦–å…ˆç¡®å®šç³»ç»Ÿä¸­æ–­è®¾ç½®æœ‰æ•ˆä½ï¼Œè®¡ç®—å¾—åˆ°ä¼˜å…ˆçº§å†™å…¥å€¼ï¼Œå†å°†å…¶å†™å…¥åˆ°NVIC-&gt;IPå¯„å­˜å™¨ä¸­ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * @brief Sets the priority of an interrupt. * @param IRQn External interrupt number. * This parameter can be an enumerator of IRQn_Type enumeration * (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h)) * @param PreemptPriority The preemption priority for the IRQn channel. * This parameter can be a value between 0 and 15 * A lower priority value indicates a higher priority * @param SubPriority the subpriority level for the IRQ channel. * This parameter can be a value between 0 and 15 * A lower priority value indicates a higher priority. * @retval None */void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)&#123; uint32_t prioritygroup = 0x00; /* Check the parameters */ assert_param(IS_NVIC_SUB_PRIORITY(SubPriority)); assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority)); prioritygroup = NVIC_GetPriorityGrouping(); NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));&#125;/** \\brief Encode Priority \\details Encodes the priority for an interrupt with the given priority group, preemptive priority value, and subpriority value. In case of a conflict between priority grouping and available priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set. \\param [in] PriorityGroup Used priority group. \\param [in] PreemptPriority Preemptive priority value (starting from 0). \\param [in] SubPriority Subpriority value (starting from 0). \\return Encoded priority. Value can be used in the function \\ref NVIC_SetPriority(). */__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)&#123; uint32_t PriorityGroupTmp = (PriorityGroup &amp; (uint32_t)0x07UL); /* only values 0..7 are used */ uint32_t PreemptPriorityBits; uint32_t SubPriorityBits; PreemptPriorityBits = ((7UL - PriorityGroupTmp) &gt; (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp); SubPriorityBits = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) &lt; (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS)); return ( ((PreemptPriority &amp; (uint32_t)((1UL &lt;&lt; (PreemptPriorityBits)) - 1UL)) &lt;&lt; SubPriorityBits) | ((SubPriority &amp; (uint32_t)((1UL &lt;&lt; (SubPriorityBits )) - 1UL))) );&#125;/** \\brief Set Interrupt Priority \\details Sets the priority of an interrupt. \\note The priority cannot be set for every core interrupt. \\param [in] IRQn Interrupt number. \\param [in] priority Priority to set. */__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)&#123; if ((int32_t)(IRQn) &lt; 0) &#123; SCB-&gt;SHPR[(((uint32_t)(int32_t)IRQn) &amp; 0xFUL)-4UL] = (uint8_t)((priority &lt;&lt; (8U - __NVIC_PRIO_BITS)) &amp; (uint32_t)0xFFUL); &#125; else &#123; NVIC-&gt;IP[((uint32_t)(int32_t)IRQn)] = (uint8_t)((priority &lt;&lt; (8U - __NVIC_PRIO_BITS)) &amp; (uint32_t)0xFFUL); &#125;&#125; &emsp;ä½¿èƒ½ä¸­æ–­é€šè¿‡å‘NVIC-&gt;ISERxå¯„å­˜å™¨å†™å…¥ç”Ÿæ•ˆã€‚ 123456789101112131415161718192021222324252627/** * @brief Enables a device specific interrupt in the NVIC interrupt controller. * @note To configure interrupts priority correctly, the NVIC_PriorityGroupConfig() * function should be called before. * @param IRQn External interrupt number. * This parameter can be an enumerator of IRQn_Type enumeration * (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h)) * @retval None */void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)&#123; /* Check the parameters */ assert_param(IS_NVIC_DEVICE_IRQ(IRQn)); /* Enable interrupt */ NVIC_EnableIRQ(IRQn);&#125;/** \\brief Enable External Interrupt \\details Enables a device-specific interrupt in the NVIC interrupt controller. \\param [in] IRQn External interrupt number. Value cannot be negative. */__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)&#123; NVIC-&gt;ISER[(((uint32_t)(int32_t)IRQn) &gt;&gt; 5UL)] = (uint32_t)(1UL &lt;&lt; (((uint32_t)(int32_t)IRQn) &amp; 0x1FUL));&#125; è®¾ç½®ä¸­æ–­æœåŠ¡å‡½æ•°&emsp;GPIOçš„ä¸­æ–­æœåŠ¡å‡½æ•°å¦‚ä¸‹ï¼Œå…¶ä¸­EXTI15~EXIT10å…±ç”¨åŒä¸€å…¥å£ã€‚å½“è¿›å…¥ä¸­æ–­æœåŠ¡å‡½æ•°åï¼Œè¯»å–EXTI-&gt;PRå¯„å­˜å™¨ç¡®è®¤ä¸­æ–­çŠ¶æ€ï¼Œå¹¶æ¸…é™¤ä¸­æ–­æ ‡å¿—ä½ã€‚æœ€åï¼Œç¨‹åºè°ƒç”¨å›è°ƒå‡½æ•°HAL_GPIO_EXTI_Callback()ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*** @brief This function handles EXTI line[15:10] interrupts.*/void EXTI15_10_IRQHandler(void)&#123; /* USER CODE BEGIN EXTI15_10_IRQn 0 */ /* USER CODE END EXTI15_10_IRQn 0 */ HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_13); /* USER CODE BEGIN EXTI15_10_IRQn 1 */ /* USER CODE END EXTI15_10_IRQn 1 */&#125;/** * @brief This function handles EXTI interrupt request. * @param GPIO_Pin Specifies the pins connected EXTI line * @retval None */void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)&#123; /* EXTI line interrupt detected */ if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET) &#123; __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin); HAL_GPIO_EXTI_Callback(GPIO_Pin); &#125;&#125;/** * @brief Checks whether the specified EXTI line is asserted or not. * @param __EXTI_LINE__ specifies the EXTI line to check. * This parameter can be GPIO_PIN_x where x can be(0..15) * @retval The new state of __EXTI_LINE__ (SET or RESET). */#define __HAL_GPIO_EXTI_GET_IT(__EXTI_LINE__) (EXTI-&gt;PR &amp; (__EXTI_LINE__))/** * @brief Clears the EXTI's line pending bits. * @param __EXTI_LINE__ specifies the EXTI lines to clear. * This parameter can be any combination of GPIO_PIN_x where x can be (0..15) * @retval None */#define __HAL_GPIO_EXTI_CLEAR_IT(__EXTI_LINE__) (EXTI-&gt;PR = (__EXTI_LINE__)) &emsp;ä¸­æ–­å›è°ƒå‡½æ•°è®¾ç½®å¦‚ä¸‹ã€‚ 12345678910111213141516/** * @brief EXTI line detection callbacks. * @param GPIO_Pin Specifies the pins connected EXTI line * @retval None */uint16_t keyPressCounter =0;__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)&#123; /* Prevent unused argument(s) compilation warning */ UNUSED(GPIO_Pin); keyPressCounter++; /* NOTE: This function Should not be modified, when the callback is needed, the HAL_GPIO_EXTI_Callback could be implemented in the user file */&#125; &emsp;æ‰§è¡Œç¨‹åºï¼Œå½“Port C PIN13è¢«æŒ‰ä¸‹(å‡ºç°ä¸‹é™æ²¿)åï¼Œåˆ™keyPressCounterå¢åŠ ã€‚æ³¨æ„IOéœ€è¦è¿›è¡Œå»æŠ–å¤„ç†ï¼Œé€šå¸¸ä½¿ç”¨ä¸€ä¸ª10~100nFç”µå®¹å®Œæˆç¡¬ä»¶å»æŠ–ã€‚","categories":[{"name":"åµŒå…¥å¼","slug":"åµŒå…¥å¼","permalink":"http://jiaodi.tech/categories/åµŒå…¥å¼/"}],"tags":[{"name":"GPIO","slug":"GPIO","permalink":"http://jiaodi.tech/tags/GPIO/"},{"name":"STM32F7","slug":"STM32F7","permalink":"http://jiaodi.tech/tags/STM32F7/"},{"name":"interrupt","slug":"interrupt","permalink":"http://jiaodi.tech/tags/interrupt/"}]},{"title":"STM32F767 GPIOä¸UARTçš„åŸºæœ¬ç”¨æ³•","slug":"stm32f767-GPIO-UART","date":"2018-04-05T10:05:01.000Z","updated":"2018-04-15T15:12:33.666Z","comments":true,"path":"2018/04/05/stm32f767-GPIO-UART/","link":"","permalink":"http://jiaodi.tech/2018/04/05/stm32f767-GPIO-UART/","excerpt":"&emsp;æœ¬æ–‡ä»‹ç»STM32F767 GPIOä¸UARTçš„åŸºæœ¬ç”¨æ³•ã€‚","text":"&emsp;æœ¬æ–‡ä»‹ç»STM32F767 GPIOä¸UARTçš„åŸºæœ¬ç”¨æ³•ã€‚ å¼€å‘ç¯å¢ƒç¡¬ä»¶ç¯å¢ƒ ç”µè„‘ï¼šWindows 10 Home x64 Apollo STM32F767å¼€å‘æ¿(ST-LINK V2ä»¿çœŸå™¨) è½¯ä»¶ç¯å¢ƒ Keil Version 5.24.1 (Pack Installerï¼šKeil.STM32F7xx_DFP.2.9.0.pack) STM32CubeMX Version 4.25.0(Packages Managerï¼šSTM32CubeF7) GPIOåŸºæœ¬ç”¨æ³•&emsp;ä½¿ç”¨GPIOçš„åŸºæœ¬æµç¨‹ä¸ºï¼šä½¿èƒ½GPIOå¯¹åº”ç«¯å£æ—¶é’Ÿã€é…ç½®IOå‚æ•°ã€æ§åˆ¶IOè¾“å‡ºæˆ–è€…è¯»å–IOçŠ¶æ€ã€‚ ä½¿èƒ½GPIOç«¯å£æ—¶é’Ÿ&emsp;ä»»ä½•éœ€è¦ä½¿ç”¨IOç«¯å£çš„å¤–è®¾ä½¿ç”¨å‰éƒ½å¿…é¡»ä½¿èƒ½å¯¹åº”åœ°IOç«¯å£æ—¶é’Ÿã€‚å¯¹äºä¸è€ƒè™‘åŠŸè€—çš„ç³»ç»Ÿï¼Œå¯ä»¥ç›´æ¥å°†æ‰€æœ‰çš„IOç«¯å£æ—¶é’Ÿå…¨éƒ¨æ‰“å¼€ã€‚ 1234567891011121314void RCC_CLK_Enable(void)&#123; /* GPIO Ports Clock Enable */ __HAL_RCC_GPIOA_CLK_ENABLE(); __HAL_RCC_GPIOB_CLK_ENABLE(); __HAL_RCC_GPIOC_CLK_ENABLE(); __HAL_RCC_GPIOD_CLK_ENABLE(); __HAL_RCC_GPIOE_CLK_ENABLE(); __HAL_RCC_GPIOF_CLK_ENABLE(); __HAL_RCC_GPIOG_CLK_ENABLE(); __HAL_RCC_GPIOH_CLK_ENABLE(); __HAL_RCC_GPIOI_CLK_ENABLE(); &#125; è®¾ç½®IOå‚æ•°12345678910111213141516171819202122void MX_GPIO_Init(void)&#123; GPIO_InitTypeDef GPIO_InitStruct; /*Configure GPIO pin Output Level */ HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0|GPIO_PIN_1, GPIO_PIN_RESET); /*Configure GPIO pins : PB0 PB1 */ GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct); /*Configure GPIO pin : PH3 */ GPIO_InitStruct.Pin = GPIO_PIN_3; GPIO_InitStruct.Mode = GPIO_MODE_INPUT; GPIO_InitStruct.Pull = GPIO_PULLUP; HAL_GPIO_Init(GPIOH, &amp;GPIO_InitStruct);&#125; &emsp;IOçš„åˆå§‹åŒ–å‚æ•°é€šè¿‡GPIO_InitStructç»“æ„ä½“è®¾ç½®ï¼Œå¯¹äºè¾“å…¥IOï¼Œéœ€è¦çš„è®¾ç½®å¦‚ä¸‹ï¼š PINè„šå·ï¼› IOæ¨¡å¼ï¼šå¯ä»¥é€‰æ‹©push pullæˆ–è€…open drainï¼› IOä¸Šä¸‹æ‹‰è®¾ç½®ï¼šå¯ä»¥é€‰æ‹©ä¸Šæ‹‰ã€ä¸‹æ‹‰æˆ–è€…ä¸è¿›è¡Œä¸Šæ‹‰ä¸‹æ‹‰ï¼› IOé€Ÿåº¦ï¼šå¯ä»¥è®¾ç½®IOçš„ç¿»è½¬é€Ÿåº¦ï¼Œå…·ä½“å¯ä»¥å‚è€ƒå™¨ä»¶çš„æ‰‹å†Œï¼› è°ƒç”¨HAL_GPIO_Init()å‡½æ•°å®ŒæˆIOåˆå§‹åŒ–ã€‚ &emsp;å¯¹äºè¾“å…¥IOï¼Œä¸è¾“å‡ºIOä¸åŒçš„è®¾ç½®å¦‚ä¸‹ï¼š IOæ¨¡å¼ï¼šé€‰æ‹©inputæ¨¡å¼ï¼› IOé€Ÿåº¦ï¼šæ— éœ€è®¾ç½®ã€‚ è¾“å‡ºIOçš„æ§åˆ¶&emsp;IOçš„è¾“å‡ºé€šè¿‡HAL_GPIO_WritePin()/HAL_GPIO_TogglePin()å®ç°ï¼Œåæ–‡ä¸¾ä¾‹è¯´æ˜ã€‚ è¾“å…¥IOçš„è¯»å–&emsp;IOçš„è¾“å…¥æ•°æ®é€šè¿‡HAL_GPIO_ReadPin()å®ç°ï¼Œåæ–‡ä¸¾ä¾‹è¯´æ˜ã€‚ GPIOä½¿ç”¨ç¤ºä¾‹&emsp;ç¤ºä¾‹ä»£ç å¦‚ä¸‹æ‰€ç¤ºã€‚ 12345678910if (HAL_GPIO_ReadPin(GPIOH, GPIO_PIN_3) == GPIO_PIN_RESET)&#123; HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_SET); HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_0); while (HAL_GPIO_ReadPin(GPIOH, GPIO_PIN_3) == GPIO_PIN_RESET);&#125;else&#123; HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_RESET);&#125; &emsp;è¯¥ä»£ç çš„åŠŸèƒ½æ˜¯æ£€æµ‹åˆ°port H PIN3ä¸ºä½ç”µå¹³åï¼Œç¿»è½¬port B PIN1ï¼ŒåŒæ—¶ç‚¹äº®port B PIN1ã€‚ OLEDçš„ä½¿ç”¨&emsp;æœ¬æ–‡ä½¿ç”¨çš„OLEDæ˜¾ç¤ºå±ä½¿ç”¨4ä¸ªGPIOå³å¯å®Œæˆé©±åŠ¨ã€‚åªéœ€è¦ç§»æ¤åº•å±‚IOä»£ç ï¼Œä¸Šå±‚åº”ç”¨å¯ä»¥ç›´æ¥ä½¿ç”¨ï¼Œåº•å±‚ä»£ç å®ç°å¦‚ä¸‹ã€‚ 12345678910111213141516171819void LCD_Hardware_Init()&#123; /*Configure GPIO pins : PC6 PC7 PC8 PC9 */ __HAL_RCC_GPIOE_CLK_ENABLE(); GPIO_InitTypeDef GPIO_InitStruct; GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_LOW; HAL_GPIO_Init(GPIOE, &amp;GPIO_InitStruct);&#125;#define oledSCL_1 HAL_GPIO_WritePin(GPIOE, GPIO_PIN_2, GPIO_PIN_SET)#define oledSCL_0 HAL_GPIO_WritePin(GPIOE, GPIO_PIN_2, GPIO_PIN_RESET)#define oledSDA_1 HAL_GPIO_WritePin(GPIOE, GPIO_PIN_3, GPIO_PIN_SET)#define oledSDA_0 HAL_GPIO_WritePin(GPIOE, GPIO_PIN_3, GPIO_PIN_RESET)#define oledRST_1 HAL_GPIO_WritePin(GPIOE, GPIO_PIN_4, GPIO_PIN_SET)#define oledRST_0 HAL_GPIO_WritePin(GPIOE, GPIO_PIN_4, GPIO_PIN_RESET)#define oledDC_1 HAL_GPIO_WritePin(GPIOE, GPIO_PIN_5, GPIO_PIN_SET)#define oledDC_0 HAL_GPIO_WritePin(GPIOE, GPIO_PIN_5, GPIO_PIN_RESET) &emsp;OLEDæ˜¾ç¤ºå±å¯ä»¥è¿›è¡Œå­—ç¬¦ä¸²ã€æ•°å­—ä»¥åŠç®€å•å›¾æ ‡çš„å±•ç¤ºï¼Œä¾¿äºç³»ç»Ÿè°ƒè¯•ã€‚ UARTåŸºæœ¬ç”¨æ³•&emsp;ä½¿ç”¨UARTçš„åŸºæœ¬æµç¨‹ä¸ºï¼šåˆå§‹åŒ–huart1ç»“æ„ä½“ã€è°ƒç”¨HAL_UART_Init()å‡½æ•°å®Œæˆåˆå§‹åŒ–ã€‚ huart1ç»“æ„ä½“å‚æ•°åˆå§‹åŒ–&emsp;huart1ç»“æ„ä½“ä¸»è¦åŒ…å«äº†ä¸²å£å‚æ•°ï¼Œä¾‹å¦‚æ³¢ç‰¹ç‡ã€æ•°æ®é•¿åº¦ã€åœæ­¢ä½ã€å¥‡å¶æ ¡éªŒä½ç­‰ã€‚ä¹‹åè°ƒç”¨HAL_UART_Init()å‡½æ•°å®Œæˆåˆå§‹åŒ–ã€‚ 12345678910111213141516171819202122UART_HandleTypeDef huart1;/* USART1 init function */void MX_USART1_UART_Init(void)&#123; huart1.Instance = USART1; huart1.Init.BaudRate = 115200; huart1.Init.WordLength = UART_WORDLENGTH_8B; huart1.Init.StopBits = UART_STOPBITS_1; huart1.Init.Parity = UART_PARITY_NONE; huart1.Init.Mode = UART_MODE_TX_RX; huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart1.Init.OverSampling = UART_OVERSAMPLING_16; huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE; huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT; if (HAL_UART_Init(&amp;huart1) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125;&#125; HAL_UART_Init()çš„åŠŸèƒ½&emsp;HAL_UART_Init()å‡½æ•°çš„å†…å®¹å¦‚ä¸‹æ‰€ç¤ºã€‚é™¤å‚æ•°åˆç†æ€§æ£€æµ‹ä¹‹å¤–ï¼Œå°†è°ƒç”¨HAL_UART_MspInit()å®Œæˆç¡¬ä»¶IOçš„åˆå§‹åŒ–ã€è°ƒç”¨UART_SetConfig()å®ŒæˆUARTå‚æ•°çš„åˆå§‹åŒ–ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/** * @brief Initializes the UART mode according to the specified * parameters in the UART_InitTypeDef and creates the associated handle . * @param huart uart handle * @retval HAL status */HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)&#123; /* Check the UART handle allocation */ if(huart == NULL) &#123; return HAL_ERROR; &#125; if(huart-&gt;Init.HwFlowCtl != UART_HWCONTROL_NONE) &#123; /* Check the parameters */ assert_param(IS_UART_HWFLOW_INSTANCE(huart-&gt;Instance)); &#125; else &#123; /* Check the parameters */ assert_param(IS_UART_INSTANCE(huart-&gt;Instance)); &#125; if(huart-&gt;gState == HAL_UART_STATE_RESET) &#123; /* Allocate lock resource and initialize it */ huart-&gt;Lock = HAL_UNLOCKED; /* Init the low level hardware : GPIO, CLOCK */ HAL_UART_MspInit(huart); &#125; huart-&gt;gState = HAL_UART_STATE_BUSY; /* Disable the Peripheral */ __HAL_UART_DISABLE(huart); /* Set the UART Communication parameters */ if (UART_SetConfig(huart) == HAL_ERROR) &#123; return HAL_ERROR; &#125; if (huart-&gt;AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT) &#123; UART_AdvFeatureConfig(huart); &#125; /* In asynchronous mode, the following bits must be kept cleared: - LINEN and CLKEN bits in the USART_CR2 register, - SCEN, HDSEL and IREN bits in the USART_CR3 register.*/ CLEAR_BIT(huart-&gt;Instance-&gt;CR2, (USART_CR2_LINEN | USART_CR2_CLKEN)); CLEAR_BIT(huart-&gt;Instance-&gt;CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN)); /* Enable the Peripheral */ __HAL_UART_ENABLE(huart); /* TEACK and/or REACK to check before moving huart-&gt;gState and huart-&gt;RxState to Ready */ return (UART_CheckIdleState(huart));&#125;void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)&#123; GPIO_InitTypeDef GPIO_InitStruct; if(uartHandle-&gt;Instance==USART1) &#123; /* USER CODE BEGIN USART1_MspInit 0 */ /* USER CODE END USART1_MspInit 0 */ /* USART1 clock enable */ __HAL_RCC_USART1_CLK_ENABLE(); /**USART1 GPIO Configuration PA9 ------&gt; USART1_TX PA10 ------&gt; USART1_RX */ GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH; GPIO_InitStruct.Alternate = GPIO_AF7_USART1; HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct); /* USER CODE BEGIN USART1_MspInit 1 */ /* USER CODE END USART1_MspInit 1 */ &#125;&#125; UARTçš„å‘é€ä¸æ¥æ”¶&emsp;UARTçš„å‘é€ä¸æ¥æ”¶é€šè¿‡HAL_UART_Transmit()/HAL_UART_Receive()å®ç°ï¼Œç¤ºä¾‹å¦‚ä¸‹ã€‚ 123456if (__HAL_UART_GET_FLAG(&amp;huart1,UART_FLAG_RXNE)==SET)&#123; HAL_UART_Receive(&amp;huart1, usart1_rx, 1, 1000); HAL_UART_Transmit(&amp;huart1,(uint8 *)\"\\nYou send: \",11,1000); HAL_UART_Transmit(&amp;huart1,usart1_rx, 1,1000);&#125; &emsp;å½“æ£€æµ‹åˆ°ä¸²å£RXNEæ ‡å¿—ä½ä¸º1æ—¶ï¼Œè¡¨ç¤ºæ­¤æ—¶ä¸²å£æ¥æ”¶åˆ°ä¿¡æ¯ï¼Œå³è°ƒç”¨HAL_UART_Receive()å‡½æ•°è¿›è¡Œè¯»å–ã€‚è¯»å–åé€šè¿‡HAL_UART_Transmit()å‘é€æç¤ºä¿¡æ¯ä¸æ¥æ”¶åˆ°çš„ä¿¡æ¯ã€‚äº‹å®ä¸Šå¯ä»¥ç›´æ¥è°ƒç”¨HAL_UART_Receive()å‡½æ•°è½®è¯¢ä¸²å£ï¼Œå½“è¿”å›å€¼ä¸ºHAL_TIMEOUTæ—¶å³è¡¨ç¤ºæ²¡æœ‰æ¥æ”¶åˆ°ä¿¡æ¯ã€‚ UARTå‘é€å‡½æ•°çš„ç®€åŒ–&emsp;è¯»å–HAL_UART_Transmit()çš„å®ç°æµç¨‹ï¼Œå…¶ç›¸å¯¹å¤æ‚ã€‚å¯¹äºé€šå¸¸ç”¨åˆ°çš„åœºæ™¯æ¥è¯´ï¼Œå¯ä»¥è¿›è¡Œç®€åŒ–ï¼Œå³é‡‡ç”¨å¯„å­˜å™¨æ–¹å¼æ“ä½œã€‚å…·ä½“å®ç°å¦‚ä¸‹ã€‚ 123456// Transmit a character from the SCIvoid scia_xmit(int ch)&#123; while ((USART1-&gt;ISR &amp; USART_ISR_TC_Msk) == FALSE); USART1-&gt;TDR = (uint8)(ch &amp; 0xFF);&#125; &emsp;è¯¥å‡½æ•°å®ç°äº†å•ä¸ªå­—ç¬¦çš„å‘é€ï¼Œæ³¨æ„å¯¹å­—ç¬¦ä¸0xffçš„&amp;æ“ä½œè¡¨ç¤ºå‘é€çš„æ•°æ®ä½ä¸º8ä½ã€‚ &emsp;åŸºäºè¯¥å‡½æ•°è¿˜å¯ä»¥å°è£…è¯¸å¦‚å‘é€å­—ç¬¦ä¸²ã€æ•°å­—ã€ä¸åŒè¿›åˆ¶æ•°çš„ç›¸å…³å‡½æ•°ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include \"uart.h\"// Test 1,SCIA DLB, 8-bit word, baud rate 0x000F, default, 1 STOP bit, no parity// Transmit a character from the SCIvoid scia_xmit(int ch)&#123; while ((USART1-&gt;ISR &amp; USART_ISR_TC_Msk) == FALSE); USART1-&gt;TDR = (uint8)(ch &amp; 0xFF);&#125;void scia_msg(char * msg)&#123; int i; i = 0; while(msg[i] != '\\0') &#123; scia_xmit(msg[i]); i++; &#125;&#125;void uart_printf(char * msg)&#123; int i; i = 0; while(msg[i] != '\\0') &#123; scia_xmit(msg[i]); i++; &#125;&#125;void uart_print_data(int32 data)&#123; int i = 0; char temp[7]; if (data &lt; 0) &#123; data = - data; temp[0] = '-'; &#125; else temp[0] = ' '; temp[1] = data / 10000 + '0'; temp[2] = (data % 10000) /1000 + '0'; temp[3] = (data % 1000 ) /100 + '0'; temp[4] = (data % 100 ) /10 + '0'; temp[5] = (data % 10 ) /1 + '0'; temp[6] = '\\0'; while(temp[i] != '\\0') &#123; scia_xmit(temp[i]); i++; &#125;&#125;void uart_print_info(char * msg, int32 data)&#123; uart_printf(msg); uart_printf(\": \"); uart_print_data(data); uart_printf(\"\\n\");&#125;void printNumber(unsigned long n, uint8 base) &#123; char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte. char *str = &amp;buf[sizeof(buf) - 1]; *str = '\\0'; // prevent crash if called with base == 1 if (base &lt; 2) base = 10; do &#123; unsigned long m = n; n /= base; char c = m - base * n; *--str = c &lt; 10 ? c + '0' : c + 'A' - 10; &#125; while(n); uart_printf(str);&#125;// Receive a character from the SCIuint8 scia_recv(void)&#123; uint8 ch; while ((USART1-&gt;ISR &amp; UART_FLAG_RXNE) == FALSE); ch = USART1-&gt;RDR &amp; 0xFF; return ch;&#125; UARTæ¥æ”¶å‡½æ•°çš„ç®€åŒ–&emsp;åŒç†ï¼ŒHAL_UART_Receive()å‡½æ•°çš„å®ç°ä¹Ÿç›¸å¯¹å¤æ‚ï¼Œè¿™é‡Œè¿›è¡Œä¸€ä¸ªç®€å•ç®€åŒ–ã€‚ 12345678// Receive a character from the SCIuint8 scia_recv(void)&#123; uint8 ch; while ((USART1-&gt;ISR &amp; UART_FLAG_RXNE) == FALSE); ch = USART1-&gt;RDR &amp; 0xFF; return ch;&#125; &emsp;è¯¥å‡½æ•°å®ç°äº†é˜»å¡ç­‰å¾…æ–¹å¼è¯»å–ä¸€ä¸ªæ¥æ”¶å­—ç¬¦ã€‚ ç®€åŒ–çš„UARTå‘é€æ¥æ”¶&emsp;ç¤ºä¾‹ä»£ç å¦‚ä¸‹ï¼Œå…¶å®ç°çš„åŠŸèƒ½ä¸åŸºäºHALçš„å‘é€æ¥æ”¶å‡½æ•°ä¸€è‡´ï¼Œä½†æ˜¯å¾—åˆ°äº†æ˜æ˜¾ç®€åŒ–ã€‚ 123456if ((USART1-&gt;ISR &amp; USART_ISR_RXNE_Msk) != FALSE)&#123; usart1_rx[0] = USART1-&gt;RDR &amp; 0xFF; uart_printf(\"\\nYou send: \"); scia_xmit(usart1_rx[0]);&#125;","categories":[{"name":"åµŒå…¥å¼","slug":"åµŒå…¥å¼","permalink":"http://jiaodi.tech/categories/åµŒå…¥å¼/"}],"tags":[{"name":"GPIO","slug":"GPIO","permalink":"http://jiaodi.tech/tags/GPIO/"},{"name":"STM32F7","slug":"STM32F7","permalink":"http://jiaodi.tech/tags/STM32F7/"},{"name":"UART","slug":"UART","permalink":"http://jiaodi.tech/tags/UART/"}]},{"title":"STM32F767 delayå‡½æ•°çš„HALåº“å®ç°ä¸ä¼˜åŒ–","slug":"stm32f767-delay","date":"2018-03-29T11:48:22.000Z","updated":"2018-04-05T10:07:31.523Z","comments":true,"path":"2018/03/29/stm32f767-delay/","link":"","permalink":"http://jiaodi.tech/2018/03/29/stm32f767-delay/","excerpt":"&emsp;æœ¬æ–‡ä»‹ç»STM32F767 delayå‡½æ•°çš„HALåº“å®ç°ä¸ä¼˜åŒ–ã€‚","text":"&emsp;æœ¬æ–‡ä»‹ç»STM32F767 delayå‡½æ•°çš„HALåº“å®ç°ä¸ä¼˜åŒ–ã€‚ å¼€å‘ç¯å¢ƒç¡¬ä»¶ç¯å¢ƒ ç”µè„‘ï¼šWindows 10 Home x64 Apollo STM32F767å¼€å‘æ¿(ST-LINK V2ä»¿çœŸå™¨) è½¯ä»¶ç¯å¢ƒ Keil Version 5.24.1 (Pack Installerï¼šKeil.STM32F7xx_DFP.2.9.0.pack) STM32CubeMX Version 4.25.0(Packages Managerï¼šSTM32CubeF7) HALåº“å®ç°æ–¹å¼&emsp;é¦–å…ˆäº†è§£HALåº“ä¸­delayçš„å®ç°æ–¹å¼ã€‚ SYSTICKåˆå§‹åŒ–&emsp;åˆå§‹åŒ–å‡½æ•°å¦‚ä¸‹æ‰€ç¤ºã€‚ 12345678910 /**Configure the Systick interrupt time */HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000); /**Configure the Systick */HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);/* SysTick_IRQn interrupt configuration */HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0); &emsp;åˆå§‹åŒ–å‡½æ•°ä¸­å°†SYSTICKæ—¶é’Ÿæºè®¾ç½®ä¸ºHCLKï¼ŒåŒæ—¶å°†SYSTICKä¸­æ–­å‘¨æœŸè®¾ç½®ä¸º1msã€‚ SYSTICKä¸­æ–­å‡½æ•°&emsp;ä¸­æ–­å‡½æ•°å¦‚ä¸‹æ‰€ç¤ºã€‚ 123456789101112131415161718192021222324/** * @brief This function handles SysTick Handler. * @param None * @retval None */void SysTick_Handler(void)&#123; HAL_IncTick();&#125;__weak void HAL_IncTick(void)&#123; uwTick += uwTickFreq;&#125;HAL_TickFreqTypeDef uwTickFreq = HAL_TICK_FREQ_DEFAULT; /* 1KHz */typedef enum&#123; HAL_TICK_FREQ_10HZ = 100U, HAL_TICK_FREQ_100HZ = 10U, HAL_TICK_FREQ_1KHZ = 1U, HAL_TICK_FREQ_DEFAULT = HAL_TICK_FREQ_1KHZ&#125; HAL_TickFreqTypeDef; &emsp;ä¸­æ–­æœåŠ¡å‡½æ•°çš„æœ€ç»ˆåŠŸèƒ½æ˜¯å¯¹uwTickè¿›è¡ŒåŠ 1æ“ä½œï¼Œå³1msä¸­æ–­åˆ™uwTickå¢åŠ 1ã€‚ delayå‡½æ•°&emsp;å‡½æ•°å®ç°å¦‚ä¸‹æ‰€ç¤ºã€‚ 1234567891011121314151617181920__weak void HAL_Delay(uint32_t Delay)&#123; uint32_t tickstart = HAL_GetTick(); uint32_t wait = Delay; /* Add a freq to guarantee minimum wait */ if (wait &lt; HAL_MAX_DELAY) &#123; wait += (uint32_t)(uwTickFreq); &#125; while ((HAL_GetTick() - tickstart) &lt; wait) &#123; &#125;&#125;__weak uint32_t HAL_GetTick(void)&#123; return uwTick;&#125; &emsp;delayå‡½æ•°çš„å®ç°æ¯”è¾ƒæ¸…æ™°ï¼Œé¦–å…ˆåˆ©ç”¨tickstartå­˜å‚¨uwTickå½“å‰å€¼ï¼Œwaitå€¼ä¸ºæ‰€éœ€å»¶æ—¶msæ•°ï¼Œç¨‹åºå°†è½®è¯¢æ£€æµ‹uwTickå½“å‰å€¼ä¸tickstartå·®å€¼æ˜¯å¦å°äºwaitï¼Œç›´åˆ°è¾¾åˆ°æ‰€éœ€å»¶è¿Ÿæ•°åˆ™è·³å‡ºå¾ªç¯ã€‚ delayå‡½æ•°çš„ç¼ºé™·&emsp;HALåº“ç»™å‡ºçš„delayå‡½æ•°å®ç°äº†msçº§åˆ«çš„å»¶æ—¶ï¼Œä½†æ˜¯æœ‰2ç‚¹ä¸¥é‡ä¸è¶³ã€‚ å»¶æ—¶å‡†ç¡®æ€§éš¾ä»¥ä¿è¯ï¼šuwTickåœ¨SYSTICKä¸­æ–­ä¸­å¢åŠ ï¼Œä½†æ˜¯SYSTICKæœ¬èº«çš„ä¸­æ–­å¯èƒ½è¢«æ›´é«˜ä¼˜å…ˆçº§çš„ä¸­æ–­æ‰“æ–­ï¼Œè¿™å°†å¯¼è‡´uwTickå»¶è¿Ÿå¢åŠ ã€‚å½“å‰ç¨‹åºè®¾ç½®ä¸­SYSTICKçš„ä¸­æ–­ä¼˜å…ˆçº§è®¾ç½®åˆ°æœ€é«˜ï¼Œä½†æ˜¯å®é™…ç³»ç»Ÿä¸­ä¸­æ–­ä¼˜å…ˆçº§éœ€è¦æ ¹æ®ä»»åŠ¡çš„é‡è¦æ€§æ¥è®¾ç½®ï¼Œé€šå¸¸SYSTICKä¸ä¼šæ˜¯æœ€é«˜ä¼˜å…ˆçº§çš„ä¸­æ–­ï¼› å»¶æ—¶åˆ†è¾¨ç‡ä¸å¤Ÿï¼šdelayå‡½æ•°åªèƒ½å®ç°msçº§åˆ«çš„å»¶æ—¶ï¼Œæ›´çŸ­æ—¶é—´çš„å»¶æ—¶æ— æ³•å®ç°ã€‚ &emsp;åŸºäºä»¥ä¸Šè€ƒè™‘ï¼Œéœ€è¦å¯¹delayå‡½æ•°è¿›è¡Œä¼˜åŒ–ã€‚ Delayå‡½æ•°çš„ä¼˜åŒ–SYSTICKåˆå§‹åŒ–&emsp;åˆå§‹åŒ–å‡½æ•°å¦‚ä¸‹æ‰€ç¤ºã€‚ 1234567891011121314151617181920212223#define SYSTICK_Frequency 1000 //in Hzstatic uint32 systick_load = 0; // SysTick load value, period 1000/SYSTICK_Frequency msstatic uint32 systick_per_us = 0; // SysTick delta value per usuint32 delay_us_max = 0; //max value in Delay_US/**Configure the Systick interrupt time*/systick_load = HAL_RCC_GetHCLKFreq()/SYSTICK_Frequency; HAL_SYSTICK_Config(systick_load); systick_per_us = systick_load * SYSTICK_Frequency / 1000 / 1000;//systick_per_us = HAL_RCC_GetHCLKFreq() / 1000 / 1000; delay_us_max = UINT32_MAX / systick_per_us; /**Configure the Systick*/HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);/* SysTick_IRQn interrupt configuration */HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0); &emsp;é’ˆå¯¹å„ä¸ªå˜é‡çš„è¯´æ˜è§ä¸‹å›¾ã€‚ å˜é‡ è¯´æ˜ SYSTICK_Frequency SYSTICKä¸­æ–­é¢‘ç‡ï¼Œå•ä½ä¸ºHzã€‚ systick_load SYSTICK reloadå€¼ï¼Œreloadç­‰äºSYSTICKæ—¶é’Ÿé¢‘ç‡/SYSTICK_Frequencyï¼Œä½¿å¾—ä¸­æ–­é¢‘ç‡ä¸ºSYSTICK_Frequencyã€‚ 1000/SYSTICK_Frequency SYSTICKä¸­æ–­å‘¨æœŸï¼Œå•ä½ä¸ºmsã€‚ systick_load * SYSTICK_Frequency / 1000 1ms SYSTICKè®¡æ•°å™¨çš„å˜åŒ–å€¼ã€‚ systick_per_us 1us SYSTICKè®¡æ•°å™¨çš„å˜åŒ–å€¼ã€‚ delay_us_max SYS_Delay_US()å‡½æ•°å…è®¸çš„æœ€å¤§å»¶æ—¶usæ•°ï¼Œç”±UINT32_MAXä¸systick_per_uså†³å®šã€‚ æœ€åå¾—åˆ°çš„delay_us_maxå€¼ä¸ºï¼š19884107ï¼Œå³å»¶æ—¶æœ€å¤§å‘¨æœŸä¸è¶…è¿‡19884107usï¼Œçº¦19.8sã€‚ delayå‡½æ•°&emsp;å‡½æ•°å¦‚ä¸‹æ‰€ç¤ºã€‚ 12345678910111213141516171819202122232425262728293031void SYS_Delay_US(uint32_t delay_us)&#123; uint32 systick_pre = SysTick-&gt;VAL; uint32 systick_now = 0; uint32 delay_total = 0; uint32 delay_sum = 0; if (delay_us &gt; delay_us_max) &#123; while (1); &#125; delay_total = systick_per_us * delay_us; while (delay_total &gt; delay_sum) &#123; systick_now = SysTick-&gt;VAL; if (systick_now &lt; systick_pre) &#123; delay_sum += systick_pre - systick_now; systick_pre = systick_now; &#125; else if (systick_now &gt; systick_pre) &#123; delay_sum += systick_load - (systick_now - systick_pre); systick_pre = systick_now; &#125; &#125;&#125; &emsp;ç¨‹åºçš„é€»è¾‘æ¯”è¾ƒç®€æ˜ï¼Œæ ¸å¿ƒæ€æƒ³ä¸ºä¸æ–­è·å–SysTickè®¡æ•°å€¼çš„æ”¹å˜é‡ï¼Œå¯¹æ”¹å˜é‡è¿›è¡Œç´¯åŠ ä»¥æ¨ç®—å»¶æ—¶æ—¶é—´ï¼›å½“å»¶æ—¶æ—¶é—´è¾¾åˆ°é¢„æœŸåˆ™è·³å‡ºå¾ªç¯ã€‚ç®€å•ä»‹ç»å¦‚ä¸‹ã€‚ è¿›å…¥ç¨‹åºåç«‹å³ä¿å­˜å½“å‰SysTickè®¡æ•°å€¼ï¼Œä¾¿äºåç»­æ¯”è¾ƒï¼› æ£€æµ‹delay_uså€¼æ˜¯å¦è¶…é™ï¼Œè¶…é™åˆ™åœæ­¢è¿è¡Œå‘Šè­¦ï¼› delay_totalä¸ºå»¶æ—¶éœ€è¦çš„SysTickè®¡æ•°å€¼æ”¹å˜é‡ï¼› ä½¿ç”¨systick_nowè·å–å½“å‰SysTickè®¡æ•°å€¼ï¼Œä¸systick_preè¿›è¡Œå¯¹æ¯”ã€‚SysTick-&gt;VALä¸ºé€’å‡è®¡æ•°å™¨ï¼Œå¦‚æœæœªå‘ç”Ÿreloadï¼Œåˆ™æ”¹å˜å€¼ä¸ºsystick_pre - systick_nowï¼›å¦‚æœå‘ç”Ÿäº†reloadï¼Œåˆ™æ”¹å˜å€¼ä¸ºsystick_load - (systick_now - systick_pre)ï¼› delay_sumä¸ºSysTickæ€»çš„æ”¹å˜é‡ï¼Œå½“å¤§äºdelay_totalåˆ™è·³å‡ºå¾ªç¯ã€‚ &emsp;æ³¨æ„ï¼Œè¯¥å‡½æ•°æˆç«‹çš„å‰ææœ‰ä¸€ä¸ªåŸºæœ¬å‡è®¾ï¼Œå³2æ¬¡ä½¿ç”¨systick_nowè·å–å½“å‰SysTickè®¡æ•°å€¼ä¹‹é—´æœ€å¤šå‘ç”Ÿä¸€æ¬¡reloadï¼Œå¦‚æœå‘ç”Ÿ2æ¬¡åŠä»¥ä¸Šä»¥ä¸Šç¨‹åºæ— æ³•åˆ†è¾¨ï¼Œåˆ™åªä¼šè®¡æ•°ä¸€æ¬¡ï¼Œåˆ™å»¶æ—¶å€¼ä¸å‡†ç¡®ã€‚äº‹å®ä¸ŠSysTickçš„ä¸­æ–­ä¸€èˆ¬ä¸ºmsçº§åˆ«ï¼ŒåŒæ—¶STM32F7çš„è¿ç®—é€Ÿåº¦å¾ˆé«˜ï¼Œsystick_nowè·å–å½“å‰SysTickè®¡æ•°å€¼çš„å®æ—¶æ€§å¾ˆé«˜ï¼Œä¸ä¼šå‡ºç°å‡è®¾ä¸­æè¿°çš„å¼‚å¸¸ã€‚ å®éªŒéªŒè¯&emsp;mainå‡½æ•°ä¸­å¯¹SYS_Delay_US()å‡½æ•°è¿›è¡Œæµ‹è¯•ï¼Œç¨‹åºå¦‚ä¸‹ã€‚ 1234567while (1) &#123; mainloop++; HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_0); HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1); SYS_Delay_US(100); &#125; &emsp;ä½¿ç”¨é€»è¾‘åˆ†æä»ªæ£€æµ‹PB1ç”µå¹³å˜åŒ–ï¼Œä¸é¢„æœŸä¸€è‡´ã€‚","categories":[{"name":"åµŒå…¥å¼","slug":"åµŒå…¥å¼","permalink":"http://jiaodi.tech/categories/åµŒå…¥å¼/"}],"tags":[{"name":"STM32F7","slug":"STM32F7","permalink":"http://jiaodi.tech/tags/STM32F7/"},{"name":"STM32CubeMX","slug":"STM32CubeMX","permalink":"http://jiaodi.tech/tags/STM32CubeMX/"},{"name":"Systick","slug":"Systick","permalink":"http://jiaodi.tech/tags/Systick/"}]},{"title":"STM32F767ç³»ç»Ÿå†…æ ¸ä¸æ—¶é’Ÿè®¾ç½®","slug":"stm32f767-system","date":"2018-03-23T12:48:14.000Z","updated":"2018-03-27T13:00:30.785Z","comments":true,"path":"2018/03/23/stm32f767-system/","link":"","permalink":"http://jiaodi.tech/2018/03/23/stm32f767-system/","excerpt":"&emsp;æœ¬æ–‡ä»‹ç»å¦‚ä½•å¯¹STM32F767çš„ç³»ç»Ÿå†…æ ¸ä¸æ—¶é’Ÿè¿›è¡Œè®¾ç½®ã€‚","text":"&emsp;æœ¬æ–‡ä»‹ç»å¦‚ä½•å¯¹STM32F767çš„ç³»ç»Ÿå†…æ ¸ä¸æ—¶é’Ÿè¿›è¡Œè®¾ç½®ã€‚ å¼€å‘ç¯å¢ƒç¡¬ä»¶ç¯å¢ƒ ç”µè„‘ï¼šWindows 10 Home x64 Apollo STM32F767å¼€å‘æ¿(ST-LINK V2ä»¿çœŸå™¨) è½¯ä»¶ç¯å¢ƒ Keil Version 5.24.1 (Pack Installerï¼šKeil.STM32F7xx_DFP.2.9.0.pack) STM32CubeMX Version 4.25.0(Packages Managerï¼šSTM32CubeF7) ç³»ç»Ÿè®¾ç½®&emsp;STM32F767åŸºäºå¼ºå¤§çš„Cortex-M7å†…æ ¸ï¼Œå…¶è®¸å¤šç³»ç»Ÿç‰¹æ€§éœ€è¦è¿›è¡Œè®¾ç½®ä»¥å‘æŒ¥æœ€é«˜æ€§èƒ½ã€‚ è®¾ç½®Flash Interface&emsp;STM32F767çš„flashæ”¯æŒTCMä¸AXIæ¥å£ï¼Œè€ŒChrom-Art Acceleratorä¸Instruction Prefetchä»…æ”¯æŒåœ¨TCMæ¨¡å¼ä¸‹ä½¿ç”¨ã€‚å› æ­¤ï¼Œéœ€è¦é¦–å…ˆå°†flashé…ç½®ä¸ºTCMæ¥å£ã€‚TCMæ¥å£çš„é€‰æ‹©é€šè¿‡BOOTå¼•è„šä»¥åŠFlashé€‰é¡¹æ§åˆ¶å¯„å­˜å™¨FLASH_OPTCR1è¿›è¡Œè®¾ç½®ã€‚ &emsp;å½“BOOT pin=0æ—¶ï¼ŒFLASH_OPTCR1å¯„å­˜å™¨å…³äºBOOTçš„é€‰é¡¹å¦‚ä¸‹æ‰€ç¤ºã€‚ &emsp;é»˜è®¤çŠ¶æ€ä¸‹ï¼ŒBOOT_ADD0çš„å€¼ä¸º0x80ï¼Œå³é»˜è®¤ä»¥TCMæ¥å£å¯åŠ¨ã€‚ &emsp;å¯ä»¥é€šè¿‡è¯»å–Flashé»˜è®¤é…ç½®ä»¥ç¡®è®¤Flashæ¥å£ï¼Œç¨‹åºå¦‚ä¸‹æ‰€ç¤ºã€‚ 123FLASH_OBProgramInitTypeDef Flash_InitStruct;HAL_FLASHEx_OBGetConfig(&amp;Flash_InitStruct); &emsp;å¯ä»¥çœ‹åˆ°ç³»ç»Ÿé»˜è®¤çŠ¶æ€ä¸‹BOOT_ADD0çš„å€¼ä¸º0x80ã€‚ ä½¿èƒ½Chrom-Art Acceleratorä¸Instruction Prefetch&emsp;Chrom-Art Acceleratorâ„¢ (DMA2D) æ˜¯ä¸“ç”¨äºå›¾åƒå¤„ç†çš„ä¸“ä¸š DMAï¼Œå°†å…¶å¼€å¯æœ‰åˆ©äºæå‡å›¾åƒç›¸å…³å¤„ç†é€Ÿåº¦ã€‚Instruction Prefetchå³ä¸ºæŒ‡ä»¤é¢„è¯»å–ï¼ŒSTå¯¹å…¶çš„è§£é‡Šæ˜¯ï¼š æ¯ä¸ª flash è¯»æ“ä½œå¯è¯»å– 256 ä½ï¼Œå¯ä»¥æ˜¯ 8 è¡Œ 32 ä½æŒ‡ä»¤ï¼Œä¹Ÿå¯ä»¥æ˜¯ 16 è¡Œ 16 ä½æŒ‡ä»¤ï¼Œå…·ä½“å–å†³äºçƒ§å†™åœ¨ Flash ä¸­çš„ç¨‹åºã€‚å› æ­¤å¯¹äºé¡ºåºæ‰§è¡Œçš„ä»£ç ï¼Œè‡³å°‘éœ€è¦ 8 ä¸ª CPU å‘¨æœŸæ¥æ‰§è¡Œå‰ä¸€æŒ‡ä»¤è¡Œçš„è¯»å–æ“ä½œã€‚åœ¨ CPU å¯¹å½“å‰æŒ‡ä»¤è¡Œè¿›è¡Œæ“ä½œè¯·æ±‚æ—¶ï¼Œå¯ä½¿ç”¨ ITCM æ€»çº¿çš„é¢„å–æ“ä½œè¯»å– Flash ä¸­çš„ä¸‹ä¸€ä¸ªè¿ç»­å­˜æ”¾çš„æŒ‡ä»¤è¡Œã€‚å¯é€šè¿‡å°† FLASH_ACR å¯„å­˜å™¨ä¸­çš„ PRFTENä½ç½® 1 æ¥ä½¿èƒ½é¢„å–åŠŸèƒ½ã€‚å½“è®¿é—® Flash è‡³å°‘éœ€è¦ä¸€ä¸ªç­‰å¾…å‘¨æœŸæ—¶ï¼Œæ­¤åŠŸèƒ½éå¸¸æœ‰ç”¨ã€‚å¤„ç†éé¡ºåºæ‰§è¡Œçš„ä»£ç ï¼ˆæœ‰åˆ†æ”¯ï¼‰æ—¶ï¼ŒæŒ‡ä»¤å¯èƒ½å¹¶ä¸å­˜åœ¨äºå½“å‰ä½¿ç”¨çš„æŒ‡ä»¤è¡Œä»¥åŠé¢„å–çš„æŒ‡ä»¤è¡Œä¸­ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼ŒCPU å»¶è¿Ÿå‘¨æœŸæ•°è‡³å°‘ç­‰äºç­‰å¾…å‘¨æœŸæ•°ã€‚ &emsp;Art Acceleratorä¸Instruction Prefetchçš„å¯åŠ¨åœ¨HAL_Init()å‡½æ•°ä¸­å®Œæˆã€‚HAL_Init()å‡½æ•°å¦‚ä¸‹æ‰€ç¤ºã€‚ 123456789101112131415161718192021222324HAL_StatusTypeDef HAL_Init(void)&#123; /* Configure Instruction cache through ART accelerator */ #if (ART_ACCLERATOR_ENABLE != 0) __HAL_FLASH_ART_ENABLE();#endif /* ART_ACCLERATOR_ENABLE */ /* Configure Flash prefetch */#if (PREFETCH_ENABLE != 0U) __HAL_FLASH_PREFETCH_BUFFER_ENABLE();#endif /* PREFETCH_ENABLE */ /* Set Interrupt Group Priority */ HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4); /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */ HAL_InitTick(TICK_INT_PRIORITY); /* Init the low level hardware */ HAL_MspInit(); /* Return function status */ return HAL_OK;&#125; &emsp;æ³¨æ„åˆ°ART_ACCLERATOR_ENABLEä¸PREFETCH_ENABLEä¸ºæ§åˆ¶å…³é”®å­—ï¼Œå…¶å®šä¹‰åœ¨stm32f7xx_hal_conf.hæ–‡ä»¶ä¸­ï¼Œå°†å…¶è®¾ç½®ä¸º1å³è¡¨ç¤ºART Acceleratorä¸Prefetchå¯ç”¨ã€‚ 123456789/* ########################### System Configuration ######################### *//** * @brief This is the HAL system configuration section */ #define VDD_VALUE ((uint32_t)3300U) /*!&lt; Value of VDD in mv */#define TICK_INT_PRIORITY ((uint32_t)0x0FU) /*!&lt; tick interrupt priority */#define USE_RTOS 0U#define PREFETCH_ENABLE 1U#define ART_ACCLERATOR_ENABLE 1U /* To enable instruction cache and prefetch */ ä½¿èƒ½I Cacheä¸D Cache&emsp;I Cacheä¸ºæŒ‡ä»¤Cacheï¼ŒD Cacheä¸ºæ•°æ®Cacheã€‚Cacheä½äºCoreä¸SRAMæˆ–è€…å¤–éƒ¨RAMä¹‹é—´ï¼ŒCacheçš„é€Ÿç‡è¾ƒRAMæ›´é«˜ï¼Œåªè¦ä¿è¯Cacheæœ‰è¶³å¤Ÿé«˜çš„å‘½ä¸­ç‡ï¼Œåˆ™å¯ä»¥è¿›ä¸€æ­¥æé«˜Coreä¸SRAMæˆ–è€…å¤–éƒ¨RAMä¹‹é—´çš„æ•°æ®äº¤äº’é€Ÿç‡ï¼Œè¿›è€Œæé«˜æ€§èƒ½ã€‚ &emsp;åœ¨system.cæ–‡ä»¶ä¸­å»ºç«‹å¦‚ä¸‹å‡½æ•°ã€‚ 1234567891011//enable CPU L1-Cachevoid Cache_Enable(void)&#123; SCB_InvalidateICache();//enable I Cache. SCB_EnableICache(); SCB_InvalidateDCache();//enable D Cache. SCB_EnableDCache(); SCB-&gt;CACR|=1&lt;&lt;2; //Enables Force Write-Through. All Cacheable memory regions are treated as Write-Through.&#125; &emsp;å…³äºCacheçš„å‡½æ•°è¯´æ˜åœ¨Keilå®˜ç½‘ä¸­CMSIS-Core (Cortex-M)éƒ¨åˆ†ï¼ŒåŒæ—¶å®‰è£…STM32CubeMX åCMSISæ–‡ä»¶å¤¹ä¸‹ä¹Ÿæœ‰ç›¸å…³æ–‡æ¡£ï¼Œä¸å®˜ç½‘ä¸€è‡´ã€‚ &emsp;æ³¨æ„åˆ°åœ¨I/D Cacheä½¿èƒ½å‰å‡ä½¿ç”¨Invalidateç›¸å…³å‡½æ•°æ— æ•ˆåŒ–äº†Cacheä¸­çš„æ•°æ®ï¼Œå®˜ç½‘ä¸­æ˜ç¡®æå‡ºç³»ç»Ÿå¤ä½åï¼Œå¿…é¡»åœ¨Enableå‡½æ•°å‰é¦–å…ˆåº”ç”¨Invalidateå‡½æ•°ã€‚å¯ä»¥ç†è§£åœ¨ç³»ç»Ÿå¤ä½åï¼ŒCacheä¸­çš„æŒ‡ä»¤\\æ•°æ®æ˜¯æ— æ•ˆçš„ï¼Œä¸ºäº†é¿å…dirtyæŒ‡ä»¤\\æ•°æ®å½±å“ç³»ç»Ÿè¿è¡Œï¼Œåˆ™é¦–å…ˆå°†å…¶æ— æ•ˆåŒ–ã€‚ &emsp;å†æœ‰ä¸€ä¸ªé‡è¦æ“ä½œæ˜¯å¯¹SCB-&gt;CACRå¯„å­˜å™¨FORCEWTè¿›è¡Œä½¿èƒ½ï¼Œè¿›è¡Œå¼ºåˆ¶Write-Throughã€‚è¿™é‡Œä¸»è¦æ˜¯ä¸ºäº†è§£å†³Cacheçš„ä¸€è‡´æ€§é—®é¢˜ã€‚å…³äºCacheçš„ä¸€è‡´æ€§é—®é¢˜å¯ä»¥å‚è€ƒæ–‡æ¡£AN4839: Level 1 cache on STM32F7 Series and STM32H7 Seriesã€‚æ ¹æ®STM32F7 MPU Cacheæµ…æä¸€æ–‡ï¼Œä¸€è‡´æ€§é—®é¢˜çš„ä¸»è¦å‘ç”Ÿåœ¨ä¸¤ç§æƒ…å½¢ï¼š ç¬¬ä¸€ç§æƒ…å†µæ˜¯å½“æœ‰å†™ç‰©ç†å†…å­˜çš„æŒ‡ä»¤æ—¶ï¼Œcoreä¼šå…ˆå»æ›´æ–°ç›¸åº”çš„cache-line(Write-backç­–ç•¥)ï¼Œåœ¨æ²¡æœ‰cleançš„æƒ…å†µä¸‹ï¼Œä¼šå¯¼è‡´å…¶å¯¹åº”çš„å®é™…ç‰©ç†å†…å­˜ä¸­çš„æ•°æ®å¹¶æ²¡æœ‰è¢«æ›´æ–°ï¼Œå¦‚æœè¿™ä¸ªæ—¶å€™æœ‰å…¶å®ƒçš„Hostï¼ˆå¦‚DMAï¼‰è®¿é—®è¿™æ®µå†…å­˜æ—¶ï¼Œå°±ä¼šå‡ºç°é—®é¢˜ï¼ˆç”±äºå®é™…ç‰©ç†å†…å­˜å¹¶æœªè¢«æ›´æ–°ï¼Œå’ŒD-cacheä¸­çš„ä¸ä¸€è‡´ï¼‰ï¼Œè¿™å°±æ˜¯æ‰€è°“çš„cacheä¸€è‡´æ€§çš„é—®é¢˜ï¼ ç¬¬äºŒç§æƒ…å†µæ˜¯DMAæ›´æ–°äº†æŸæ®µç‰©ç†å†…å­˜ï¼ˆDMAå’Œcacheç›´æ¥æ²¡æœ‰ç›´æ¥é€šé“ï¼‰ï¼Œè€Œè¿™ä¸ªæ—¶å€™Coreå†è¯»å–è¿™æ®µå†…å­˜çš„æ—¶å€™ï¼Œç”±äºç›¸å¯¹åº”åœ°å€çš„cache-lineæ²¡æœ‰è¢«invalidateï¼Œå¯¼è‡´Coreè¯»åˆ°çš„æ˜¯cache-lineä¸­çš„æ•°æ®ï¼Œè€Œéè¢«DMAæ›´æ–°è¿‡çš„å®é™…ç‰©ç†å†…å­˜çš„æ•°æ®ï¼ &emsp;é’ˆå¯¹Cacheä¸€è‡´æ€§é—®é¢˜ï¼Œä»¥ä¸Šæåˆ°çš„ä¸¤ç¯‡æ–‡ç« ä¹Ÿç»™å‡ºäº†ç›¸åº”çš„è§£å†³æ–¹æ³•ã€‚ MPUé…ç½®çš„ä»£ç ï¼Œå°†å±æ€§æ”¹ä¸ºMPU_ACCESS_BUFFERABLEï¼Œå³ä½¿ç”¨write-thoughç­–ç•¥è€Œéé»˜è®¤çš„write-backç­–ç•¥ï¼› é€šè¿‡Cacheæ§åˆ¶å¯„å­˜å™¨SCB-&gt;CACRï¼Œå°†æ‰€æœ‰cacheableçš„ç©ºé—´å…¨éƒ¨å¼ºåˆ¶write-thoughï¼› åœ¨å¯¹cacheableå†…å­˜åŒºåŸŸå†™æ•°æ®æ—¶ï¼Œè¿›è¡Œcache maintenanceæ“ä½œï¼Œå³CleanCacheæ“ä½œï¼Œå°†dirty dataæ›´æ–°åˆ°çœŸå®çš„ç‰©ç†åœ°å€ä¸­ï¼› ä¿®æ”¹MPU SRAM1åŒºåŸŸåˆ°å…±äº«åŒºåŸŸï¼Œå¯ä»¥é¿å…é»˜è®¤çŠ¶æ€ä¸‹SRAM1å¯è¢«D Cacheç¼“å­˜ã€‚ &emsp;å½“å‰ç¨‹åºä¸­ä½¿ç”¨ç¬¬2ç§æ–¹æ³•ï¼Œå®é™…ä¸Šè¿™å¯¹æ€§èƒ½æ˜¯æœ‰æŸå¤±çš„ï¼Œåç»­å°†å°è¯•ä½¿ç”¨æ›´é«˜æ•ˆæ–¹æ³•ã€‚ç›´è§‰ä¸Šæ–¹æ³•1ä¸æ–¹æ³•2éƒ½ä¸€å®šç¨‹åºæŠ‘åˆ¶äº†Cacheçš„æ€§èƒ½ï¼Œæ–¹æ³•4åˆ™ç›´æ¥å°†SRAM1è®¾ç½®ä¸ºä¸ç¼“å­˜ï¼Œæ–¹æ³•3åº”è¯¥æ˜¯å¯¹æ€§èƒ½å½±å“æœ€ä½ä½†æ˜¯æ“ä½œéœ€è¦å¼‚å¸¸å°å¿ƒçš„æ–¹æ³•ã€‚ æ—¶é’Ÿè®¾ç½®æ—¶é’Ÿæ ‘&emsp;STM32F767çš„æ—¶é’Ÿç³»ç»Ÿæ¯”è¾ƒå¤æ‚ï¼Œæ—¶é’Ÿæ ‘æ€»ä½“å¦‚å›¾æ‰€ç¤ºã€‚ æ—¶é’Ÿæº&emsp;STM32F767çš„æ—¶é’Ÿæºæœ‰5ä¸ªï¼Œåˆ†åˆ«åˆ—ä¸¾è¯´æ˜å¦‚ä¸‹ã€‚ LSIï¼šLow Speed Internalï¼Œå†…éƒ¨ä½é€Ÿæ—¶é’Ÿï¼Œä¸ºRCæŒ¯è¡å™¨æ„æˆï¼Œé¢‘ç‡çº¦ä¸º32KHzï¼› LSEï¼šLow Speed Externalï¼Œå¤–éƒ¨ä½é€Ÿæ—¶é’Ÿï¼Œç”±å¤–éƒ¨æ™¶ä½“æä¾›ï¼Œå½“å‰ç¡¬ä»¶æ­¤æ—¶é’Ÿä¸º32.768kHzï¼› HSIï¼šHigh Speed Internalï¼Œå†…éƒ¨é«˜é€Ÿæ—¶é’Ÿï¼Œä¸ºRCæŒ¯è¡å™¨æ„æˆï¼Œé¢‘ç‡çº¦ä¸º16MHzï¼› HSEï¼šHigh Speed Externalï¼Œå¤–éƒ¨é«˜é€Ÿæ—¶é’Ÿï¼Œç”±å¤–éƒ¨æ™¶ä½“æä¾›ï¼Œå½“å‰ç¡¬ä»¶æ­¤æ—¶é’Ÿä¸º25MHzï¼› PLLCLKï¼šé”ç›¸ç¯è¾“å‡ºæ—¶é’Ÿã€‚ SYSCLKè®¾ç½®&emsp;SYSCLKæ—¶é’Ÿçš„è®¾ç½®å¯ä»¥åŸºäºSTM32CubeMX ç”Ÿæˆä»£ç ï¼ŒSTM32CubeMX çš„è®¾ç½®åŸç†å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚ &emsp;ä½¿ç”¨STM32CubeMX è®¾ç½®æ—¶é’Ÿéå¸¸æ–¹ä¾¿ï¼Œå›¾ä¸­åŸºæœ¬çš„è®¾ç½®ä¸ºï¼šå¯ç”¨HSEæ—¶é’Ÿï¼Œæ—¶é’Ÿä¸º25MHzï¼Œå°†å…¶ä½œä¸ºPLLæ—¶é’Ÿæºã€‚PLLM=25ï¼ŒPLLN=432ï¼ŒPLLP=2ï¼Œæœ€åå¾—åˆ°çš„PLLCLKä¸ºï¼š $$PLLCLK=HSE\\cdot \\frac{1}{25}\\cdot 432\\cdot \\frac{1}{2}=216MHz$$ &emsp;SYSCLKçš„æ—¶é’Ÿæºé€‰æ‹©PLLCLKï¼Œå³ä¸º216MHzï¼Œè¿™æ˜¯ç³»ç»Ÿå…è®¸çš„æœ€é«˜æ—¶é’Ÿã€‚ &emsp;å½“SYSCLKè®¾ç½®å®Œæ¯•åï¼Œåˆ†åˆ«è®¾ç½®SYSTICKï¼ŒAPB1ä¸APB2åˆ†é¢‘ç³»æ•°ï¼Œå¯ä»¥å¾—åˆ°å¦‚å›¾æ‰€ç¤ºçš„å„è‡ªæ—¶é’Ÿé¢‘ç‡ã€‚ RTCæ—¶é’Ÿè®¾ç½®&emsp;RTCæ—¶é’Ÿéœ€è¦ç²¾å‡†çš„æ—¶é’Ÿæºï¼Œè€Œå¤–éƒ¨æ—¶é’Ÿçš„ç²¾åº¦é€šå¸¸é«˜äºå†…éƒ¨æ—¶é’Ÿï¼Œå› æ­¤RTCæ—¶é’Ÿæºéœ€è¦é€‰æ‹©å¤–éƒ¨æ™¶ä½“ã€‚RTCçš„ä½¿ç”¨éœ€è¦é¢å¤–è®¾ç½®ï¼Œåç»­ç« èŠ‚å†è¿›è¡Œè¯¦ç»†ä»‹ç»ã€‚ ä»£ç å®ç°&emsp;æ—¶é’Ÿåˆå§‹åŒ–çš„ä»£ç å®ç°å¦‚ä¸‹ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * @brief System Clock Configuration * @retval None */void SystemClock_Config(void)&#123; RCC_OscInitTypeDef RCC_OscInitStruct; RCC_ClkInitTypeDef RCC_ClkInitStruct; /**Configure the main internal regulator output voltage */ __HAL_RCC_PWR_CLK_ENABLE(); __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1); /**Initializes the CPU, AHB and APB busses clocks */ RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 25; RCC_OscInitStruct.PLL.PLLN = 432; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 2; if (HAL_RCC_OscConfig(&amp;RCC_OscInitStruct) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; /**Activate the Over-Drive mode */ if (HAL_PWREx_EnableOverDrive() != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; /**Initializes the CPU, AHB and APB busses clocks */ RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2; if (HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK) &#123; _Error_Handler(__FILE__, __LINE__); &#125; /**Configure the Systick interrupt time */ HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000); /**Configure the Systick */ HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK); /* SysTick_IRQn interrupt configuration */ HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);&#125; &emsp;å¯¹ä»£ç çš„å‡ ä¸ªé‡ç‚¹è¿›è¡Œè¡¥å……è¯´æ˜ã€‚ __HAL_RCC_PWR_CLK_ENABLE()&emsp;è¯¥å‡½æ•°ç”¨äºä½¿èƒ½APB1ç”µæºæ¥å£æ—¶é’Ÿã€‚ __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1)&emsp;è¯¥å‡½æ•°ç”¨äºè®¾ç½®å†…éƒ¨è°ƒå‹å™¨è¾“å‡ºç”µå‹è¾“å‡ºç”µå‹ï¼Œå³è°ƒèŠ‚PWR_CR1å¯„å­˜å™¨VOSä½ï¼Œè®¾ç½®ä¸ºSCALE1å³ä¸ºåŒæ—¶æ‰“å¼€HAL_PWREx_EnableOverDrive()æ‰èƒ½å°†HCLKè®¾ç½®ä¸º216MHzã€‚å…·ä½“è¯´æ˜å‚è§SMT32F767ç”¨æˆ·æ‰‹å†Œ3.3.3èŠ‚ã€‚ æ—¶é’Ÿåˆå§‹åŒ–&emsp;å¯¹æ—¶é’Ÿçš„åˆå§‹åŒ–ä¸ºå¸¸è§„è°ƒç”¨ï¼Œå‚æ•°ä¸æœ¬æ–‡è¯´æ˜å»åˆï¼Œä¸å†ç»§ç»­è¯´æ˜ã€‚ HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_7)&emsp;è¯¥å‡½æ•°ä¸ºflashå»¶è¿Ÿè®¾ç½®ï¼Œå½“ç³»ç»Ÿä¾›ç”µç”µå‹ä¸HCLKæ˜ç¡®åï¼ŒæŒ‰ç…§ä¸‹è¡¨è®¾ç½®flashå»¶è¿Ÿæ•°ã€‚ SYSTICKåˆå§‹åŒ–&emsp;SYSTICKåˆå§‹åŒ–å°†å…¶å‘¨æœŸè®¾ç½®ä¸º1msï¼Œæ—¶é’Ÿæºä¸ºHCLKï¼ŒåŒæ—¶è®¾ç½®ä¸ºæœ€é«˜ä¼˜å…ˆçº§ã€‚","categories":[{"name":"åµŒå…¥å¼","slug":"åµŒå…¥å¼","permalink":"http://jiaodi.tech/categories/åµŒå…¥å¼/"}],"tags":[{"name":"STM32F7","slug":"STM32F7","permalink":"http://jiaodi.tech/tags/STM32F7/"},{"name":"STM32CubeMX","slug":"STM32CubeMX","permalink":"http://jiaodi.tech/tags/STM32CubeMX/"},{"name":"Keil","slug":"Keil","permalink":"http://jiaodi.tech/tags/Keil/"}]},{"title":"æ–°å»ºä¸€ä¸ªSTM32F767å·¥ç¨‹(åŸºäºHALåº“)","slug":"stm32f767newpro","date":"2018-03-18T12:51:20.000Z","updated":"2018-03-23T13:19:52.322Z","comments":true,"path":"2018/03/18/stm32f767newpro/","link":"","permalink":"http://jiaodi.tech/2018/03/18/stm32f767newpro/","excerpt":"&emsp;ä½¿ç”¨STM32CubeMXå¯ä»¥ç”Ÿæˆä¸€ä¸ªç›´æ¥å¯ç”¨çš„Keilå·¥ç¨‹ï¼Œä½†ä¸ºäº†åŠ æ·±å¯¹ç¨‹åºæ¡†æ¶çš„ç†è§£ä¸æŠŠæ§ï¼Œä»é›¶å¼€å§‹æ–°å»ºä¸€ä¸ªå·¥ç¨‹ä¹Ÿæ˜¯æœ‰å¿…è¦çš„ï¼Œæœ¬æ–‡å°†ç®€è¿°è¿™ä¸€è¿‡ç¨‹ã€‚","text":"&emsp;ä½¿ç”¨STM32CubeMXå¯ä»¥ç”Ÿæˆä¸€ä¸ªç›´æ¥å¯ç”¨çš„Keilå·¥ç¨‹ï¼Œä½†ä¸ºäº†åŠ æ·±å¯¹ç¨‹åºæ¡†æ¶çš„ç†è§£ä¸æŠŠæ§ï¼Œä»é›¶å¼€å§‹æ–°å»ºä¸€ä¸ªå·¥ç¨‹ä¹Ÿæ˜¯æœ‰å¿…è¦çš„ï¼Œæœ¬æ–‡å°†ç®€è¿°è¿™ä¸€è¿‡ç¨‹ã€‚ å¼€å‘ç¯å¢ƒç¡¬ä»¶ç¯å¢ƒ ç”µè„‘ï¼šWindows 10 Home x64 Apollo STM32F767å¼€å‘æ¿(ST-LINK V2ä»¿çœŸå™¨) è½¯ä»¶ç¯å¢ƒ Keil Version 5.24.1 (Pack Installerï¼šKeil.STM32F7xx_DFP.2.9.0.pack) STM32CubeMX Version 4.25.0(Packages Managerï¼šSTM32CubeF7) æ–‡ä»¶å‡†å¤‡å‚ç…§åº“&emsp;å·¥ç¨‹çš„å»ºç«‹åŸºäºSTå®˜æ–¹çš„åº“å‡½æ•°ï¼Œå³STM32CubeF7å›ºä»¶åº“ä¸­çš„ç›¸å…³æ–‡ä»¶ã€‚åº“æ–‡ä»¶å¦‚å›¾æ‰€ç¤ºï¼Œå½“å‰ä½¿ç”¨çš„å›ºä»¶åº“ç‰ˆæœ¬ä¸ºV1.11.0ã€‚ å»ºç«‹å·¥ç¨‹æ–‡ä»¶å¤¹&emsp;é€‰æ‹©åˆ›å»ºå·¥ç¨‹çš„ç›®å½•ï¼Œåœ¨è¯¥ç›®å½•ä¸‹æ–°å»ºdemoæ–‡ä»¶å¤¹å­˜å‚¨å·¥ç¨‹ã€‚åœ¨demoæ–‡ä»¶å¤¹ä¸‹ï¼Œå»ºç«‹Driversã€Incã€MDK-ARMã€Srcå››ä¸ªå­æ–‡ä»¶å¤¹ï¼ŒåŒæ—¶ä¾ç…§å¦‚ä¸‹æ–¹æ³•åœ¨å­æ–‡ä»¶å¤¹ä¸­å¢åŠ ç›¸åº”æ–‡ä»¶ã€‚ å¢åŠ Driversæ–‡ä»¶å¤¹åŠç›¸å…³æ–‡ä»¶&emsp;åœ¨demoæ–‡ä»¶å¤¹ä¸‹æ–°å»ºDriversæ–‡ä»¶å¤¹ï¼Œå¹¶æŒ‰ç…§å¦‚ä¸‹æ–¹å¼å¢åŠ ç›¸åº”æ–‡ä»¶ã€‚ Drivers\\CMSIS\\Include&emsp;å»ºç«‹Drivers\\CMSIS\\Includeæ–‡ä»¶å¤¹ï¼Œå°†STM32CubeF7å›ºä»¶åº“ä¸­Drivers\\CMSIS\\Includeä¸‹å¦‚ä¸‹å¤´æ–‡ä»¶å¤åˆ¶åˆ°æ–‡ä»¶å¤¹ä¸­ã€‚ cmsis_armcc.h core_cm7.h core_cmFunc.h core_cmInstr.h core_cmSimd.h &emsp;ä»¥ä¸Šæ–‡ä»¶å‡ä¸ºCMSIS Cortexå†…æ ¸æ”¯æŒç›¸å…³å¤´æ–‡ä»¶ã€‚CMSIS(Cortex Microcontroller Software Interface Standard)å³ä¸ºARM Cortexå¾®å¤„ç†å™¨è½¯ä»¶æ¥å£æ ‡å‡†ï¼Œå…¶ç»“æ„å¦‚å›¾æ‰€ç¤ºã€‚ Drivers\\CMSIS\\STM32F7xx\\Include&emsp;å»ºç«‹Drivers\\CMSIS\\STM32F7xx\\Includeæ–‡ä»¶å¤¹ï¼Œå°†STM32CubeF7å›ºä»¶åº“ä¸­Drivers\\CMSIS\\Device\\ST\\STM32F7xx\\Includeä¸­å¦‚ä¸‹å¤´æ–‡ä»¶å¤åˆ¶åˆ°æ–‡ä»¶å¤¹ä¸­ã€‚ æ–‡ä»¶ è¯´æ˜ stm32f7xx.h å¤–è®¾è®¿é—®å±‚å¤´æ–‡ä»¶ï¼Œç¡®ç«‹stm32f767xx.hè¢«includeã€‚ stm32f767xx.h å¤–è®¾è®¿é—®å±‚å¤´æ–‡ä»¶ï¼Œè¿›è¡Œå¯„å­˜å™¨æ“ä½œç»“æ„ä½“ä»¥åŠæ©ç ç­‰ç›¸å…³å®šä¹‰ã€‚ system_stm32f7xx.h ç³»ç»Ÿç›¸å…³å¤´æ–‡ä»¶ï¼Œè¿›è¡Œç³»ç»Ÿã€æ—¶é’Ÿç­‰åˆå§‹åŒ–ã€‚ Drivers\\CMSIS\\STM32F7xx\\Source&emsp;å»ºç«‹Drivers\\CMSIS\\STM32F7xx\\Sourceæ–‡ä»¶å¤¹ï¼Œå°†STM32CubeF7å›ºä»¶åº“ä¸­Drivers\\CMSIS\\Device\\ST\\STM32F7xx\\Source\\Templatesä¸­å¦‚ä¸‹å¤´æ–‡ä»¶å¤åˆ¶åˆ°æ–‡ä»¶å¤¹ä¸­ã€‚ æ–‡ä»¶ è¯´æ˜ system_stm32f7xx.c ä¸system_stm32f7xx.hå¯¹åº”ï¼Œè¿›è¡Œç³»ç»Ÿã€æ—¶é’Ÿç­‰åˆå§‹åŒ–ã€‚ Drivers\\STM32F7xx_HAL_Driver\\Inc&emsp;å»ºç«‹Drivers\\STM32F7xx_HAL_Driver\\Incæ–‡ä»¶å¤¹ï¼Œå°†STM32CubeF7å›ºä»¶åº“ä¸­Drivers\\STM32F7xx_HAL_Driver\\Incä¸­å¦‚ä¸‹å¤´æ–‡ä»¶å¤åˆ¶åˆ°æ–‡ä»¶å¤¹ä¸­ã€‚ æ–‡ä»¶ è¯´æ˜ stm32f7xx_hal.h HALé€šç”¨å¤–è®¾å¤´æ–‡ä»¶ stm32f7xx_hal_cortex.h Cortexå†…æ ¸é€šç”¨å¤–è®¾å¤´æ–‡ä»¶ stm32f7xx_hal_def.h HALé€šç”¨defineç­‰å¤´æ–‡ä»¶ stm32f7xx_hal_flash.h/stm32f7xx_hal_flash_ex.h HAL Flashä»¥åŠæ‹“å±•å¤´æ–‡ä»¶ stm32f7xx_hal_gpio.h/stm32f7xx_hal_gpio_ex.h HAL GPIOä»¥åŠæ‹“å±•å¤´æ–‡ä»¶ stm32f7xx_hal_pwr.h/stm32f7xx_hal_pwr_ex.h HAL PWRä»¥åŠæ‹“å±•å¤´æ–‡ä»¶ stm32f7xx_hal_rcc.h/stm32f7xx_hal_rcc_ex.h HAL RCCä»¥åŠæ‹“å±•å¤´æ–‡ä»¶ Drivers\\STM32F7xx_HAL_Driver\\Inc\\Legacy&emsp;å»ºç«‹Drivers\\STM32F7xx_HAL_Driver\\Inc\\Legacyæ–‡ä»¶å¤¹ï¼Œå°†STM32CubeF7å›ºä»¶åº“ä¸­Drivers\\STM32F7xx_HAL_Driver\\Inc\\Legacyä¸­stm32_hal_legacy.hå¤åˆ¶åˆ°æ–‡ä»¶å¤¹ä¸­ï¼Œè¯¥æ–‡ä»¶ä¸ºhalåº“çš„é—ç•™å¤´æ–‡ä»¶ã€‚ Drivers\\STM32F7xx_HAL_Driver\\Src&emsp;å»ºç«‹Drivers\\STM32F7xx_HAL_Driver\\Srcæ–‡ä»¶å¤¹ï¼Œå°†STM32CubeF7å›ºä»¶åº“ä¸­Drivers\\STM32F7xx_HAL_Driver\\Srcä¸­å¦‚ä¸‹æºæ–‡ä»¶å¤åˆ¶åˆ°æ–‡ä»¶å¤¹ä¸­ã€‚æºæ–‡ä»¶ä¸Drivers\\STM32F7xx_HAL_Driver\\Incä¸­å¤´æ–‡ä»¶å¯¹åº”ï¼Œè¿™é‡Œä¸å†è¯´æ˜ã€‚ å¢åŠ Incæ–‡ä»¶å¤¹åŠç›¸å…³æ–‡ä»¶&emsp;åœ¨demoæ–‡ä»¶å¤¹ä¸‹æ–°å»ºIncæ–‡ä»¶å¤¹ï¼Œå°†STM32CubeF7å›ºä»¶åº“ä¸­Projects\\STM32F767ZI-Nucleo\\Templates\\Incä¸­å¦‚ä¸‹å¤´æ–‡ä»¶å¤åˆ¶åˆ°æ–‡ä»¶å¤¹ä¸­ã€‚ æ–‡ä»¶ è¯´æ˜ stm32f7xx_hal_conf.h HALé…ç½®æ–‡ä»¶å¤´æ–‡ä»¶ stm32f7xx_it.h HALä¸­æ–­å¤´æ–‡ä»¶ &emsp;æ³¨æ„ï¼Œåœ¨stm32f7xx_hal_conf.hä¸­ï¼Œä»ç¬¬51è¡Œå¼€å§‹å®šä¹‰ä½¿èƒ½çš„å¤–è®¾ï¼Œæœ¬ç¨‹åºçš„ç›®çš„åœ¨äºè®¾ç½®ä¸€ä¸ªæœ€ç²¾ç®€å·¥ç¨‹ï¼Œå› æ­¤åªä½¿èƒ½å¿…éœ€çš„å¤–è®¾ï¼Œå³HAL_MODULE_ENABLEDã€HAL_GPIO_MODULE_ENABLEDã€HAL_RCC_MODULE_ENABLEDã€HAL_FLASH_MODULE_ENABLEDã€HAL_PWR_MODULE_ENABLEDã€HAL_CORTEX_MODULE_ENABLEDä½¿èƒ½ï¼Œå…¶ä½™å‡æ³¨é‡Šæ‰ã€‚è¿™é‡Œä¸åŒ…å«çš„å¤´æ–‡ä»¶æºæ–‡ä»¶å‡æ˜¯å¯¹åº”çš„ã€‚ &emsp;åœ¨Incæ–‡ä»¶å¤¹ä¸‹æ–°å»ºmain.hå¤´æ–‡ä»¶ï¼Œå¹¶åŠ å…¥ä»£ç å¦‚ä¸‹ã€‚ 123456#ifndef __MAIN_H#define __MAIN_H#include \"stm32f7xx_hal.h\"#endif /* __MAIN_H */ &emsp;è¯¥å¤´æ–‡ä»¶å°†è¢«includeåˆ°mainå‡½æ•°ä¸­ã€‚ å¢åŠ MDK-ARMæ–‡ä»¶å¤¹åŠç›¸å…³æ–‡ä»¶&emsp;åœ¨demoæ–‡ä»¶å¤¹ä¸‹æ–°å»ºMDK-ARMæ–‡ä»¶å¤¹ï¼Œå°†STM32CubeF7å›ºä»¶åº“ä¸­Drivers\\CMSIS\\Device\\ST\\STM32F7xx\\Source\\Templates\\armä¸­startup_stm32f767xx.så¤´æ–‡ä»¶å¤åˆ¶åˆ°æ–‡ä»¶å¤¹ä¸­ã€‚è¯¥æ–‡ä»¶ä¸ºå¤„ç†å™¨çš„å¯åŠ¨æ–‡ä»¶ã€‚ å¢åŠ Srcæ–‡ä»¶å¤¹åŠç›¸å…³æ–‡ä»¶&emsp;åœ¨demoæ–‡ä»¶å¤¹ä¸‹æ–°å»ºSrcæ–‡ä»¶å¤¹ï¼Œå°†STM32CubeF7å›ºä»¶åº“ä¸­Projects\\STM32F767ZI-Nucleo\\Templates\\Srcä¸­å¦‚ä¸‹å¤´æ–‡ä»¶å¤åˆ¶åˆ°æ–‡ä»¶å¤¹ä¸­ã€‚ æ–‡ä»¶ è¯´æ˜ stm32f7xx_hal_msp.c MCU support packageæºæ–‡ä»¶ stm32f7xx_it.c HALä¸­æ–­æºæ–‡ä»¶ &emsp;åœ¨Incæ–‡ä»¶å¤¹ä¸‹æ–°å»ºmain.cæºæ–‡ä»¶ï¼Œå¹¶åŠ å…¥ä»£ç å¦‚ä¸‹ã€‚ 1234567891011121314#include \"main.h\"uint32_t mainloop = 0;int main(void)&#123; HAL_Init(); while (1) &#123; mainloop++; &#125;&#125; &emsp;è‡³æ­¤ï¼Œæ–‡ä»¶å‡†å¤‡å®Œæ¯•ã€‚ å»ºç«‹å·¥ç¨‹ æ‰“å¼€keilæ–°å»ºå·¥ç¨‹ï¼ŒèŠ¯ç‰‡é€‰æ‹©STM32767IGTxï¼Œå°†å·¥ç¨‹æ–‡ä»¶å‘½åä¸ºdemoå¹¶ä¿å­˜åœ¨MDK-ARMç›®å½•ä¸‹ã€‚ é€‰ä¸­demoå·¥ç¨‹ï¼Œå³é”®æ‰“å¼€Manage Project Itemsï¼Œå°†Targetsä¿®æ”¹ä¸ºdemoï¼ŒæŒ‰ç…§ä¸‹å›¾ä¾æ¬¡å¢åŠ Groupsä¸å…¶ä¸­çš„Filesã€‚ æ‰“å¼€Options for Target â€˜demoâ€™-&gt;C/C++ï¼ŒDefineä¸­åŠ å…¥åŠ å…¥USE_HAL_DRIVER,STM32F767xxå®šä¹‰ï¼Œè¯¥å®šä¹‰å°†å¼•å¯¼ç›¸å…³å¤´æ–‡ä»¶ç¡®å®šè¯¥å‹å·èŠ¯ç‰‡çš„ç›¸å…³è®¾ç½®ã€‚ æ‰“å¼€Options for Target â€˜demoâ€™-&gt;C/C++ï¼Œé€‰æ‹©ä¸‹æ–¹Include Pathsï¼ŒåŠ å…¥å¦‚ä¸‹åŒ…å«è·¯å¾„ã€‚è¿™æ ·Keilå¯ä»¥æœç´¢åˆ°æ‰€éœ€è¦çš„å¤´æ–‡ä»¶ã€‚ æ‰“å¼€Options for Target â€˜demoâ€™-&gt;Debugï¼Œè®¾ç½®ä»¿çœŸå™¨ä¸ºST-Linkã€‚ æ‰“å¼€Options for Target â€˜demoâ€™-&gt;Utilitiesï¼Œè®¾ç½®Flashç®—æ³•å¹¶å‹¾é€‰Reset and Runï¼Œè¿™æ ·ç¨‹åºä¸‹è½½å®Œæ¯•åå°†è‡ªåŠ¨å¤ä½è¿è¡Œã€‚ ç¼–è¯‘è¿è¡Œç¨‹åº&emsp;ç¼–è¯‘ç¨‹åºï¼Œé‡‡ç”¨debugæ–¹å¼è¿›è¡Œçƒ§å½•ï¼ŒåŒæ—¶è§‚å¯Ÿmainloopå˜é‡ï¼Œå¯ä»¥çœ‹åˆ°è¯¥å˜é‡éšç€æ‰§è¡Œå¾ªç¯è€Œä¸æ–­å¢åŠ ã€‚ &emsp;è‡³æ­¤ï¼Œå·¥ç¨‹å»ºç«‹ä¸æµ‹è¯•å®Œæˆã€‚ ç¨‹åºç»“æ„çš„ä¼˜åŒ–&emsp;ç¨‹åºå®ŒæˆåŸºæœ¬åŠŸèƒ½ä¹‹åï¼Œå¯ä»¥è¿›è¡Œè¿›ä¸€æ­¥çš„ç¨‹åºç»“æ„ä¼˜åŒ–ï¼Œå…·ä½“å¦‚ä¸‹ã€‚ è®¾ç«‹mytype.hæ•°æ®ç±»å‹å¤´æ–‡ä»¶&emsp;å¯¹äºä¸åŒçš„å¤„ç†å™¨ä¸ç¼–è¯‘å™¨ï¼Œæ•°æ®ç±»å‹çš„å‘½åæ–¹å¼æœ‰æ‰€ä¸åŒï¼Œä¸ºäº†ä¾¿äºç¨‹åºçš„ç¼–å†™ä¸ç§»æ¤ï¼Œå¯ä»¥ç”¨typedefå¯¹æ•°æ®ç±»å‹è¿›è¡Œé‡æ–°å®šä¹‰ã€‚æ‰“å¼€Keil_v5\\ARM\\ARMCC\\includeè·¯å¾„ä¸‹stdint.hæ–‡ä»¶ï¼Œä»¥æ­¤ä¸ºå‚è€ƒè®¾ç½®è‡ªå·±çš„æ•°æ®ç±»å‹å¯¹ç…§ã€‚å»ºç«‹mytype.hå¹¶æ”¾åœ¨demoæ–‡ä»¶å¤¹ä¸‹Incæ–‡ä»¶å¤¹ï¼Œè¯¥æ–‡ä»¶å…·ä½“å†…å®¹å¦‚ä¸‹ã€‚è¯¥æ–‡ä»¶åº”å½“è¢«æ‰€æœ‰ç”¨æˆ·æºæ–‡ä»¶ä½¿ç”¨ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738/* * mytype.h * * Created on: 2018-3-19 * Author: Di */#ifndef MYTYPE_H_#define MYTYPE_H_#include \"stdint.h\"typedef int8_t int8;typedef int16_t int16;typedef int32_t int32;typedef int64_t int64;typedef uint8_t uint8;typedef uint16_t uint16;typedef uint32_t uint32;typedef uint64_t uint64;typedef volatile int8 vint8;typedef volatile uint8 vuint8;typedef volatile int16 vint16;typedef volatile uint16 vuint16;typedef volatile int32 vint32;typedef volatile uint32 vuint32;typedef volatile int64 vint64;typedef volatile uint64 vuint64;typedef float float32;typedef double float64;#endif /* MYTYPE_H_ */ è®¾ç«‹commom.hé€šç”¨å¤´æ–‡ä»¶&emsp;å¯¹äºä¸åŒçš„å¤„ç†å™¨ï¼Œæ‰€æœ‰çš„ç¡¬ä»¶å¤–è®¾éƒ½éœ€è¦è°ƒç”¨åº“å‡½æ•°çš„é€šç”¨å¤–è®¾å¤´æ–‡ä»¶ï¼Œä»¥åŠè®¾ç«‹çš„mytype.hæ•°æ®ç±»å‹å¤´æ–‡ä»¶ã€‚å¯ä»¥å»ºç«‹ä¸€ä¸ªcommom.hé€šç”¨å¤´æ–‡ä»¶ï¼Œåˆ›ç«‹æ–°çš„ç”¨æˆ·æ–‡ä»¶ç›´æ¥å°†å…¶includeå³å¯ã€‚å»ºç«‹commom.hå¹¶æ”¾åœ¨demoæ–‡ä»¶å¤¹ä¸‹Incæ–‡ä»¶å¤¹ï¼Œè¯¥æ–‡ä»¶å…·ä½“å†…å®¹å¦‚ä¸‹ã€‚ 12345678910111213141516171819202122/* * common.h * * Created on: 2018-3-19 * Author: Di */#ifndef COMMON_H_#define COMMON_H_#define TRUE 1#define FALSE 0#define HIGH 1#define LOW 0#include \"stm32f7xx_hal.h\"#include \"mytype.h\"#endif /* COMMON_H_ */ è®¾ç«‹includes.hæ€»åŒ…å«å¤´æ–‡ä»¶&emsp;mainå‡½æ•°ä¸­ï¼Œéœ€è¦åŒ…å«æ‰€æœ‰çš„æ§åˆ¶æ–‡ä»¶ï¼Œå¯ä»¥å•ç‹¬å»ºç«‹ä¸€ä¸ªincludes.hæ€»åŒ…å«å¤´æ–‡ä»¶ï¼Œå°†éœ€è¦åŒ…å«çš„å¤´æ–‡ä»¶ç»Ÿä¸€ç®¡ç†å³å¯ã€‚å»ºç«‹includes.hå¹¶æ”¾åœ¨demoæ–‡ä»¶å¤¹ä¸‹Incæ–‡ä»¶å¤¹ï¼Œè¯¥æ–‡ä»¶å…·ä½“å†…å®¹å¦‚ä¸‹ã€‚ 12345678910111213/* * includes.h * * Created on: 2018-3-19 * Author: Di */ #ifndef INCLUDES_H_#define INCLUDES_H_#include \"common.h\"#endif /* INCLUDES_H_ */ main.cä¿®æ”¹&emsp;æœ‰äº†includes.hæ€»åŒ…å«å¤´æ–‡ä»¶ï¼Œå¯ä»¥å°†main.cå‡½æ•°çš„includeä¸­ä»…ä»…è®¾ç½®ä¸ºincludes.hä¸€é¡¹ã€‚ ä¸€ä¸ªç¤ºä¾‹å·¥ç¨‹&emsp;å·¥ç¨‹æ¨¡æ¿å»ºç«‹åï¼Œä¸¾ä¾‹å±•ç¤ºå¦‚ä½•ä½¿ç”¨æ¨¡æ¿ã€‚è¿™é‡Œæ·»åŠ GPIOæ§åˆ¶ç›¸å…³æ–‡ä»¶ã€‚ å¢åŠ gpio.hæ–‡ä»¶&emsp;å»ºç«‹gpio.hå¹¶æ”¾åœ¨demoæ–‡ä»¶å¤¹ä¸‹Incæ–‡ä»¶å¤¹ï¼Œè¯¥æ–‡ä»¶å…·ä½“å†…å®¹å¦‚ä¸‹ã€‚ 1234567891011121314151617/* * gpio.h * * Created on: 2018-3-19 * Author: Di */#ifndef GPIO_H_#define GPIO_H_#include \"common.h\"void MX_GPIO_Init(void);#endif /* GPIO_H_ */ å¢åŠ gpio.cæ–‡ä»¶&emsp;å»ºç«‹gpio.cå¹¶æ”¾åœ¨demoæ–‡ä»¶å¤¹ä¸‹Srcæ–‡ä»¶å¤¹ï¼Œè¯¥æ–‡ä»¶å…·ä½“å†…å®¹å¦‚ä¸‹ã€‚ 12345678910111213141516171819202122232425262728/* * gpio.c * * Created on: 2018å¹´3æœˆ19æ—¥ * Author: jiaod */#include \"gpio.h\"void MX_GPIO_Init(void)&#123; GPIO_InitTypeDef GPIO_InitStruct; /* GPIO Ports Clock Enable */ __HAL_RCC_GPIOB_CLK_ENABLE(); /*Configure GPIO pin Output Level */ HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0|GPIO_PIN_1, GPIO_PIN_RESET); /*Configure GPIO pins : PB0 PB1 */ GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);&#125; includes.hä¸­åŒ…å«gpio.h&emsp;åœ¨includes.hä¸­include gpio.hæ–‡ä»¶ã€‚åœ¨å·¥ç¨‹ä¸­Manage Project Itemsä¸­Application\\Userä¸‹åŠ å…¥gpio.cæ–‡ä»¶ã€‚ &emsp;æ­¤æ—¶ï¼Œmainå‡½æ•°ä¸­ä»¥åŠå¯ä»¥è°ƒç”¨gpio.h/gpio.cä¸­æœ‰å…³GPIOçš„å‡½æ•°ã€‚main.cæ–‡ä»¶ä¿®æ”¹å¦‚ä¸‹ã€‚ 1234567891011121314151617181920#include \"includes.h\"uint32_t mainloop = 0;int main(void)&#123; HAL_Init(); MX_GPIO_Init(); while (1) &#123; mainloop++; HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_0); HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1); HAL_Delay(500); &#125;&#125; &emsp;è¿™æ ·ï¼Œå°±å®Œæˆäº†ç¨‹åºç»“æ„çš„ä¼˜åŒ–ã€‚","categories":[{"name":"åµŒå…¥å¼","slug":"åµŒå…¥å¼","permalink":"http://jiaodi.tech/categories/åµŒå…¥å¼/"}],"tags":[{"name":"STM32F7","slug":"STM32F7","permalink":"http://jiaodi.tech/tags/STM32F7/"},{"name":"STM32CubeMX","slug":"STM32CubeMX","permalink":"http://jiaodi.tech/tags/STM32CubeMX/"},{"name":"Keil","slug":"Keil","permalink":"http://jiaodi.tech/tags/Keil/"}]},{"title":"ä½¿ç”¨STM32CubeMXæ–°å»ºSTM32F7å·¥ç¨‹","slug":"stm32f767-start","date":"2018-03-17T09:25:48.000Z","updated":"2018-03-17T10:52:52.116Z","comments":true,"path":"2018/03/17/stm32f767-start/","link":"","permalink":"http://jiaodi.tech/2018/03/17/stm32f767-start/","excerpt":"&emsp;æœ¬æ–‡è®°å½•STM32F7çš„å¼€å‘ç¯å¢ƒé…ç½®ä¸STM32CubeMXçš„å®‰è£…é…ç½®ã€‚","text":"&emsp;æœ¬æ–‡è®°å½•STM32F7çš„å¼€å‘ç¯å¢ƒé…ç½®ä¸STM32CubeMXçš„å®‰è£…é…ç½®ã€‚ &emsp;STM32F7ç³»åˆ—æ˜¯STå…¬å¸Cortex M7å†…æ ¸çš„é«˜æ€§èƒ½å¤„ç†å™¨ã€‚ä»æœ¬æ–‡å¼€å§‹ï¼Œå°†é€æ­¥è®°å½•å­¦ä¹ è¯¥å¤„ç†å™¨çš„å¿ƒå¾—ä½“ä¼šã€‚ ç¡¬ä»¶ç¯å¢ƒ ç”µè„‘ï¼šWindows 10 Home x64 Apollo STM32F767å¼€å‘æ¿(ST-LINK V2ä»¿çœŸå™¨) Keilçš„å®‰è£…ä¸é…ç½® Keil Version 5.24.1 Pack Installerï¼šKeil.STM32F7xx_DFP.2.9.0.pack STM32CubeMXçš„å®‰è£…ä¸é…ç½® STM32CubeMX Version 4.25.0 Packages Managerï¼šSTM32CubeF7 ç”ŸæˆLEDé—ªçƒå·¥ç¨‹æ–°å»ºå·¥ç¨‹&emsp;æ‰“å¼€STM32CubeMXï¼Œé€‰æ‹©æ‰€ç”¨çš„èŠ¯ç‰‡å‹å·ï¼Œæœ¬æ¬¡ä¸ºSTM32F767IGT6ã€‚ é…ç½®IO&emsp;åœ¨Pinouté¡µé¢ä¸­é€‰æ‹©æ‰€ç”¨çš„IOï¼Œè®¾ç½®ä¸ºGPIO Outputï¼› &emsp;åœ¨Configurationä¸­å¯¹IOè¿›ä¸€æ­¥è®¾ç½®ï¼Œä¾‹å¦‚åˆå§‹åŒ–ç”µå¹³ã€è¾“å‡ºæ¨¡å¼ã€ä¸Šæ‹‰ä¸‹æ‹‰ã€è¾“å‡ºé€Ÿåº¦ç­‰ï¼› ç”Ÿæˆä»£ç &emsp;é€‰æ‹©Project-Settingsï¼Œè¾“å…¥å·¥ç¨‹åä¸ä¿å­˜è·¯å¾„ï¼Œé€‰æ‹©å¼€å‘å·¥å…·ã€‚ &emsp;æ³¨æ„åœ¨Code Generatorä¸­å‹¾é€‰å¦‚ä¸‹é€‰é¡¹ï¼Œè¿™æ ·åˆå§‹åŒ–ä»£ç ä¼šåˆ†æˆç‹¬ç«‹çš„æºæ–‡ä»¶ä¸å¤´æ–‡ä»¶ä¿å­˜åœ¨å·¥ç¨‹ä¸­ã€‚åŒæ—¶ï¼Œç¬¬ä¸€ä¸ªé€‰é¡¹ä¸­å¯ä»¥é€‰æ‹©copy only the necessary library filesï¼Œè¿™æ ·å¯ä»¥é™ä½å·¥ç¨‹æ–‡ä»¶å¤§å°ã€‚ æ·»åŠ æ‰§è¡Œä»£ç &emsp;STM32CubeMXå·²ç»å®Œæˆäº†ç³»ç»Ÿä»¥åŠGPIOçš„åˆå§‹åŒ–ä»£ç ï¼Œåœ¨mainä¸­æ·»åŠ å¦‚ä¸‹ä»£ç å¯ä»¥æ§åˆ¶IOç¿»è½¬è¿›è€Œä½¿LEDé—ªçƒã€‚ 12345678910111213while (1)&#123;/* USER CODE END WHILE *//* USER CODE BEGIN 3 */HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_0);HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1);HAL_Delay(500);loop++;&#125;/* USER CODE END 3 */ çƒ§å½•ç¨‹åº&emsp;ç¼–è¯‘å¹¶çƒ§å½•ç¨‹åºï¼Œå¯ä»¥è§‚å¯Ÿåˆ°IOå¯¹åº”çš„LEDé—ªçƒã€‚","categories":[{"name":"åµŒå…¥å¼","slug":"åµŒå…¥å¼","permalink":"http://jiaodi.tech/categories/åµŒå…¥å¼/"}],"tags":[{"name":"STM32F7","slug":"STM32F7","permalink":"http://jiaodi.tech/tags/STM32F7/"},{"name":"STM32CubeMX","slug":"STM32CubeMX","permalink":"http://jiaodi.tech/tags/STM32CubeMX/"},{"name":"Keil","slug":"Keil","permalink":"http://jiaodi.tech/tags/Keil/"}]},{"title":"ç”µæºåº”ç”¨ä¸­MLCCå•¸å«é—®é¢˜çš„åˆ†æä¸è§£å†³","slug":"mlcc-noise","date":"2018-03-12T13:56:56.000Z","updated":"2018-03-14T15:52:32.155Z","comments":true,"path":"2018/03/12/mlcc-noise/","link":"","permalink":"http://jiaodi.tech/2018/03/12/mlcc-noise/","excerpt":"&emsp;æœ¬æ–‡åˆ†æç”µæºåº”ç”¨ä¸­MLCCå•¸å«äº§ç”Ÿçš„æœºç†ä¸æŠ‘åˆ¶æ‰‹æ®µã€‚","text":"&emsp;æœ¬æ–‡åˆ†æç”µæºåº”ç”¨ä¸­MLCCå•¸å«äº§ç”Ÿçš„æœºç†ä¸æŠ‘åˆ¶æ‰‹æ®µã€‚ &emsp;æœ¬æ–‡æ ¹æ®ä»¥ä¸‹æ–‡ç« æ•´ç†ç»¼åˆï¼š å•¸å«å¯¹ç­–äº‹ä¾‹ (åŠ¨ç”») How to reduce acoustic noise of MLCCs in power applications Reducing MLCCsâ€™ piezoelectric effects and audible noise MLCCå•¸å«ç°è±¡ &emsp;MLCCåœ¨ç”µæºåº”ç”¨ä¸­å…·æœ‰å¹¿æ³›çš„ç”¨é€”ï¼Œå…¶ä¼˜ç‚¹ä¸»è¦åœ¨äºï¼š é«˜å¯†åº¦å®¹å€¼ ä½å¯„ç”Ÿç”µé˜»(ESR) ä½å¯„ç”Ÿç”µæ„Ÿ(ESL) é«˜é¢‘é˜»æŠ—ä½ æ— ææ€§ï¼Œæ˜“äºå®‰è£…åˆ¶é€  ç›¸æ¯”äºé’½ç”µå®¹ä¸é“ç”µè§£ç”µå®¹å¯é æ€§æ›´é«˜ ä½æˆæœ¬ &emsp;é€šå¸¸æƒ…å†µä¸‹ï¼ŒMLCCå¹¶ä¸ä¼šäº§ç”Ÿå™ªå£°ã€‚ä½†åœ¨æŸäº›ç‰¹æ®Šåœºåˆä¸‹ï¼ŒMLCCä¼šå¼•å‘å•¸å«ç°è±¡ã€‚MLCCçš„å½¢æ€å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š &emsp;ç”±äºé™¶ç“·ææ–™çš„å‹ç”µæ•ˆåº”(piezoelectric effect)ï¼Œå½“å¤–åŠ äº¤æµç”µå‹æ—¶å…¶å°†è¿›è¡Œæ”¶ç¼©ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºã€‚ &emsp;å½“ç”µå®¹å™¨æ”¶ç¼©æ—¶ï¼Œå°†ç‰µå¼•PCBéœ‡åŠ¨ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºã€‚æ³¨æ„å›¾ä¸­â€œç”µè§£çš„æ–½åŠ æ–¹å‘â€æ ‡æ³¨é”™è¯¯ï¼Œåº”ä¸ºâ€œç”µåœºçš„æ–½åŠ æ–¹å‘â€ã€‚èŠ¯ç‰‡ä»¥åŠç”µè·¯æ¿çš„æŒ¯å¹…ä»…ä¸º1pm~1nmã€‚å½“ç”µè·¯æ¿çš„æŒ¯åŠ¨å‘¨æœŸåœ¨äººè€³å¯ä»¥å¬åˆ°çš„é¢‘ç‡å¸¦(20~20kHz)æ˜¯ï¼Œåˆ™å£°éŸ³å¯ä»¥è¢«äººè€³è¯†åˆ«ã€‚ å½±å“å•¸å«çš„å› ç´ &emsp;å½±å“å•¸å«çš„å› ç´ ä¸»è¦æœ‰ä»¥ä¸‹å‡ ç‚¹ï¼Œå•¸å«ç¨‹åº¦å¯ä»¥ç”¨å£°å‹çº§(SPL:Sound Pressure Level)è¡¡é‡ï¼š äº¤æµç”µå‹çš„é¢‘ç‡æ˜¯å¦åœ¨å¯é—»é¢‘ç‡å¸¦(20~20kHz) äº¤æµç”µå‹çš„å¹…å€¼ï¼šå¹…å€¼å¢å¤§åˆ™SPLå¢åŠ  ç›´æµåç½®ç”µå‹ï¼šç›´æµåç½®ç”µå‹è¶Šå¤§ï¼Œåˆ™SPLå¢åŠ  ç”µå®¹çš„ä»‹ç”µå¸¸æ•°ï¼šä»‹ç”µå¸¸æ•°è¶Šå¤§åˆ™å‹ç”µæ•ˆåº”è¶Šå¼º ç”µå®¹çš„å±‚æ•°ï¼šç”µå®¹çš„å±‚æ•°è¶Šå°‘ï¼Œäº§ç”Ÿçš„å½¢å˜å°ï¼Œåˆ™SPLé™ä½ æŠ‘åˆ¶å•¸å«çš„æ‰‹æ®µé™ä½äº¤æµç”µå‹å¹…å€¼&emsp;é™ä½çº¹æ³¢å¹…å€¼å¯ä»¥é€šè¿‡å¢å¤§ç”µå®¹å€¼æ¥å®ç°ã€‚æ›´é‡è¦çš„æ˜¯ï¼Œéœ€è¦ä¾§é‡é™ä½å¯é—»é¢‘ç‡å¸¦çš„çº¹æ³¢å¹…å€¼ã€‚å¯ä»¥æµ‹é‡çº¹æ³¢å™ªå£°çš„é¢‘ç‡ï¼Œé’ˆå¯¹è¯¥é¢‘å¸¦è®¾ç½®åˆç†ç±»å‹ä¸å®¹å€¼çš„ç”µå®¹è¿›è¡Œæ»¤æ³¢ã€‚ ä½¿ç”¨è€å‹æ›´é«˜çš„ç”µå®¹&emsp;ç›´æµåç½®ç”µå‹è¶Šé«˜SPLè¶Šå¤§(æœ¬äººçŒœæƒ³è¿™ä¸ç”µå®¹çš„å®¹å€¼-ç›´æµåç½®ç”µå‹ç‰¹æ€§æœ‰å…³ï¼Œç›´æµåç½®ç”µå‹å¢åŠ ï¼Œåˆ™å®¹å€¼é™ä½ï¼Œåˆ™çº¹æ³¢å¹…å€¼å¢åŠ ï¼Œåˆ™SPLå¢åŠ )ã€‚ç›¸å¯¹åœ°ï¼Œå¦‚æœæé«˜ç”µå®¹çš„è€å‹å€¼ï¼Œåˆ™å¯ä»¥é™ä½å•¸å«æ°´å¹³ã€‚ ä¼˜åŒ–PCBå¸ƒå±€&emsp;ç”µå®¹å™¨ç‰µå¼•PCBå¼•èµ·å™ªå£°ã€‚å¢åŠ PCBæ¿çš„åšåº¦æœ‰åŠ©äºé™ä½ç‰µå¼•å½±å“ï¼Œå¯ä»¥é™ä½å™ªå£°ï¼›åŒæ—¶ï¼Œå¦‚æœå°†ç”µå®¹å™¨å¯¹ç§°æ”¾ç½®åœ¨PCBä¸¤ä¾§ï¼Œåˆ™ç†æƒ³çŠ¶æ€ä¸‹ç‰µå¼•åŠ›æŠµæ¶ˆï¼Œåˆ™PCBä¸ä¼šå‘ç”Ÿå½¢å˜ã€‚ ä½¿ç”¨ä½å™ªå£°ç”µå®¹&emsp;ç›®å‰æ‘ç”°ç­‰å·²ç»æœ‰ä½å™ªå£°äº§å“æ¨å‡ºï¼Œä¸»è¦æœ‰ä¸¤ç§é™å™ªæ€è·¯ï¼š ä½¿ç”¨ç‹¬ç‰¹çš„é™¶ç“·ææ–™æŠ‘åˆ¶ç”µå®¹å™¨çš„éœ‡åŠ¨ï¼› ä½¿ç”¨æ”¯æ¶ç­‰ç»“æ„é™ä½ç”µå®¹éœ‡åŠ¨å¼•èµ·çš„åº”åŠ›ã€‚","categories":[{"name":"Hardware","slug":"Hardware","permalink":"http://jiaodi.tech/categories/Hardware/"}],"tags":[{"name":"MLCC","slug":"MLCC","permalink":"http://jiaodi.tech/tags/MLCC/"},{"name":"Noise","slug":"Noise","permalink":"http://jiaodi.tech/tags/Noise/"},{"name":"PCB","slug":"PCB","permalink":"http://jiaodi.tech/tags/PCB/"}]},{"title":"PierceæŒ¯è¡å™¨çš„åŸç†ä¸è®¾è®¡æ–¹æ³•","slug":"pierce-oscillator","date":"2018-02-04T07:33:59.000Z","updated":"2018-02-10T11:30:15.215Z","comments":true,"path":"2018/02/04/pierce-oscillator/","link":"","permalink":"http://jiaodi.tech/2018/02/04/pierce-oscillator/","excerpt":"&emsp;æœ¬æ–‡ä»‹ç»çš®å°”æ–¯æŒ¯è¡å™¨(Pierce Oscillator)çš„åŸç†ä¸è®¾è®¡æ–¹æ³•ã€‚","text":"&emsp;æœ¬æ–‡ä»‹ç»çš®å°”æ–¯æŒ¯è¡å™¨(Pierce Oscillator)çš„åŸç†ä¸è®¾è®¡æ–¹æ³•ã€‚ &emsp;æ™¶ä½“ç”µè·¯æ˜¯ç¡¬ä»¶è®¾è®¡ä¸­ä¸€ä¸ªé‡è¦ç¯èŠ‚ï¼Œå…¶ç”µè·¯çš„ç¨³å®šå¯é ç›´æ¥å…³ç³»åˆ°äº§å“çš„ä½¿ç”¨å¯¿å‘½ã€‚çš®å°”æ–¯æŒ¯è¡å™¨(Pierce Oscillator)åœ¨ç¡¬ä»¶ç”µè·¯ä¸­åº”ç”¨å¹¿æ³›ï¼Œæœ¬æ–‡å¯¹è¯¥ç”µè·¯è¿›è¡Œå­¦ä¹ æ€»ç»“ã€‚ åŸºæœ¬åŸç†&emsp;çš®å°”æ–¯æŒ¯è¡å™¨çš„ç®€åŒ–æ¡†å›¾å¦‚ä¸‹ï¼šå¯ä»¥çœ‹ä½œä¸€ä¸ªæ”¾å¤§å™¨ä¸ä¸€ä¸ªåé¦ˆç½‘ç»œæ„æˆã€‚æ”¾å¤§å™¨çš„ç”µå‹å¢ç›Šä¸ºaï¼Œç›¸ä½å·®ä¸º$\\alpha $ï¼›åé¦ˆç½‘ç»œçš„å¢ç›Šä¸ºfï¼Œç›¸ä½å·®ä¸º$\\beta $ ã€‚ &emsp;çš®å°”æ–¯æŒ¯è¡å™¨æ˜¯ä¸€ä¸ªå…¸å‹çš„åé¦ˆç”µè·¯ï¼Œå…¶ç¯è·¯å¢ç›Šæ˜¯ï¼š $$\\left | a \\right |\\cdot \\left | f \\right |\\cdot e^{j(\\alpha +\\beta )}$$ &emsp;æŒ¯è¡å™¨çš„èµ·æŒ¯æ¡ä»¶åŒ…å«å¹…å€¼ä¸ç›¸ä½è¦æ±‚å¦‚ä¸‹ï¼š $$\\left | a \\right |\\cdot \\left | f \\right |\\geqslant 1$$ $$\\alpha +\\beta = 2\\cdot n\\cdot \\pi $$ &emsp;è¯¥æ¡ä»¶å³ä¸ºæŒ¯è¡å™¨çš„å·´å…‹è±ªæ£®ç¨³å®šæ€§å‡†åˆ™(Barkhausen stability criterion)ã€‚åœ¨æŒ¯è¡å™¨çš„ç¯è·¯ä¸­ï¼Œè¿æ”¾å¯ä»¥æä¾›é«˜å¢ç›Šä¸180Â°çš„ç›¸ä½å·®ï¼›æ­¤æ—¶åé¦ˆç½‘ç»œå°†äº§ç”Ÿé¢å¤–çš„180Â°ç›¸ä½å·®ã€‚å½“è¿æ”¾çš„ç›¸ä½å·®å­˜åœ¨è¯¯å·®æ—¶ï¼Œåé¦ˆç½‘ç»œä¹Ÿå°†è‡ªé€‚åº”åœ°è°ƒèŠ‚è‡ªèº«ç›¸ä½å·®ï¼Œä»¥ä½¿å¾—ç¯è·¯æ€»ç›¸ä½å·®ä¸º360Â°ã€‚ æ™¶ä½“ç­‰æ•ˆç”µè·¯&emsp;æ™¶ä½“ç­‰æ•ˆç”µè·¯å¦‚å›¾æ‰€ç¤ºã€‚ å…¶ä¸­$C_{0}$ä¸ºé™æ€ç”µå®¹ï¼Œä¸æ™¶ä½“å°è£…ä»¥åŠå¤–éƒ¨ç”µè·¯æœ‰å…³ï¼Œä¸€èˆ¬ä¸ºè‹¥å¹²ä¸ªpFï¼› $C_{m}$ä¸ºåŠ¨æ€ç­‰æ•ˆç”µå®¹ï¼Œä¸€èˆ¬ä¸ºè‹¥å¹²fFï¼› $L_{m}$ä¸ºåŠ¨æ€ç­‰æ•ˆç”µæ„Ÿï¼Œä¸€èˆ¬ä¸ºå‡ åmHï¼› $R_{s}$ä¸ºåŠ¨æ€ä¸²è”ç­‰æ•ˆç”µé˜»ï¼Œä¸€èˆ¬ä¸ºå‡ åÎ©ï¼› æ³¨æ„åˆ°$C_{0}$è¿œå¤§äº$C_{m}$ï¼ŒåŒæ—¶$C_{0}$ä¸æ™¶ä½“å°è£…æœ‰å…³ã€‚ ç­‰æ•ˆæ¨¡å‹é˜»æŠ—è¡¨è¾¾å¼&emsp;æ™¶ä½“ç­‰æ•ˆç”µè·¯çš„é˜»æŠ—è¡¨è¾¾å¼å¦‚ä¸‹ï¼š $$Z(s)=\\frac{1}{s\\cdot C_{0}}//(s\\cdot L_{m}+R_{s}+\\frac{1}{s\\cdot C_{1}})$$ $$Z(s)=\\frac{1}{\\frac{1}{\\frac{1}{s\\cdot C_{0}}}+\\frac{1}{s\\cdot L_{m}+R_{s}+\\frac{1}{s\\cdot C_{1}}}}$$ &emsp;æ³¨æ„åˆ°$R_{s}$çš„é˜»æŠ—è¿œä½äº$L_{m}$ä¸$C_{m}$ï¼Œå°†$R_{s}$å¿½ç•¥ä»¥ç®€åŒ–å¾—åˆ°ï¼š $$Z(s)=\\frac{1}{\\frac{1}{\\frac{1}{s\\cdot C_{0}}}+\\frac{1}{s\\cdot L_{m}+\\frac{1}{s\\cdot C_{1}}}}$$ &emsp;å³å¾—åˆ°ï¼š $$Z(s)=\\frac{s^{2}\\cdot L_{m}\\cdot C_{1}+1}{s\\cdot (s^{2}\\cdot L_{m}\\cdot C_{0}\\cdot C_{1}+C_{0}+C_{1})}$$ ä¸²è”è°æŒ¯é¢‘ç‡ä¸å¹¶è”è°æŒ¯é¢‘ç‡&emsp;ä»¤ä¸Šå¼ç­‰äº0ï¼Œå¯ä»¥å¾—åˆ°ç”µè·¯çš„ä¸²è”è°æŒ¯é¢‘ç‡$f_{ser}$: $$f_{ser}=\\frac{s_{ser}}{j\\cdot 2\\cdot \\pi }=\\frac{1}{2\\cdot \\pi\\cdot \\sqrt{L_{m}\\cdot C_{1}}}$$ &emsp;ä»¤ä¸Šå¼ç­‰äºæ— ç©·ï¼Œå¯ä»¥å¾—åˆ°ç”µè·¯åœ°ä¸²è”è°æŒ¯é¢‘ç‡$f_{par}$: $$f_{par}=\\frac{s_{par}}{j\\cdot 2\\cdot \\pi }=\\frac{1}{2\\cdot \\pi\\cdot \\sqrt{L_{m}\\cdot C_{1}}}\\cdot \\sqrt{1+\\frac{C_{1}}{C_{0}}}$$ $$f_{par}=f_{ser}\\cdot \\sqrt{1+\\frac{C_{1}}{C_{0}}}$$ &emsp;ä»ç»“æœä¸Šçœ‹ï¼Œåœ¨å¹¶è”è°æŒ¯é¢‘ç‡$f_{par}$çš„è¡¨è¾¾å¼ä¸­å¼•å…¥äº†$C_{0}$å‚æ•°ï¼Œ$C_{0}$ä¸æ™¶ä½“å°è£…è®¾è®¡æœ‰å…³ï¼Œæ— æ³•ä¿è¯è¶³å¤Ÿçš„ç²¾åº¦ï¼Œå› æ­¤ä½¿å¾—å¹¶è”è°æŒ¯é¢‘ç‡$f_{par}$çš„ç¨³å®šæ€§ä½äºä¸²è”è°æŒ¯é¢‘ç‡$f_{ser}$ ã€‚ä½†æ˜¯å½“ç­‰æ•ˆç”µè·¯å¤„äºä¸²è”è°æŒ¯çŠ¶æ€æ—¶ï¼Œå…¶é˜»æŠ—è¿‘ä¼¼ç­‰äºåŠ¨æ€ä¸²è”ç­‰æ•ˆç”µé˜»$R_{s}$ï¼Œè€ŒèŠ¯ç‰‡æ™¶ä½“è¾“å…¥ç®¡è„šä¸€èˆ¬ä¸ºCMOSç±»å‹ï¼Œå…¶å…·æœ‰é«˜è¾“å…¥é˜»æŠ—ï¼Œè¿™å°†å½¢æˆä¸¥é‡çš„ä¸åŒ¹é…ã€‚ &emsp;å½“ç­‰æ•ˆç”µè·¯å¤„äºå¹¶è”è°æŒ¯çŠ¶æ€æ—¶ï¼Œå…¶é˜»æŠ—å¾ˆé«˜ï¼Œå…·ä½“é˜»æŠ—å€¼åç»­æœ‰æ¨å¯¼ã€‚ä¸ºäº†æé«˜å¹¶è”è°æŒ¯é¢‘ç‡çš„ç¨³å®šæ€§ï¼Œå¯ä»¥é€šè¿‡å¢åŠ è´Ÿè½½ç”µå®¹$C_{L}$çš„æ–¹å¼é™ä½$C_{0}$å¯¹è°æŒ¯é¢‘ç‡çš„å½±å“ã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š &emsp;å½“å¢åŠ è´Ÿè½½ç”µå®¹$C_{L}$æ—¶ï¼Œå¹¶è”è°æŒ¯é¢‘ç‡çš„è¡¨è¾¾å¼å¦‚ä¸‹æ‰€ç¤ºï¼š $$f_{par}=\\frac{s_{par}}{j\\cdot 2\\cdot \\pi }=\\frac{1}{2\\cdot \\pi\\cdot \\sqrt{L_{m}\\cdot C_{1}}}\\cdot \\sqrt{1+\\frac{C_{1}}{C_{0}+C_{L}}}$$ &emsp;æ³¨æ„åˆ°$C_{L}$é€šå¸¸ä¸ºæ•°åpFï¼Œå…¶è¿œå¤§äº$C_{1}$ï¼Œæœ€ç»ˆæé«˜äº†$f_{par}$çš„é¢‘ç‡ç¨³å®šæ€§ï¼Œå¹¶ä½¿å¾—$f_{par}$è¶‹å‘äº$f_{ser}$ ã€‚ &emsp;å…¸å‹åº”ç”¨ä¸­ï¼Œé€šå¸¸åœ¨æ™¶ä½“ä¸¤ç«¯åˆ†åˆ«è®¾ç½®$C_{L1}$ä¸$C_{L2}$æ„æˆè´Ÿè½½ç”µå®¹$C_{L}$ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå®é™…ç”µè·¯ä¸­$C_{L}$çš„è®¡ç®—åº”å½“åŒ…å«èŠ¯ç‰‡ç®¡è„šä¸PCBèµ°çº¿çš„å¯„ç”Ÿç”µå®¹ï¼Œè¿™é‡Œå°†å¯„ç”Ÿç”µå®¹è®°ä¸º$C_{T1}$ä¸$C_{T2}$ã€‚ &emsp;$C_{L}$çš„è¡¨è¾¾å¼å¦‚ä¸‹æ‰€ç¤ºï¼š $$C_{L}=\\frac{(C_{L1}+C_{T1})\\cdot (C_{L2}+C_{T2})}{C_{L1}+C_{T1}+C_{L2}+C_{T2}}$$ è´Ÿè½½ç”µå®¹åé¦ˆæ¯”&emsp;æ³¨æ„åˆ°$C_{L1}$ä¸$C_{L2}$å†³å®šäº†åé¦ˆå›è·¯çš„åˆ†å‹æ¯”ï¼Œåé¦ˆæ¯”ä¾‹ä¸ºï¼š $$K=\\frac{C_{L2}}{C_{L1}}$$ &emsp;ä¸ºäº†ä¿è¯åé¦ˆå›è·¯çš„å¢ç›Šï¼Œåœ¨è®¾è®¡è¿‡ç¨‹ä¸­åº”å½“å°½å¯èƒ½æé«˜Kå€¼ã€‚ è´Ÿè½½ç”µå®¹æ•æ„Ÿåº¦&emsp;å½“æ™¶ä½“è´Ÿè½½ç”µå®¹å˜åŒ–æ—¶ï¼Œæ™¶ä½“çš„å¹¶è”è°æŒ¯é¢‘ç‡ä¹Ÿå°†å‘ç”Ÿå˜åŒ–ã€‚æ™¶ä½“çš„è´Ÿè½½ç”µå®¹æ•æ„Ÿåº¦(Trim Sensitivity)å®šä¹‰å¦‚ä¸‹ï¼š $$S=\\frac{\\frac{\\mathrm{d} f_{par}}{\\mathrm{d} C_{L}}}{f_{par}}$$ $$S=-\\frac{1}{2}\\cdot \\frac{C_{1}}{(1+\\frac{C_{1}}{C_{0}+C_{L}})\\cdot (C_{0}+C_{L})^{2}}$$ &emsp;è€ƒè™‘åˆ°$C_{0}$ä¸$C_{L}$è¿œå¤§äº$C_{1}$ï¼Œä¸Šå¼å¯ä»¥è¿‘ä¼¼åŒ–å¾—ï¼š $$S\\approx -\\frac{1}{2}\\cdot \\frac{C_{1}}{(C_{0}+C_{L})^{2}}$$ $$S\\approx -\\frac{1}{2}\\cdot \\frac{C_{1}}{(C_{0}+C_{L})^{2}}\\cdot 10^{6}ppm/pF$$ &emsp;å…¸å‹åº”ç”¨ä¸­ï¼ŒèŠ¯ç‰‡é€šè¿‡è°ƒèŠ‚ç®¡è„šçš„å¹¶è”ç­‰æ•ˆç”µå®¹ç”¨äºè°ƒèŠ‚æ™¶ä½“é¢‘åï¼Œä¾‹å¦‚åœ¨æ”¾å¤§å™¨è¾“å…¥ç«¯è°ƒèŠ‚å¹¶è”ç”µå®¹å®ç°æ™¶ä½“é¢‘åçš„æ ¡å‡†ï¼Œæ­¤æ—¶ç­‰æ•ˆäºè°ƒèŠ‚$C_{L1}$ã€‚æ­¤æ—¶æ™¶ä½“çš„å¹¶è”è°æŒ¯é¢‘ç‡è¡¨è¾¾å¼å¦‚ä¸‹ï¼š $$f_{par}=\\frac{1}{2\\cdot \\pi\\cdot \\sqrt{L_{m}\\cdot C_{1}}}\\cdot \\sqrt{1+\\frac{C_{1}}{C_{0}+\\frac{(C_{L1}+C_{T1})\\cdot (C_{L2}+C_{T2})}{C_{L1}+C_{T1}+C_{L2}+C_{T2}}}}$$ &emsp;æ™¶ä½“ç›¸å¯¹äº$C_{L1}$çš„è´Ÿè½½ç”µå®¹çµæ•åº¦ä¸ºï¼š $$S=\\frac{\\frac{\\mathrm{d} f_{par}}{\\mathrm{d} C_{L1}}}{f_{par}}$$ $$S=-\\frac{1}{2}\\cdot \\frac{C_{1}\\cdot \\frac{(C_{L2}+C_{T2})^{2}}{(C_{L1}+C_{T1}+C_{L2}+C_{T2})^{2}}}{(1+\\frac{C_{1}}{C_{0}+\\frac{(C_{L1}+C_{T1})\\cdot (C_{L2}+C_{T2})}{C_{L1}+C_{T1}+C_{L2}+C_{T2}}})\\cdot (C_{0}+\\frac{(C_{L1}+C_{T1})\\cdot (C_{L2}+C_{T2})}{C_{L1}+C_{T1}+C_{L2}+C_{T2}})^{2}}$$ &emsp;è€ƒè™‘åˆ°$C_{0}$ä¸$C_{L}$è¿œå¤§äº$C_{1}$ï¼Œä¸Šå¼å¯ä»¥è¿‘ä¼¼åŒ–å¾—ï¼š $$S\\approx -\\frac{1}{2}\\cdot \\frac{C_{1}\\cdot \\frac{(C_{L2}+C_{T2})^{2}}{(C_{L1}+C_{T1}+C_{L2}+C_{T2})^{2}}}{(C_{0}+\\frac{(C_{L1}+C_{T1})\\cdot (C_{L2}+C_{T2})}{C_{L1}+C_{T1}+C_{L2}+C_{T2}})^{2}}$$ $$S\\approx -\\frac{1}{2}\\cdot \\frac{C_{1}\\cdot \\frac{(C_{L2}+C_{T2})^{2}}{(C_{L1}+C_{T1}+C_{L2}+C_{T2})^{2}}}{(C_{0}+\\frac{(C_{L1}+C_{T1})\\cdot (C_{L2}+C_{T2})}{C_{L1}+C_{T1}+C_{L2}+C_{T2}})^{2}} \\cdot 10^{6}ppm/pF$$ åé¦ˆç”µé˜»&emsp;å½“æ™¶ä½“çš„è´Ÿè½½ç”µå®¹ä¸º$C_{L}$æ—¶ï¼Œæ™¶ä½“çš„å¹¶è”è°æŒ¯é˜»æŠ—ä¸ºï¼š $$R_{p}= \\frac{1-j\\cdot \\omega \\cdot R\\cdot (C_{0}+C_{L})}{R\\cdot \\omega ^{2}\\cdot (C_{0}+C_{L})^{2}}$$ $$R_{p}\\approx \\frac{1}{R\\cdot \\omega ^{2}\\cdot (C_{0}+C_{L})^{2}}$$ &emsp;å½“æ™¶ä½“çš„åé¦ˆç”µé˜»ä¸º$R_{F}$æ—¶ï¼Œç”±äºåç›¸æ”¾å¤§å™¨çš„å¼€ç¯å¢ç›Šè¿œå¤§äº1ï¼Œå…¶è¾“å…¥é˜»æŠ—ä¸ºï¼š $$Z_{i}=\\frac{R_{F}}{a+1} \\approx \\frac{R_{F}}{a} $$ &emsp;ä»¤$Z_{i}=R_{p}$ï¼Œæœ‰ $$R_{F}=a\\cdot \\frac{1}{R\\cdot \\omega ^{2}\\cdot (C_{0}+C_{L})^{2}}$$","categories":[{"name":"Hardware","slug":"Hardware","permalink":"http://jiaodi.tech/categories/Hardware/"}],"tags":[{"name":"Pierce","slug":"Pierce","permalink":"http://jiaodi.tech/tags/Pierce/"},{"name":"oscillator","slug":"oscillator","permalink":"http://jiaodi.tech/tags/oscillator/"},{"name":"crystal","slug":"crystal","permalink":"http://jiaodi.tech/tags/crystal/"}]},{"title":"F28379Dæ–°å»ºå·¥ç¨‹","slug":"F28379D-new-pro-cpu1","date":"2018-01-28T08:17:50.000Z","updated":"2018-01-28T13:34:45.693Z","comments":true,"path":"2018/01/28/F28379D-new-pro-cpu1/","link":"","permalink":"http://jiaodi.tech/2018/01/28/F28379D-new-pro-cpu1/","excerpt":"&emsp;TMS320F28379Dæ˜¯å¾·å·ä»ªå™¨å…¬å¸C2000ç³»åˆ—ä¸­åŒæ ¸ç³»åˆ—é«˜æ€§èƒ½å¾®å¤„ç†å™¨ã€‚æœ¬æ–‡ç®€è¿°å¦‚ä½•ä¸ºCPU1ä¸CPU2åˆ†åˆ«æ–°å»ºä¸€ä¸ªå·¥ç¨‹ã€‚éšç€å­¦ä¹ çš„æ·±å…¥ï¼Œæœ¬æ–‡å°†ä¸æ–­æ›´æ–°ä¼˜åŒ–ã€‚","text":"&emsp;TMS320F28379Dæ˜¯å¾·å·ä»ªå™¨å…¬å¸C2000ç³»åˆ—ä¸­åŒæ ¸ç³»åˆ—é«˜æ€§èƒ½å¾®å¤„ç†å™¨ã€‚æœ¬æ–‡ç®€è¿°å¦‚ä½•ä¸ºCPU1ä¸CPU2åˆ†åˆ«æ–°å»ºä¸€ä¸ªå·¥ç¨‹ã€‚éšç€å­¦ä¹ çš„æ·±å…¥ï¼Œæœ¬æ–‡å°†ä¸æ–­æ›´æ–°ä¼˜åŒ–ã€‚ å¼€å‘ç¯å¢ƒ&emsp;æœ¬æ–‡ä¸­å¼€å‘ç¯å¢ƒå¦‚ä¸‹ï¼š æ“ä½œç³»ç»Ÿï¼šWindows 10 Home x64 Code Composer Studio : 7.1.0.00016 controlSUITE : 3.4.7 å¼€å‘æ¿ï¼šLAUNCHXL-F28379D CPU1ç¨‹åº&emsp;æ–°å»ºå·¥ç¨‹çš„æ­¥éª¤ä¸æ–°å»ºä¸€ä¸ªC2000å·¥ç¨‹ç±»ä¼¼ï¼Œè¿™é‡Œå°†ä»‹ç»ä¸»è¦æ­¥éª¤ã€‚ æ–°å»ºä¸€ä¸ªç©ºé¡¹ç›®&emsp;å¦‚å›¾æ‰€ç¤ºï¼Œåœ¨CCSä¸­æ–°å»ºä¸€ä¸ªF28379Dç©ºé¡¹ç›®ã€‚ å¢åŠ å¤´æ–‡ä»¶&emsp;åœ¨å·¥ç¨‹ä¸­æ–°å»ºincludeæ–‡ä»¶å¤¹ï¼Œå°†controlSuiteä¸­ä¸‹åˆ—æ–‡ä»¶å¤åˆ¶åˆ°è¯¥æ–‡ä»¶å¤¹ä¸‹ï¼š controlSUITE\\device_support\\F2837xD\\v210\\F2837xD_headers\\include controlSUITE\\device_support\\F2837xD\\v210\\F2837xD_common\\include å¢åŠ æºæ–‡ä»¶&emsp;åœ¨å·¥ç¨‹ä¸­æ–°å»ºsourceæ–‡ä»¶å¤¹ï¼Œå°†controlSuiteä¸­ä¸‹åˆ—æ–‡ä»¶å¤åˆ¶åˆ°è¯¥æ–‡ä»¶å¤¹ä¸‹ï¼š controlSUITE\\device_support\\F2837xD\\v210\\F2837xD_common\\source å¢åŠ ä½åŸŸç»“æ„ä½“æ”¯æŒæºæ–‡ä»¶&emsp;å°†å¦‚ä¸‹æ–‡ä»¶å¤åˆ¶åˆ°å·¥ç¨‹æ ¹ç›®å½•ä¸‹ï¼š controlSUITE\\device_support\\F2837xD\\v210\\F2837xD_headers\\source\\F2837xD_GlobalVariableDefs.c controlSUITE\\device_support\\F2837xD\\v210\\F2837xD_headers\\cmd\\F2837xD_Headers_nonBIOS_cpu1.cmd è®¾ç½®RAM_lnkæ–‡ä»¶&emsp;åœ¨å­¦ä¹ è¿‡ç¨‹ä¸­å»ºè®®æ§åˆ¶ç¨‹åºåœ¨RAMä¸­è¿è¡Œï¼Œæœ‰åŠ©äºæé«˜çƒ§å†™é€Ÿç‡å¹¶ä¿æŠ¤å™¨ä»¶ã€‚å°†å¦‚ä¸‹æ–‡ä»¶å¤åˆ¶åˆ°å·¥ç¨‹æ ¹ç›®å½•ä¸‹ï¼ŒåŒæ—¶excludeåŸæœ‰2837x_FLASH_lnk_cpu1.cmdæ–‡ä»¶ï¼š controlSUITE\\device_support\\F2837xD\\v210\\F2837xD_common\\cmd\\2837xD_RAM_lnk_cpu1.cmd è®¾ç½®åŒ…å«é€‰é¡¹&emsp;å°†includeæ–‡ä»¶å¤¹æ·»åŠ åˆ°åŒ…å«è·¯å¾„ã€‚ è®¾ç½®Predefined Symbols&emsp;TIçš„åº“æ–‡ä»¶ä¸­ä½¿ç”¨å®å®šä¹‰å½¢å¼è®¾ç½®ä¸€äº›åˆå§‹åŒ–å‚æ•°ä»¥åŠCPUæŒ‡å®šï¼Œéœ€è¦å¢åŠ å¦‚ä¸‹é¢„å®šä¹‰ï¼š ä½¿ç”¨æ–°å·¥ç¨‹è¿›è¡ŒLEDé—ªçƒå®éªŒ&emsp;æ–°å»ºé¡¹ç›®ä¸­mainä¸ºç©ºå‡½æ•°ã€‚ä¸ºäº†æ£€éªŒåˆ›å»ºçš„å·¥ç¨‹æ˜¯å¦å¯ä»¥æ­£å¸¸ä½¿ç”¨ï¼Œè¿™é‡Œè¿›è¡Œç®€å•çš„æµ‹è¯•ã€‚&emsp;åœ¨è¿™é‡Œï¼Œå°†main.cæ–‡ä»¶å†…å®¹æ›¿æ¢ä¸ºå¦‚ä¸‹å†…å®¹ã€‚ 12345678910111213141516171819202122232425262728293031323334353637#include \"F28x_Project.h\"int main_loop = 0;void main(void)&#123; InitSysCtrl(); DINT; InitPieCtrl(); IER = 0x0000; IFR = 0x0000; InitPieVectTable(); EALLOW; GpioCtrlRegs.GPBGMUX1.bit.GPIO34 = 0; GpioCtrlRegs.GPBMUX1.bit.GPIO34 = 0; GpioCtrlRegs.GPBDIR.bit.GPIO34 = 1; GpioCtrlRegs.GPBCSEL1.bit.GPIO34 = 0; //CPU1 selected GpioCtrlRegs.GPAGMUX2.bit.GPIO31 = 0; GpioCtrlRegs.GPAMUX2.bit.GPIO31 = 0; GpioCtrlRegs.GPADIR.bit.GPIO31 = 1; GpioCtrlRegs.GPACSEL4.bit.GPIO31 = 2; //CPU2 selected EDIS; EINT; ERTM; for(;;) &#123; GpioDataRegs.GPBTOGGLE.bit.GPIO34 = 1; DELAY_US(500000); main_loop++; &#125;&#125; &emsp;ç¼–è¯‘ç¨‹åºï¼Œé€‰æ‹©CPU1è¿›è¡Œçƒ§å†™ï¼Œè¿è¡Œç¨‹åºã€‚å¯ä»¥çœ‹åˆ°æ¿å­ä¸ŠGPIO34æ§åˆ¶çš„RED LEDå¼€å§‹é—ªçƒï¼Œé—ªçƒé¢‘ç‡çº¦ä¸º1Hzã€‚ CPU2ç¨‹åº&emsp;å°†CPU1çš„ç¨‹åºå¤åˆ¶ï¼Œåœ¨æ­¤åŸºç¡€ä¸Šæ”¹ä¸ºCPU2ç¨‹åºã€‚ æ›´æ–°RAM_lnkæ–‡ä»¶&emsp;åˆ é™¤åŸæœ‰2837xD_RAM_lnk_cpu1.cmdæ–‡ä»¶ï¼Œæ›´æ¢ä¸ºï¼š controlSUITE\\device_support\\F2837xD\\v210\\F2837xD_common\\cmd\\2837xD_RAM_lnk_cpu2.cmd æ›´æ–°F2837xD_Headers_nonBIOS_cpu2æ–‡ä»¶&emsp;åˆ é™¤F2837xD_Headers_nonBIOS_cpu1.cmdï¼Œå°†å¦‚ä¸‹æ–‡ä»¶å¤åˆ¶åˆ°å·¥ç¨‹æ ¹ç›®å½•ä¸‹ï¼š controlSUITE\\device_support\\F2837xD\\v210\\F2837xD_headers\\cmd\\F2837xD_Headers_nonBIOS_cpu2.cmd æ›´æ–°Predefined Symbols&emsp;å°†Predefined Symbolsä¸­CPU1æ”¹ä¸ºCPU2ã€‚ åˆ é™¤éƒ¨åˆ†ä¸æ”¯æŒæºæ–‡ä»¶&emsp;æ­¤æ—¶ç¼–è¯‘ç¨‹åºï¼Œä¼šå‘ç°sourceä¸­éƒ¨åˆ†æºæ–‡ä»¶æŠ¥é”™ã€‚è¿™æ˜¯å› ä¸ºéƒ¨åˆ†å¤–è®¾ä»…æ”¯æŒCPU1æ§åˆ¶ã€‚éœ€è¦åˆ é™¤çš„æºæ–‡ä»¶åŒ…æ‹¬ï¼š F2837xD_ECap.c F2837xD_EPwm.c F2837xD_EQep.c F2837xD_Spi.c F2837xD_TempSensorConv.c F2837xD_Upp.c ä½¿ç”¨æ–°å·¥ç¨‹è¿›è¡ŒLEDé—ªçƒå®éªŒ&emsp;åœ¨è¿™é‡Œï¼Œå°†main.cæ–‡ä»¶å†…å®¹æ›¿æ¢ä¸ºå¦‚ä¸‹å†…å®¹ã€‚ 12345678910111213141516171819202122232425#include \"F28x_Project.h\"int main_loop = 0;void main(void)&#123; InitSysCtrl(); DINT; InitPieCtrl(); IER = 0x0000; IFR = 0x0000; InitPieVectTable(); EINT; ERTM; for(;;) &#123; GpioDataRegs.GPATOGGLE.bit.GPIO31 = 1; DELAY_US(50000); main_loop++; &#125;&#125; ç¼–è¯‘ç¨‹åºï¼Œé€‰æ‹©CPU2è¿›è¡Œçƒ§å†™ï¼Œè¿è¡Œç¨‹åºã€‚å¯ä»¥çœ‹åˆ°æ¿å­ä¸ŠGPIO31æ§åˆ¶çš„BLUE LEDå¼€å§‹é—ªçƒï¼Œé—ªçƒé¢‘ç‡çº¦ä¸º10Hzã€‚ æ³¨æ„F28379Dçƒ§å†™ç¨‹åºå¿…é¡»æŒ‰ç…§CPU1å…ˆè¿›è¡Œï¼ŒCPU2åè¿›è¡Œçš„é¡ºåºã€‚ ç‰¹åˆ«é¸£è°¢JOJOåŒå­¦åœ¨æœ¬å®éªŒä¸­çš„å¤§åŠ›å¸®åŠ©ã€‚ğŸ˜„","categories":[{"name":"åµŒå…¥å¼","slug":"åµŒå…¥å¼","permalink":"http://jiaodi.tech/categories/åµŒå…¥å¼/"}],"tags":[{"name":"C2000","slug":"C2000","permalink":"http://jiaodi.tech/tags/C2000/"},{"name":"F28379D","slug":"F28379D","permalink":"http://jiaodi.tech/tags/F28379D/"},{"name":"GPIO","slug":"GPIO","permalink":"http://jiaodi.tech/tags/GPIO/"}]},{"title":"PyInstalleråŸºæœ¬ç”¨æ³•","slug":"python-pyinstaller","date":"2018-01-23T14:51:58.000Z","updated":"2018-01-25T14:45:24.156Z","comments":true,"path":"2018/01/23/python-pyinstaller/","link":"","permalink":"http://jiaodi.tech/2018/01/23/python-pyinstaller/","excerpt":"&emsp;PyInstallerå¯ä»¥å°†Pythonç¨‹åºæ‰“åŒ…ä¸ºä¸€ä¸ªç‹¬ç«‹çš„å¯æ‰§è¡Œç¨‹åºï¼Œé€‚ç”¨äºWindowsã€Linuxä¸Mac OS Xç­‰ã€‚æœ¬æ–‡ç®€è¿°PyInstallerçš„å®‰è£…ä¸åŸºæœ¬ä½¿ç”¨æ–¹æ³•ã€‚","text":"&emsp;PyInstallerå¯ä»¥å°†Pythonç¨‹åºæ‰“åŒ…ä¸ºä¸€ä¸ªç‹¬ç«‹çš„å¯æ‰§è¡Œç¨‹åºï¼Œé€‚ç”¨äºWindowsã€Linuxä¸Mac OS Xç­‰ã€‚æœ¬æ–‡ç®€è¿°PyInstallerçš„å®‰è£…ä¸åŸºæœ¬ä½¿ç”¨æ–¹æ³•ã€‚ &emsp;Pythonç”¨äºå¼€å‘ä¸€äº›å°ç¨‹åºéå¸¸æ–¹ä¾¿ï¼Œä½†æ˜¯ä½¿ç”¨çš„è¯ä¸€èˆ¬éœ€è¦å®‰è£…å¼€å‘ç¯å¢ƒã€‚é€šè¿‡PyInstallerå¯ä»¥å°†Pythonç¨‹åºè½¬åŒ–ä¸ºä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶ï¼Œä¾‹å¦‚å¯ä»¥åœ¨Windowsä¸‹ç›´æ¥æ‰§è¡Œçš„exeæ–‡ä»¶ã€‚ å¼€å‘ç¯å¢ƒ&emsp;æœ¬æ–‡ä¸­å¼€å‘ç¯å¢ƒå¦‚ä¸‹ï¼š æ“ä½œç³»ç»Ÿï¼šWindows 10 Home x64 Pythonç‰ˆæœ¬ï¼š2.7.13 x64 PyInstallerçš„å®‰è£…å®‰è£…PyInstaller1pip install pyinstaller æ›´æ–°PyInstaller1pip install --upgrade pyinstaller å®‰è£…å½“å‰å¼€å‘è€…ç‰ˆæœ¬1pip install https://github.com/pyinstaller/pyinstaller/tarball/develop PyInstallerçš„ä½¿ç”¨&emsp;PyInstallerå‘½ä»¤çš„è¯­æ³•å¦‚ä¸‹æ‰€ç¤ºï¼š 1pyinstaller [options] script [script â€¦] | specfile &emsp;å…³äºè¯¥è¯­æ³•çš„è¯¦ç»†ä»‹ç»è§å®˜ç½‘ã€‚è¿™é‡Œåªåˆ—ä¸¾å‡ºä¸€äº›ç›¸å¯¹å¸¸ç”¨çš„ç”¨æ³•ã€‚ optioné€‰é¡¹&emsp;optionä¸­å¯ä»¥è®¾ç½®çš„å‚æ•°è¾ƒå¤šï¼Œå¸¸ç”¨çš„åˆ—ä¸¾å¦‚ä¸‹ã€‚ Parameter Function å¤‡æ³¨ -D, â€“onedir Create a one-folder bundle containing an executable (default) ç”Ÿæˆä¸€ä¸ªåŒ…å«ç¨‹åºçš„æ–‡ä»¶å¤¹ -F, â€“onefile Create a one-file bundled executable. ç”Ÿæˆä¸€ä¸ªç‹¬ç«‹ç¨‹åº p DIR, â€“paths DIR A path to search for imports (like using PYTHONPATH). Multiple paths are allowed, separated by â€˜:â€™, or use this option multiple times è®¾ç½®importæ–‡ä»¶è·¯å¾„ c, â€“console, â€“nowindowed Open a console window for standard i/o (default) ä½¿ç”¨æ§åˆ¶å°ç¨‹åº -w, â€“windowed, â€“noconsole Windows and Mac OS X: do not provide a console window for standard i/o. On Mac OS X this also triggers building an OS X .app bundle. This option is ignored in *NIX systems. ä½¿ç”¨éæ§åˆ¶å°ç¨‹åº -i , â€“icon FILE.ico: apply that icon to a Windows executable. FILE.exe,ID, extract the icon with ID from an exe. FILE.icns: apply the icon to the .app bundle on Mac OS X è®¾ç½®ç¨‹åºçš„icon -n NAME, â€“name NAME Name to assign to the bundled app and spec file (default: first scriptâ€™s basename) å‘½åç”Ÿæˆçš„ç¨‹åº &emsp;ä½¿ç”¨ä¸€ä¸ªç®€å•çš„è·å–ç³»ç»Ÿæ—¶é—´ç„¶åæ‰“å°çš„ç¨‹åºï¼Œä»£ç å¦‚ä¸‹ã€‚ 12345678#coding:UTF-8from datetime import datetimeimport timedef timer(n): while True: print(datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")) time.sleep(n)timer(1) &emsp;å¯¹PyInstallerçš„ä½¿ç”¨ä¸¾ä¾‹å¦‚ä¸‹ï¼š ç”Ÿæˆç‹¬ç«‹exeæ–‡ä»¶&emsp;é¦–å…ˆå°†åœ¨CMDå‘½ä»¤æ¡†å®šä½åˆ°ç¨‹åºæ‰€åœ¨è·¯å¾„ï¼Œè¾“å…¥å¦‚ä¸‹å‘½ä»¤å³å¯ï¼š 12cd -d D:\\pythonpyinstaller -F timer.py &emsp;ä¹‹ååœ¨è¯¥ç›®å½•ä¸‹distæ–‡ä»¶å¤¹ä¸‹å¯ä»¥çœ‹åˆ°timer.exeæ–‡ä»¶ï¼Œç‚¹å‡»æ‰§è¡Œï¼Œä¼šå‘ç°ä¸è¿è¡Œpythonç¨‹åºæ•ˆæœä¸€è‡´ã€‚ å¢åŠ ç¨‹åºicon&emsp;å‘½ä»¤ä¿®æ”¹å¦‚ä¸‹ï¼š 1pyinstaller -F -i D:\\python\\qq.ico timer.py &emsp;ä¹‹ååœ¨è¯¥ç›®å½•ä¸‹distæ–‡ä»¶å¤¹ä¸‹å¯ä»¥çœ‹åˆ°timer.exeæ–‡ä»¶ï¼Œæ­¤æ—¶ç¨‹åºä½¿ç”¨äº†iconã€‚ ç¦ç”¨æ§åˆ¶å°&emsp;å¯¹äºçª—ä½“ç¨‹åºï¼Œå¯ä»¥ç¦ç”¨æ§åˆ¶å°ã€‚ä¸¾ä¾‹ä¸€ä¸ªå°ç¨‹åºï¼šä½¿ç”¨graphicsç»˜åˆ¶ä¸€ä¸ªåœ†ï¼Œé¼ æ ‡ç‚¹å‡»åæ¶ˆå¤±ï¼ŒåŒæ—¶åœ¨ç¨‹åºè¿è¡Œä¸­è¾“å‡ºä¸€ä¸ªstartå­—ç¬¦ä¸²ã€‚ 12345678910111213from graphics import *win = GraphWin('shape')print (\"start\")center = Point(100,100)circ = Circle(center,30)circ.setFill('blue')circ.draw(win)win.getMouse()win.close() &emsp;å½“ç¨‹åºç›´æ¥é€šè¿‡pythonè¿è¡Œæ—¶ï¼Œå°†è¾“å‡ºstartå¹¶ç”»åœ†ã€‚ &emsp;ä½¿ç”¨å¦‚ä¸‹å‘½ä»¤ç”Ÿæˆexeæ–‡ä»¶ç¦ç”¨æ§åˆ¶å°ï¼Œåˆ™ç¨‹åºä»…ä»…è¿›è¡Œç”»åœ†ã€‚ 1pyinstaller -F -w -i D:\\python\\qq.ico graph_1.py &emsp;PyInstallerçš„åŸºæœ¬ä½¿ç”¨ä»‹ç»å®Œæ¯•ã€‚ğŸ˜„","categories":[{"name":"Python","slug":"Python","permalink":"http://jiaodi.tech/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://jiaodi.tech/tags/Python/"},{"name":"PyInstaller","slug":"PyInstaller","permalink":"http://jiaodi.tech/tags/PyInstaller/"}]},{"title":"ä½¿ç”¨F28069é©±åŠ¨æ¸©æ¹¿åº¦ä¼ æ„Ÿå™¨HDC1010","slug":"HDC1010-C2000","date":"2018-01-14T12:50:21.000Z","updated":"2018-02-04T14:51:25.506Z","comments":true,"path":"2018/01/14/HDC1010-C2000/","link":"","permalink":"http://jiaodi.tech/2018/01/14/HDC1010-C2000/","excerpt":"&emsp;HDC1010æ˜¯å¾·å·ä»ªå™¨å…¬å¸çš„ä¸€æ¬¾é«˜ç²¾åº¦æ•°å­—æ¸©æ¹¿åº¦ä¼ æ„Ÿå™¨ï¼Œæœ¬æ–‡å°†ä»‹ç»å¦‚ä½•ä½¿ç”¨C2000ä¸­F28069é©±åŠ¨è¯¥èŠ¯ç‰‡ã€‚å› ä¸ºç¯‡å¹…é™åˆ¶ï¼Œæœ¬æ–‡ç»™å‡ºé‡è¦ä½†éå®Œæ•´å®ç°è¿‡ç¨‹ï¼ŒåŒæ—¶æœ‰ä¸€å®šä¼˜åŒ–ç©ºé—´ã€‚","text":"&emsp;HDC1010æ˜¯å¾·å·ä»ªå™¨å…¬å¸çš„ä¸€æ¬¾é«˜ç²¾åº¦æ•°å­—æ¸©æ¹¿åº¦ä¼ æ„Ÿå™¨ï¼Œæœ¬æ–‡å°†ä»‹ç»å¦‚ä½•ä½¿ç”¨C2000ä¸­F28069é©±åŠ¨è¯¥èŠ¯ç‰‡ã€‚å› ä¸ºç¯‡å¹…é™åˆ¶ï¼Œæœ¬æ–‡ç»™å‡ºé‡è¦ä½†éå®Œæ•´å®ç°è¿‡ç¨‹ï¼ŒåŒæ—¶æœ‰ä¸€å®šä¼˜åŒ–ç©ºé—´ã€‚ ä¼ æ„Ÿå™¨ä¸»è¦ç‰¹æ€§&emsp;HDC1010æ˜¯ä¸€æ¬¾ä½åŠŸè€—ã€é«˜ç²¾åº¦çš„æ•°å­—æ¸©æ¹¿åº¦ä¼ æ„Ÿå™¨ã€‚è¯¥ä¼ æ„Ÿå™¨çš„ä¸»è¦ç‰¹æ€§å¦‚ä¸‹ï¼š ç›¸å¯¹æ¹¿åº¦ç²¾åº¦ä¸ºÂ±2%ï¼Œæ¸©åº¦ç²¾åº¦ä¸ºÂ±0.2åº¦ï¼› 14ä½æµ‹é‡åˆ†è¾¨ç‡ï¼› ç¡çœ æ¨¡å¼çš„ç”µæµä¸º100nAï¼› ç”µæºç”µå‹ä¸º2.7Vè‡³5Vï¼› I2Cæ¥å£ï¼› ç‰©ç†è¿æ¥HDC1010å¼•è„š&emsp;èŠ¯ç‰‡çš„å¼•è„šå›¾å¦‚ä¸‹ï¼š ADRè®¾ç½®ï¼šADR1ä¸ADR0ç”¨äºè®¾ç½®I2Cåœ°å€ï¼Œå½“2ä¸ªå¼•è„šéƒ½ä¸‹æ‹‰åˆ°GNDæ—¶ï¼ŒHDC1010çš„7ä½åœ°å€ä¸º1000000ï¼› SCLä¸SDAï¼šä¸ºI2Cç®¡è„šçš„æ—¶é’Ÿçº¿ä¸æ•°æ®çº¿ï¼Œä¸ºå¼€æ¼è¾“å‡ºï¼› DRDYnï¼šæ•°æ®readyæ ‡å¿—ä½ï¼Œä½ç”µå¹³æœ‰æ•ˆï¼Œä¸ºå¼€æ¼è¾“å‡ºã€‚ æ§åˆ¶å™¨ç¡¬ä»¶è¿æ¥&emsp;HDC1010çš„ç‰©ç†è¿æ¥å¦‚ä¸‹æ‰€ç¤ºï¼š &emsp;æœ¬æ¬¡ä½¿ç”¨çš„MCUä¸ºå¾·å·ä»ªå™¨å…¬å¸çš„TMS320F28069ï¼Œè¿æ¥å›¾å¦‚ä¸Šå›¾æ‰€ç¤ºã€‚HDC1010çš„SCLã€SDAä¸DRDYnéœ€è¦è¿›è¡Œä¸Šæ‹‰ã€‚å…¶ä¸­SCLä¸SDAä½¿ç”¨F28069çš„ç¡¬ä»¶I2C-Aï¼ŒDRDYnä½¿ç”¨ä¸€ä¸ªGPIOè¾“å…¥ç«¯å£å³å¯ã€‚ åˆå§‹åŒ–è½¯ä»¶æµç¨‹ä¸åº•å±‚é…ç½®&emsp;æœ¬èŠ‚å°†æŒ‰ç…§åˆå§‹åŒ–è½¯ä»¶æµç¨‹ã€ç¡¬ä»¶åº•å±‚é…ç½®çš„æµç¨‹ä»‹ç»ã€‚ åˆå§‹åŒ–è½¯ä»¶æµç¨‹&emsp;åˆå§‹åŒ–æµç¨‹ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š 12345678910111213//I2C-A initializeInitI2CGpio();I2CA_Init();//HDC DRDY PIN initializeHDC_DRDY_Pin_Init();ManufacturerID = HDC_GetData(Manufacturer_ID);DeviceID = HDC_GetData(Device_ID);HDC_GetConfig();DELAY_US(40);HDC_Config = HDC_GetData(ConfigADDR); &emsp;åˆå§‹åŒ–ä»£ç ä¸»è¦åŠŸèƒ½å¦‚ä¸‹ï¼š åˆå§‹åŒ–I2C-Aï¼šç”¨äºä¸HDC1010é€šè®¯ï¼› åˆå§‹åŒ–DRDY PINï¼šç”¨äºåˆ¤æ–­data readyï¼› è¯»å–ManufacturerIDä¸DeviceIDï¼šç”¨äºåˆ¤æ–­I2Cé€šè®¯æ˜¯å¦æˆåŠŸï¼› é…ç½®HDC1010ï¼šæŒ‰ç…§éœ€æ±‚é…ç½®HDC1010ï¼› I2C-Aåˆå§‹åŒ– GPIOåˆå§‹åŒ–ï¼šåˆå§‹åŒ–I2C GPIOï¼Œå°½ç®¡ç¡¬ä»¶ä¸Šå·²ç»è¿›è¡Œä¸Šæ‹‰æ“ä½œï¼Œæ­¤å¤„I2C IOä¾æ—§è¿›è¡Œäº†ä¸Šæ‹‰æ“ä½œï¼› 12345678910111213141516171819void InitI2CGpio()&#123; EALLOW;/* Enable internal pull-up for the selected pins */ GpioCtrlRegs.GPBPUD.bit.GPIO32 = 0; // Enable pull-up for GPIO32 (SDAA) GpioCtrlRegs.GPBPUD.bit.GPIO33 = 0; // Enable pull-up for GPIO33 (SCLA)/* Set qualification for selected pins to asynch only */ GpioCtrlRegs.GPBQSEL1.bit.GPIO32 = 3; // Asynch input GPIO32 (SDAA) GpioCtrlRegs.GPBQSEL1.bit.GPIO33 = 3; // Asynch input GPIO33 (SCLA)/* Configure I2C pins using GPIO regs*/ GpioCtrlRegs.GPBMUX1.bit.GPIO32 = 1; // Configure GPIO32 for SDAA operation GpioCtrlRegs.GPBMUX1.bit.GPIO33 = 1; // Configure GPIO33 for SCLA operation EDIS;&#125; æ—¶é’Ÿè®¾ç½®ï¼šHDC1010æ”¯æŒçš„I2Cæœ€é«˜æ—¶é’Ÿé¢‘ç‡ä¸º400kHzï¼Œæœ¬æ¬¡è®¾ç½®ç†è®ºå€¼ä¸º327kHzï¼Œå…·ä½“è®¡ç®—è¿‡ç¨‹è¯·è‡ªè¡ŒæŸ¥é˜…F28069æ‰‹å†Œç¡®å®š(ä¹Ÿè®¸æˆ‘å¼€å¿ƒäº†å°±ä¼šå†™ä¸€ç¯‡ä»‹ç»I2Cçš„å°æ–‡ğŸ˜„)ï¼› 1234567// Initialize I2CI2caRegs.I2CMDR.all = 0x0000;I2caRegs.I2CSAR = 0; // Slave addressI2caRegs.I2CPSC.all = 10; // Prescaler - need 7-12 Mhz on module clkI2caRegs.I2CCLKL = 10; // NOTE: must be non zeroI2caRegs.I2CCLKH = 5; // NOTE: must be non zero I2Cä¸­æ–­è®¾ç½®ï¼šä½¿èƒ½STOPä¸ARDYä¸­æ–­ï¼› 12345678//I2caRegs.I2CIER.all = 0x24; // Enable SCD &amp; ARDY interrupts 0010 0100I2caRegs.I2CIER.bit.AAS = 0; // Addressed as slave interrupt enable bitI2caRegs.I2CIER.bit.SCD = 1; // Stop condition detected interrupt enable bitI2caRegs.I2CIER.bit.XRDY = 0; // Transmit-data-ready interrupt enable bitI2caRegs.I2CIER.bit.XRDY = 0; // Receive-data-ready interrupt enable bitI2caRegs.I2CIER.bit.ARDY = 1; // Register-access-ready interrupt enable bitI2caRegs.I2CIER.bit.NACK = 0; // No-acknowledgment interrupt enable bitI2caRegs.I2CIER.bit.ARBL = 0; // Arbitration-lost interrupt enable bit æ¨¡å¼ä¸FIFOè®¾ç½®ï¼šä½¿èƒ½I2Cæ¨¡å—ï¼Œä½¿èƒ½FIFOåŠŸèƒ½ï¼› 123456789101112131415161718192021222324252627//I2caRegs.I2CMDR.all = 0x0020; // Take I2C out of reset,Stop I2C when suspendedI2caRegs.I2CMDR.bit.NACKMOD = 0; // NACK mode bitI2caRegs.I2CMDR.bit.FREE = 0; // Stop I2C when suspendedI2caRegs.I2CMDR.bit.STT = 0; // START condition bitI2caRegs.I2CMDR.bit.STP = 0; // STOP condition bitI2caRegs.I2CMDR.bit.MST = 0; // Slave modeI2caRegs.I2CMDR.bit.TRX = 0; // Receiver modeI2caRegs.I2CMDR.bit.XA = 0; // 7-bit addressing modeI2caRegs.I2CMDR.bit.RM = 0; // Nonrepeat modeI2caRegs.I2CMDR.bit.DLB = 0; // Digital loopback mode is disabledI2caRegs.I2CMDR.bit.IRS = 1; // The I2C module is enabledI2caRegs.I2CMDR.bit.STB = 0; // The I2C module is not in the START byte modeI2caRegs.I2CMDR.bit.FDF = 0; // Free data format mode is disabledI2caRegs.I2CMDR.bit.BC = 0; // 8 bits per data byte//I2caRegs.I2CFFTX.all = 0x6000; // Enable FIFO mode and TXFIFOI2caRegs.I2CFFTX.bit.I2CFFEN = 1; // Enable the I2C FIFO modeI2caRegs.I2CFFTX.bit.TXFFRST = 1; // Enable the transmit FIFO operationI2caRegs.I2CFFTX.bit.TXFFINTCLR = 0; // Clear the TXFFINT flagI2caRegs.I2CFFTX.bit.TXFFIENA = 0; // TXFFINT flag does not generate an interrupt when setI2caRegs.I2CFFTX.bit.TXFFIL = 0; // Transmit FIFO interrupt level//I2caRegs.I2CFFRX.all = 0x2040; // Enable RXFIFO, clear RXFFINTI2caRegs.I2CFFRX.bit.RXFFRST = 1; // Enable the receive FIFO operationI2caRegs.I2CFFRX.bit.RXFFINTCLR = 1; // Clear the RXFFINT flagI2caRegs.I2CFFRX.bit.RXFFIENA = 0; // RXFFINT flag does generate an interrupt when setI2caRegs.I2CFFRX.bit.RXFFIL = 0; // Receive FIFO interrupt level DRDYn PINåˆå§‹åŒ–&emsp;è®¾ç½®ä¸€ä¸ªGPIOè¾“å…¥ç«¯å£ã€‚ 123456789101112void HDC_DRDY_Pin_Init(void)&#123; EALLOW; GpioCtrlRegs.GPAMUX1.bit.GPIO12 = 0; GpioCtrlRegs.GPADIR.bit.GPIO12 = 0; EDIS;&#125;uint8 HDC_DRDY_Read(void)&#123; return GpioDataRegs.GPADAT.bit.GPIO12;&#125; è‡³æ­¤ï¼Œåº•å±‚åˆå§‹åŒ–å®Œæˆã€‚ ä¼ æ„Ÿå™¨ä¿¡æ¯è¯»å–è®¾å¤‡ä¿¡æ¯è¯»å–&emsp;ManufacturerIDä¸DeviceIDä¸ºä¼ æ„Ÿå™¨çš„å›ºæœ‰ä¿¡æ¯ï¼Œå¯ä»¥è¯»å–è¯¥ä¿¡æ¯ç¡®è®¤I2Cé€šè®¯æœ‰æ•ˆæ€§ã€‚ &emsp;HDC1010æ‰‹å†Œæä¾›äº†Configurationå¯„å­˜å™¨çš„è¯»å†™æ“ä½œï¼Œå¯ä»¥ç±»æ¨åˆ°ManufacturerIDä¸DeviceIDå¯„å­˜å™¨çš„è¯»å–æ–¹æ³•ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºã€‚æ³¨æ„ManufacturerIDä¸DeviceIDå¯„å­˜å™¨å‡ä¸ºåªè¯»å¯„å­˜å™¨ã€‚ I2Cè¯»å–å¯„å­˜å™¨çš„ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071uint16 HDC_GetData(char REG_Address)&#123; I2CA_ReadData(HDC1010_ADDR, REG_Address, 2, HDC_buffer); return (HDC_buffer[0]&lt;&lt;8) + HDC_buffer[1];&#125;void I2CA_ReadData(uint16 addr, uint16 reg, uint16 readCount, uint8 *buffer)&#123; uint16 i; I2caRegs.I2CMDR.bit.IRS = 1; // reset I2C // Make sure I2C is not busy and has stopped while (I2caRegs.I2CSTR.bit.BB == 1); // busy loop I2caRegs.I2CSTR.bit.SCD = 1; // Clear the SCD bit (stop condition bit) //while(I2caRegs.I2CMDR.bit.STP == 1); // stop bit loop I2caRegs.I2CSAR = addr; // I2C slave address while (I2caRegs.I2CSTR.bit.BB == 1); // still busy? I2caRegs.I2CMDR.all = 0x2620; // start, no stop bit, master, tx, reset I2C 00100110// I2caRegs.I2CMDR.bit.NACKMOD = 0; // 15:NACK mode bit// I2caRegs.I2CMDR.bit.FREE = 0; // 14:Stop I2C when suspended// I2caRegs.I2CMDR.bit.STT = 1; // 13:START condition bit// I2caRegs.I2CMDR.bit.STP = 0; // 11:STOP condition bit// I2caRegs.I2CMDR.bit.MST = 1; // 10:Master mode// I2caRegs.I2CMDR.bit.TRX = 1; // 9:Transmitter mode// I2caRegs.I2CMDR.bit.XA = 0; // 8:7-bit addressing mode// I2caRegs.I2CMDR.bit.RM = 0; // 7:Nonrepeat mode// I2caRegs.I2CMDR.bit.DLB = 0; // 6:Digital loopback mode is disabled// I2caRegs.I2CMDR.bit.IRS = 1; // 5:The I2C module is enabled// I2caRegs.I2CMDR.bit.STB = 0; // 4:The I2C module is not in the START byte mode// I2caRegs.I2CMDR.bit.FDF = 0; // 3:Free data format mode is disabled// I2caRegs.I2CMDR.bit.BC = 0; // 2-0:8 bits per data byte I2caRegs.I2CCNT = 1; // assume register address is one byte I2caRegs.I2CDXR = reg; // register address of the sensor (1 byte) while(!I2caRegs.I2CSTR.bit.ARDY); // all ready? I2caRegs.I2CMDR.all = 0x2C20; // start, stop bit when CNT =0, master, rx, reset I2C 00101100// I2caRegs.I2CMDR.bit.NACKMOD = 0; // 15:NACK mode bit// I2caRegs.I2CMDR.bit.FREE = 0; // 14:Stop I2C when suspended// I2caRegs.I2CMDR.bit.STT = 1; // 13:START condition bit// I2caRegs.I2CMDR.bit.STP = 1; // 11:STOP condition bit// I2caRegs.I2CMDR.bit.MST = 1; // 10:Master mode// I2caRegs.I2CMDR.bit.TRX = 0; // 9:Transmitter mode// I2caRegs.I2CMDR.bit.XA = 0; // 8:7-bit addressing mode// I2caRegs.I2CMDR.bit.RM = 0; // 7:Nonrepeat mode// I2caRegs.I2CMDR.bit.DLB = 0; // 6:Digital loopback mode is disabled// I2caRegs.I2CMDR.bit.IRS = 1; // 5:The I2C module is enabled// I2caRegs.I2CMDR.bit.STB = 0; // 4:The I2C module is not in the START byte mode// I2caRegs.I2CMDR.bit.FDF = 0; // 3:Free data format mode is disabled// I2caRegs.I2CMDR.bit.BC = 0; // 2-0:8 bits per data byte I2caRegs.I2CCNT = readCount; // only read one byte data if(I2caRegs.I2CSTR.bit.NACK == 1) &#123; I2caRegs.I2CSTR.all = I2C_CLR_NACK_BIT; // 0x0002 &#125; I2caRegs.I2CMDR.bit.STP = 1; // stop bit when CNT=0 while(!I2caRegs.I2CSTR.bit.SCD); // stop bit detected? for (i = 0; i &lt; readCount; i++) &#123; buffer[i] = I2caRegs.I2CDRR; // read one byte data &#125;&#125; &emsp;ä»¥è¯»å–ManufacturerIDä¸DeviceIDä¸ºä¾‹ï¼Œä½¿ç”¨é€»è¾‘åˆ†æä»ªå¾—åˆ°çš„æ—¶åºå›¾å¦‚ä¸‹æ‰€ç¤ºã€‚ &emsp;å¯è§ManufacturerIDä¸DeviceIDå¯„å­˜å™¨è¯»å–åˆ°çš„å€¼åˆ†åˆ«ä¸º0x5449ã€0x1000ï¼Œä¸æ•°æ®æ‰‹å†Œæè¿°ä¸€è‡´ï¼Œè¯»å–æ­£ç¡®ã€‚ Configurationå¯„å­˜å™¨&emsp;å¯¹Configurationå¯„å­˜å™¨è¿›è¡Œé…ç½®å¹¶è¯»å–ç¡®ä¿å†™å…¥å·²ç”Ÿæ•ˆã€‚Configurationå¯„å­˜å™¨çš„è¯´æ˜å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚ &emsp;è¿™é‡Œå¯ä»¥å°†Configurationè®¾ç½®ä¸º0x00ï¼Œå³å…³é—­heaterã€æ¸©æ¹¿åº¦ç‹¬ç«‹è¯»å–ã€æ¸©æ¹¿åº¦å‡ä¸º14ä½åˆ†è¾¨ç‡ã€‚ &emsp;é€»è¾‘åˆ†æä»ªå¾—åˆ°çš„æ—¶åºå›¾å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚ æ¸©æ¹¿åº¦å¯„å­˜å™¨&emsp;HDC1010ä¸­æ¸©æ¹¿åº¦æ•°æ®è·å–æµç¨‹å¦‚ä¸‹ï¼šè§¦å‘é‡‡æ ·-ç­‰å¾…é‡‡æ ·ç»“æŸ-è¯»å–é‡‡æ ·ä¿¡æ¯ã€‚å½“é‡‡æ ·æœªç»“æŸæ—¶è¯»å–æ•°æ®å°†è·å¾—åˆ°ä¸€ä¸ªNACKã€‚æ•°æ®æ‰‹å†Œä¸­æ—¶åºå›¾å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚ &emsp;ä»£ç å®ç°å¦‚ä¸‹æ‰€ç¤ºï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576uint16 HDC_GetTemperature(void)&#123; int32 temp; HDC_GetSensor(HDC1010_ADDR, TemperatureA, 2, temperature_buffer); //HDC_GetSensor(HDC1010_ADDR, TemperatureA, 2, humidity_buffer); temp = (temperature_buffer[0]&lt;&lt;8) + temperature_buffer[1]; return (temp * 1650&gt;&gt;16) - 400;&#125;uint16 HDC_GetHumidity(void)&#123; int32 humi; HDC_GetSensor(HDC1010_ADDR, HumidityA, 2, humidity_buffer); humi = (humidity_buffer[0]&lt;&lt;8) + humidity_buffer[1]; return humi * 1000 &gt;&gt; 16;&#125;void HDC_GetSensor(uint16 addr, uint16 reg, uint16 readCount, uint8 *buffer)&#123; uint16 i; I2caRegs.I2CMDR.bit.IRS = 1; // reset I2C // Make sure I2C is not busy and has stopped while (I2caRegs.I2CSTR.bit.BB == 1); // busy loop I2caRegs.I2CSTR.bit.SCD = 1; // Clear the SCD bit (stop condition bit) //while(I2caRegs.I2CMDR.bit.STP == 1); // stop bit loop I2caRegs.I2CSAR = addr; // I2C slave address while (I2caRegs.I2CSTR.bit.BB == 1); // still busy? I2caRegs.I2CMDR.all = 0x2620; // start, no stop bit, master, tx, reset I2C 00100110// I2caRegs.I2CMDR.bit.NACKMOD = 0; // 15:NACK mode bit// I2caRegs.I2CMDR.bit.FREE = 0; // 14:Stop I2C when suspended// I2caRegs.I2CMDR.bit.STT = 1; // 13:START condition bit// I2caRegs.I2CMDR.bit.STP = 0; // 11:STOP condition bit// I2caRegs.I2CMDR.bit.MST = 1; // 10:Master mode// I2caRegs.I2CMDR.bit.TRX = 1; // 9:Transmitter mode// I2caRegs.I2CMDR.bit.XA = 0; // 8:7-bit addressing mode// I2caRegs.I2CMDR.bit.RM = 0; // 7:Nonrepeat mode// I2caRegs.I2CMDR.bit.DLB = 0; // 6:Digital loopback mode is disabled// I2caRegs.I2CMDR.bit.IRS = 1; // 5:The I2C module is enabled// I2caRegs.I2CMDR.bit.STB = 0; // 4:The I2C module is not in the START byte mode// I2caRegs.I2CMDR.bit.FDF = 0; // 3:Free data format mode is disabled// I2caRegs.I2CMDR.bit.BC = 0; // 2-0:8 bits per data byte I2caRegs.I2CCNT = 1; // assume register address is one byte I2caRegs.I2CDXR = reg; // register address of the sensor (1 byte) while(!I2caRegs.I2CSTR.bit.ARDY); // all ready? //while (HDC_DRDY_Read() != HDC_Ready); // first read and should return a NACK I2caRegs.I2CMDR.all = 0x2C20; // start, stop bit when CNT =0, master, rx, reset I2C 00101100 I2caRegs.I2CCNT = readCount; // only read one byte data while (HDC_DRDY_Read() != HDC_Ready); I2caRegs.I2CMDR.all = 0x2C20; // start, stop bit when CNT =0, master, rx, reset I2C 00101100 I2caRegs.I2CCNT = readCount; // only read one byte data if(I2caRegs.I2CSTR.bit.NACK == 1) &#123; I2caRegs.I2CSTR.all = I2C_CLR_NACK_BIT; // 0x0002 &#125; I2caRegs.I2CMDR.bit.STP = 1; // stop bit when CNT=0 while(!I2caRegs.I2CSTR.bit.SCD); // stop bit detected? for (i = 0; i &lt; readCount; i++) &#123; buffer[i] = I2caRegs.I2CDRR; // read one byte data &#125;&#125; &emsp;ä½¿ç”¨é€»è¾‘åˆ†æä»ªè·å–çš„æ—¶åºå›¾åˆ†ä¸º2éƒ¨åˆ†å±•ç¤ºï¼š1æ˜¯è§¦å‘é‡‡æ ·ï¼Œå°è¯•è¯»å–ç»“æœå¾—åˆ°ä¸€ä¸ªNACKï¼ŒåŒæ—¶DRDYnå˜ä¸ºé«˜ç”µå¹³ï¼Œè¡¨ç¤ºé‡‡æ ·è¿›è¡Œä¸­ï¼›2æ˜¯DRDYnå‡ºç°ä¸‹é™æ²¿ä»£è¡¨é‡‡æ ·å®Œæˆï¼Œæ§åˆ¶å™¨è¯»å–é‡‡æ ·ç»“æœã€‚ æ€»ç»“&emsp;è‡³æ­¤ï¼Œåˆæ­¥è¯´æ˜äº†HDC1010ä¼ æ„Ÿå™¨çš„åŸºæœ¬ä½¿ç”¨åŸåˆ™ã€‚ç”±äºç¯‡å¹…é™åˆ¶ï¼Œå…¶ä¸­ä¾‹å¦‚å¯„å­˜å™¨åŸå§‹æ•°æ®è½¬åŒ–ä¸ºæ¸©æ¹¿åº¦å€¼ç­‰è¿‡ç¨‹è¿™é‡Œä¸å†å™è¿°ã€‚ğŸ˜„","categories":[{"name":"åµŒå…¥å¼","slug":"åµŒå…¥å¼","permalink":"http://jiaodi.tech/categories/åµŒå…¥å¼/"}],"tags":[{"name":"C2000","slug":"C2000","permalink":"http://jiaodi.tech/tags/C2000/"},{"name":"HDC1010","slug":"HDC1010","permalink":"http://jiaodi.tech/tags/HDC1010/"},{"name":"I2C","slug":"I2C","permalink":"http://jiaodi.tech/tags/I2C/"},{"name":"Sensor","slug":"Sensor","permalink":"http://jiaodi.tech/tags/Sensor/"}]},{"title":"IEEE Std 802.11a/g/n/ac","slug":"IEEEStd802-11","date":"2018-01-14T02:46:04.000Z","updated":"2018-01-14T14:21:08.023Z","comments":true,"path":"2018/01/14/IEEEStd802-11/","link":"","permalink":"http://jiaodi.tech/2018/01/14/IEEEStd802-11/","excerpt":"&emsp;æœ¬æ–‡è®°å½•IEEE 802.11ä¸­å…³äºWLANæ— çº¿é€Ÿç‡ä¸æ¥æ”¶çµæ•åº¦çš„ç›¸å…³æ ‡å‡†ã€‚","text":"&emsp;æœ¬æ–‡è®°å½•IEEE 802.11ä¸­å…³äºWLANæ— çº¿é€Ÿç‡ä¸æ¥æ”¶çµæ•åº¦çš„ç›¸å…³æ ‡å‡†ã€‚ Glossary ABBR ADSL Asymmetrical Digital Subscriber Loop BPSK Binary Phase Shift Keying CCA Clear Channel Assessment DMT Discrete Multi Tone DSSS Direct Sequence Spread Spectrum FEC Forward Error Correction FFT Fast Fourier Transform FHSS Frequency Hopping Spread Spectrum GI Guard Interval IFFT Inverse Fast Fourier Transform LAN Local Area Network MAC Medium Access Control Layer MIB Management Information Base MLME MAC Layer Management Entity MPDU MAC Protocol Data Units $N_{BPSC}$ Number of coded bits per subcarrier $N_{CBPS}$ Number of coded bits per OFDM symbol $N_{DBPS}$ Number of data bits per OFDM symbol OFDM Orthogonal Frequency Division Multiplexing PHY Physical Layer PLCP Physical Layer Convergence Procedure PLME Physical Layer Management Entity PMD Physical Medium Dependent PPDU PLCP Protocol Data Unit PSDU PHY Sublayer Service Data Units QAM Quadrature Amplitude Modulation QPSK Quadrature Phase Shift Keying SAP Service Access Point WLAN Wireless Local Area Network 802.11a/gRate-dependent parameters Markdownæ ¼å¼è¡¨æ ¼å¤šåˆ—æƒ…å†µä¸‹åœ¨æ‰‹æœºä¸Šé¢„è§ˆæ•ˆæœä¸ä½³ï¼Œæ•…ä¹‹åè¡¨æ ¼é‡‡ç”¨æˆªå›¾æ–¹å¼ã€‚ Timing-related parameters Transmitter constellation error&emsp;The relative constellation RMS error, averaged over subcarriers, OFDM frames, and packets, shall notexceed a data-rate dependent value according to the table below. Receiver minimum input level sensitivity&emsp;The packet error rate (PER) shall be less than 10% at a PSDU length of 1000 bytes for rate-dependent input levels shall be the numbers listed in the table below or less. The minimum input levels are measured at the antenna connector (NF of 10 dB and 5 dB implementation margins are assumed). 802.11nSymbols used in MCS parameter tables Rate-dependent parameters20 MHz, NSS = 1, NES = 1 20 MHz, NSS = 2, NES = 1, EQM 20 MHz, NSS = 3, NES = 1, EQM 20 MHz, NSS = 4, NES = 1, EQM 40 MHz, NSS = 1, NES = 1 40 MHz, NSS = 2, NES = 1, EQM 40 MHz, NSS = 3, NES = 1, EQM 40 MHz, NSS = 4, NES = 1, EQM Transmitter constellation error Receiver minimum input level sensitivity 802.11acRate-dependent parameters20 MHz, NSS = 1 40 MHz, NSS = 1 80 MHz, NSS = 1 160 MHz, NSS = 1 Transmitter constellation error Receiver minimum input level sensitivity","categories":[{"name":"802.11","slug":"802-11","permalink":"http://jiaodi.tech/categories/802-11/"}],"tags":[{"name":"802.11","slug":"802-11","permalink":"http://jiaodi.tech/tags/802-11/"},{"name":"MAC","slug":"MAC","permalink":"http://jiaodi.tech/tags/MAC/"},{"name":"PHY","slug":"PHY","permalink":"http://jiaodi.tech/tags/PHY/"}]},{"title":"åŠ è½½C2000 XDS100ä»¿çœŸå™¨çš„è™šæ‹Ÿä¸²å£(VCP)","slug":"XDS100-VCP","date":"2018-01-08T14:16:59.000Z","updated":"2018-03-15T13:45:47.960Z","comments":true,"path":"2018/01/08/XDS100-VCP/","link":"","permalink":"http://jiaodi.tech/2018/01/08/XDS100-VCP/","excerpt":"&emsp;XDS100ä¸ºC2000ä¸­å¸¸ç”¨çš„ä»¿çœŸå™¨ï¼Œå…¶å…·æœ‰è™šæ‹Ÿä¸²å£(VCP, virtual com port)åŠŸèƒ½ã€‚åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œä»¿çœŸå™¨çš„è™šæ‹Ÿä¸²å£æ— æ³•è‡ªåŠ¨æ‰“å¼€ï¼Œæœ¬æ–‡å°†æä¾›ä¸€ç§è§£å†³æ–¹æ³•ã€‚","text":"&emsp;XDS100ä¸ºC2000ä¸­å¸¸ç”¨çš„ä»¿çœŸå™¨ï¼Œå…¶å…·æœ‰è™šæ‹Ÿä¸²å£(VCP, virtual com port)åŠŸèƒ½ã€‚åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œä»¿çœŸå™¨çš„è™šæ‹Ÿä¸²å£æ— æ³•è‡ªåŠ¨æ‰“å¼€ï¼Œæœ¬æ–‡å°†æä¾›ä¸€ç§è§£å†³æ–¹æ³•ã€‚ &emsp;æœ¬æ–‡ä¸­ä½¿ç”¨çš„æ¿å¡ä¸ºTIçš„LAUNCHXL-F28069Mã€‚ Windows 10 æ‰“å¼€è®¾å¤‡ç®¡ç†å™¨ï¼Œæ‰“å¼€XDS100 Class Auxiliary Portï¼› åœ¨è®¾ç½®ä¸­é€‰æ‹©Advancedï¼Œå‹¾é€‰Load VCPï¼Œé€‰æ‹©OKï¼› æ‹”æ‰ä»¿çœŸå™¨ï¼Œé‡æ–°æ’ä¸Šç¨ç­‰ï¼Œå¯ä»¥çœ‹åˆ°è™šæ‹Ÿä¸²å£å‡ºç°ã€‚ Windows 8 æ‰“å¼€è®¾å¤‡ç®¡ç†å™¨ï¼Œæ‰¾åˆ°TIXDS100 Channel Bã€‚å³é”®TI XDS100 Channel Bï¼Œé€‰æ‹©å±æ€§é€‰é¡¹ï¼› åœ¨å±æ€§é€‰é¡¹ä¸­ï¼Œé€‰æ‹©â€œé«˜çº§â€ã€‚å‹¾é€‰â€œåŠ è½½VCPâ€çš„é€‰é¡¹ï¼Œå¹¶é€‰æ‹©ç¡®å®šï¼› æ‹”æ‰ä»¿çœŸå™¨ï¼Œé‡æ–°æ’ä¸Šç¨ç­‰ï¼Œå¯ä»¥çœ‹åˆ°è™šæ‹Ÿä¸²å£å‡ºç°ã€‚","categories":[{"name":"åµŒå…¥å¼","slug":"åµŒå…¥å¼","permalink":"http://jiaodi.tech/categories/åµŒå…¥å¼/"}],"tags":[{"name":"C2000","slug":"C2000","permalink":"http://jiaodi.tech/tags/C2000/"},{"name":"XDS100","slug":"XDS100","permalink":"http://jiaodi.tech/tags/XDS100/"},{"name":"ä¸²å£","slug":"ä¸²å£","permalink":"http://jiaodi.tech/tags/ä¸²å£/"}]},{"title":"MarkdownåŸºæœ¬è¯­æ³•","slug":"MarkdownSyntax","date":"2018-01-06T14:25:37.000Z","updated":"2018-03-15T13:46:01.619Z","comments":true,"path":"2018/01/06/MarkdownSyntax/","link":"","permalink":"http://jiaodi.tech/2018/01/06/MarkdownSyntax/","excerpt":"&emsp;æœ¬æ–‡è®°å½•å¸¸ç”¨çš„Markdownè¯­æ³•ã€‚","text":"&emsp;æœ¬æ–‡è®°å½•å¸¸ç”¨çš„Markdownè¯­æ³•ã€‚ &emsp;æœ¬æ–‡æ ¹æ®ä»¥ä¸‹æ–‡ç« æ•´ç†ç»¼åˆï¼š Markdownå¸¸ç”¨æ ¼å¼ markdownç®€æ˜è¯­æ³• Markdownè¯­æ³•è¯´æ˜ï¼ˆè¯¦è§£ç‰ˆï¼‰ Markdownä¸­å†™æ•°å­¦å…¬å¼ &emsp;æ–‡ç« æ’°å†™æ‰€ä½¿ç”¨çš„Markdownç¼–è¾‘å™¨ä¸ºTyporaï¼Œæ‰€æœ‰è¯­æ³•å‡åŸºäºè¯¥ç¼–è¾‘å™¨è¿›è¡Œæµ‹è¯•ã€‚ æ®µè½&emsp;æ®µè½ç”±è‡³å°‘ä¸€è¡Œçš„è¿ç»­æ–‡æœ¬æ„æˆã€‚åœ¨Typoraä¸­ï¼Œä½¿ç”¨å›è½¦è¿›è¡Œæ®µè½åˆ‡æ¢å³å¯ã€‚ æ ‡é¢˜&emsp;æ–‡æœ¬å‰ä½¿ç”¨#æŒ‡ç¤ºæ ‡é¢˜ï¼ŒæŒ‰ç…§#ä¸ªæ•°åˆ†ä¸º1è‡³6çº§æ ‡é¢˜ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š å¼•ç”¨&emsp;&gt;ç”¨äºå¼•ç”¨æ–‡æœ¬ã€‚ 1&gt;é¥®æ°´æ€æºï¼Œçˆ±å›½è£æ ¡ã€‚ å³ä¸ºï¼š é¥®æ°´æ€æºï¼Œçˆ±å›½è£æ ¡ã€‚ åˆ—è¡¨&emsp;è¾“å…¥* åˆ—è¡¨1åˆ›å»ºä¸€ä¸ªæ— åºåˆ—è¡¨ï¼Œ*å¯ä»¥ç”¨+æˆ–è€…-ä»£æ›¿ã€‚æ³¨æ„*åå¿…é¡»åŠ ä¸€ä¸ªç©ºæ ¼ã€‚ &emsp;è¾“å…¥1. åˆ—è¡¨1åˆ›å»ºä¸€ä¸ªæœ‰åºåˆ—è¡¨ã€‚æ³¨æ„1.åå¿…é¡»åŠ ä¸€ä¸ªç©ºæ ¼ã€‚ 12345* æ— åºåˆ—è¡¨1* æ— åºåˆ—è¡¨21. æœ‰åºåˆ—è¡¨12. æœ‰åºåˆ—è¡¨ å³ä¸ºï¼š æ— åºåˆ—è¡¨1 æ— åºåˆ—è¡¨2 æœ‰åºåˆ—è¡¨1 æœ‰åºåˆ—è¡¨ ä»»åŠ¡åˆ—è¡¨&emsp;ä»»åŠ¡åˆ—è¡¨ç”¨æ³•å¦‚ä¸‹ï¼Œä½¿ç”¨- [ ] æ ‡è¯†ã€‚æ³¨æ„-åã€[ ]ä¸­ä¸]åå¿…é¡»åŠ ä¸€ä¸ªç©ºæ ¼ã€‚ 12- [ ] incomplete- [x] completed [ ] incomplete [x] completed ä»£ç æ®µè¾“å…¥```code```å³å¯ã€‚åœ¨Typoraä¸­è¾“å…¥```åå›è½¦å³å¯ï¼ŒåŒæ—¶åœ¨ç¬¬ä¸€è¡Œ```åå¯ä»¥æŒ‡å®šä»£ç è¯­è¨€ã€‚ å³ä¸ºï¼š 12name = raw_input(\"please enter your name:\")print (\"input:\", name) æ•°å­¦å…¬å¼&emsp;Markdownä¸­å¯ä»¥ä½¿ç”¨LaTeXæ•°å­¦è¡¨è¾¾å¼ã€‚åœ¨Typoraä¸­è¾“å…¥$$åå›è½¦å³å¯ã€‚ä¾‹å¦‚éº¦å…‹æ–¯éŸ¦æ–¹ç¨‹ç»„çš„å¾®åˆ†ä¸ç§¯åˆ†å½¢å¼ã€‚ 1234567891011Differentialï¼š$$\\nabla\\cdot\\vec&#123;B&#125;=0$$$$\\nabla\\cdot\\vec&#123;D&#125;=\\rho$$$$\\nabla\\times\\vec&#123;H&#125;=\\vec&#123;J&#125; + \\frac&#123;\\partial \\vec&#123;D&#125;&#125;&#123;\\partial t&#125;$$$$\\nabla\\times\\vec&#123;E&#125;=- \\frac&#123;\\partial \\vec&#123;B&#125;&#125;&#123;\\partial t&#125;$$Integralï¼š$$\\oint\\_&#123;S&#125; \\vec&#123;B&#125;\\cdot\\mathrm&#123;d&#125;\\vec&#123;S&#125;=0$$$$\\oint\\_&#123;S&#125; \\vec&#123;B&#125;\\cdot\\mathrm&#123;d&#125;\\vec&#123;S&#125;=\\int\\_&#123;V&#125;\\rho \\mathrm&#123;d&#125;V$$$$\\oint\\_&#123;l&#125; \\vec&#123;H&#125;\\cdot \\mathrm&#123;d&#125;\\vec&#123;l&#125;=\\int\\_&#123;S&#125;(\\vec&#123;J&#125;+\\frac&#123;\\partial \\vec&#123;D&#125;&#125;&#123;\\partial t&#125;)\\cdot\\mathrm&#123;d&#125;\\vec&#123;S&#125;$$$$\\oint\\_&#123;l&#125; \\vec&#123;E&#125;\\cdot \\mathrm&#123;d&#125;\\vec&#123;l&#125;=-\\int\\_&#123;S&#125;\\frac&#123;\\partial \\vec&#123;B&#125;&#125;&#123;\\partial t&#125;\\cdot\\mathrm&#123;d&#125;\\vec&#123;S&#125;$$ å³ä¸ºï¼š &emsp;Differentialï¼š $$\\nabla\\cdot\\vec{B}=0$$$$\\nabla\\cdot\\vec{D}=\\rho$$$$\\nabla\\times\\vec{H}=\\vec{J} + \\frac{\\partial \\vec{D}}{\\partial t}$$$$\\nabla\\times\\vec{E}=- \\frac{\\partial \\vec{B}}{\\partial t}$$ &emsp;Integralï¼š $$\\oint_{S} \\vec{B}\\cdot\\mathrm{d}\\vec{S}=0$$$$\\oint_{S} \\vec{B}\\cdot\\mathrm{d}\\vec{S}=\\int_{V}\\rho \\mathrm{d}V$$$$\\oint_{l} \\vec{H}\\cdot \\mathrm{d}\\vec{l}=\\int_{S}(\\vec{J}+\\frac{\\partial \\vec{D}}{\\partial t})\\cdot\\mathrm{d}\\vec{S}$$$$\\oint_{l} \\vec{E}\\cdot \\mathrm{d}\\vec{l}=-\\int_{S}\\frac{\\partial \\vec{B}}{\\partial t}\\cdot\\mathrm{d}\\vec{S}$$ è¡¨æ ¼&emsp;è¡¨æ ¼çš„ç”¨æ³•å¦‚ä¸‹æ‰€ç¤ºï¼Œå…¶ä¸­ç¬¬äºŒè¡Œçš„:ç”¨äºç¡®å®šå¯¹é½æ–¹å¼ã€‚ 12345| Left-Aligned | Center Aligned | Right Aligned || :------------ | :-------------: | ------------: || col 3 is | some wordy text | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | å³ä¸ºï¼š Left-Aligned Center Aligned Right Aligned col 3 is some wordy text $1600 col 2 is centered $12 zebra stripes are neat $1 åˆ†å‰²çº¿ ä½¿ç”¨---æˆ–è€…***å¹¶å›è½¦å°†äº§ç”Ÿä¸€æ¡åˆ†å‰²çº¿ã€‚ 12---*** é“¾æ¥ä½¿ç”¨[æ–‡æœ¬](é“¾æ¥åœ°å€)è¯­æ³•å³å¯ã€‚ 1[ä¸Šæµ·äº¤é€šå¤§å­¦](http://www.sjtu.edu.cn/) å³ä¸ºï¼š ä¸Šæµ·äº¤é€šå¤§å­¦ å›¾ç‰‡&emsp;ä½¿ç”¨![]()è¯­æ³•å³å¯ã€‚ 1![](http://omcg8fk23.bkt.clouddn.com/Jay.jpg) æ–‡æœ¬å¼ºè°ƒæ–œä½“1*é¥®æ°´æ€æºï¼Œçˆ±å›½è£æ ¡ã€‚* é¥®æ°´æ€æºï¼Œçˆ±å›½è£æ ¡ã€‚ ç²—ä½“1**é¥®æ°´æ€æºï¼Œçˆ±å›½è£æ ¡ã€‚** é¥®æ°´æ€æºï¼Œçˆ±å›½è£æ ¡ã€‚ ä»£ç 1`é¥®æ°´æ€æºï¼Œçˆ±å›½è£æ ¡ã€‚` é¥®æ°´æ€æºï¼Œçˆ±å›½è£æ ¡ã€‚ åˆ é™¤çº¿1~~å—·å—·å—·~~ å—·å—·å—·ã€‚ ä¸‹åˆ’çº¿1&lt;u&gt;é¥®æ°´æ€æºï¼Œçˆ±å›½è£æ ¡ã€‚&lt;/u&gt; é¥®æ°´æ€æºï¼Œçˆ±å›½è£æ ¡ã€‚","categories":[{"name":"Markdown","slug":"Markdown","permalink":"http://jiaodi.tech/categories/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://jiaodi.tech/tags/Markdown/"}]},{"title":"Buckç”µè·¯çš„åŠŸç‡éƒ¨åˆ†è®¾è®¡","slug":"BuckPowerStage","date":"2017-11-21T13:49:52.000Z","updated":"2018-01-25T14:45:24.151Z","comments":true,"path":"2017/11/21/BuckPowerStage/","link":"","permalink":"http://jiaodi.tech/2017/11/21/BuckPowerStage/","excerpt":"&emsp;Buckç”µè·¯æ˜¯åµŒå…¥å¼ç³»ç»Ÿä¸­æœ€å¸¸è§çš„ç”µæºæ¨¡å—ï¼Œæœ¬æ–‡å°†å¯¹Buckç”µè·¯çš„åŠŸç‡éƒ¨åˆ†è®¾è®¡è¿›è¡Œç®€å•æ€»ç»“ã€‚","text":"&emsp;Buckç”µè·¯æ˜¯åµŒå…¥å¼ç³»ç»Ÿä¸­æœ€å¸¸è§çš„ç”µæºæ¨¡å—ï¼Œæœ¬æ–‡å°†å¯¹Buckç”µè·¯çš„åŠŸç‡éƒ¨åˆ†è®¾è®¡è¿›è¡Œç®€å•æ€»ç»“ã€‚ &emsp;æœ¬æ–‡çš„ä¸»è¦å†…å®¹æ‘˜å½•æ€»ç»“è‡ªBasic Calculation of a Buck Converterâ€™s Power Stage by RICHTEKï¼Œä¹Ÿå¯ç›´æ¥è¯»å–è¯¥æ–‡æ¡£ã€‚ Buckç”µè·¯çš„åŸºæœ¬åŸç† &emsp;Buckç”µè·¯çš„åŸºæœ¬åŸç†æ˜¯ç”µæ„Ÿçš„ä¼ç§’å¹³è¡¡ã€‚ä¼ç§’å¹³è¡¡çš„å«ä¹‰åœ¨äºä¸€ä¸ªå¼€å…³å‘¨æœŸå†…ç”µæ„Ÿçš„ç”µæµå˜åŒ–é‡ä¸ºé›¶ã€‚ä¸Šå›¾ä¸ºä¸€ä¸ªåŒæ­¥æ•´æµçš„Buckç”µè·¯ï¼Œè®¾å®šè¾“å…¥ç”µå‹ä¸ºVinï¼Œè¾“å‡ºç”µå‹ä¸ºVoutï¼Œå¼€å…³å‘¨æœŸä¸ºTï¼Œå¼€å…³é¢‘ç‡ä¸º$f_{sw}$ï¼Œå ç©ºæ¯”ä¸ºDï¼Œåˆ™ä¼ç§’å¹³è¡¡è¡¨ç¤ºå¦‚ä¸‹: $$(V_{in}-V_{out})\\cdot T\\cdot D= V_{out}\\cdot T\\cdot (1-D)$$ &emsp;å³æœ‰ï¼š$$V_{in}\\cdot D= V_{out}$$ &emsp;ä¸»è¦çš„ç”µæµç”µå‹æ³¢å½¢å¦‚ä¸‹ï¼Œè¿™é‡Œä¸å†è¯¦ç»†è¯´æ˜ï¼š åé¦ˆç”µé˜»&emsp;Buckç”µè·¯éœ€è¦åˆ©ç”¨åé¦ˆç”µé˜»è¿›è¡Œåˆ†å‹ï¼Œé€šè¿‡feedbackç®¡è„šè¾“å…¥åˆ°å†…éƒ¨è¯¯å·®æ”¾å¤§å™¨è¿›è¡Œæ¯”è¾ƒï¼Œè¿›è€Œè¿›è¡Œè¾“å‡ºè¡¥å¿ã€‚åˆ†å‹ç”µé˜»çš„ç”µè·¯å¦‚å›¾æ‰€ç¤ºï¼š &emsp;å…¶ä¸­$V_{out}$ä¸ºè¾“å‡ºç”µå‹ï¼Œ$R_{1}$ä¸$R_{2}$ä¸ºåˆ†å‹ç”µé˜»ï¼Œ$I_{FB}$ä¸ºåé¦ˆå¼•è„šçš„åç½®ç”µæµï¼Œåç½®æ‰§ç”µæµçš„å€¼å¯ä»¥åœ¨æ•°æ®æ‰‹å†Œä¸­è·å–ã€‚åé¦ˆç”µé˜»çš„é€‰å–ä¸»è¦éœ€è¦è€ƒè™‘ä»¥ä¸‹å‡ ç‚¹ã€‚ è¾“å‡ºç”µå‹ç²¾åº¦&emsp;è¾“å‡ºç²¾åº¦ä¸»è¦å—3ç‚¹å½±å“ã€‚ ICæœ¬èº«è¯¯å·®&emsp;ICæœ¬èº«æœ‰ç²¾åº¦èŒƒå›´ï¼Œé€šå¸¸æƒ…å†µä¸‹è¾“å‡ºç²¾åº¦ä¸º1%~2%ï¼Œè¿™ç”±åŠå¯¼ä½“å‚å•†æ§åˆ¶ï¼Œæ— æ³•é€šè¿‡è®¾è®¡å¼¥è¡¥ã€‚ åé¦ˆç”µé˜»è¯¯å·®&emsp;ç”µé˜»æœ¬èº«å…·æœ‰è¯¯å·®ï¼Œä¾‹å¦‚1%ä¸5%ç­‰ï¼Œé«˜ç²¾åº¦ç”µé˜»çš„è¯¯å·®å¯ä»¥ä½äº0.01%ã€‚å®é™…è®¾è®¡ä¸­ç”µé˜»çš„è¯¯å·®ç›´æ¥å½±å“åˆ†å‹æ¯”ï¼Œä½¿ç”¨ä¸¤ä¸ª1%ç²¾åº¦çš„ç”µé˜»åˆ™å¯èƒ½é€ æˆçš„æœ€å¤§è¯¯å·®çº¦ä¸º2%ã€‚è€Œé«˜ç²¾åº¦ç”µé˜»æˆæœ¬ä¼šå¤§å¹…æå‡ã€‚é€šå¸¸è®¾è®¡ä¸­å–1%ç²¾åº¦ç”µé˜»å³å¯ã€‚ åé¦ˆå¼•è„šåç½®ç”µæµå¼•èµ·çš„è¯¯å·®&emsp;æŒ‰ç…§åé¦ˆç”µé˜»çš„ç”µè·¯å›¾ï¼Œè®¾å®šåé¦ˆç”µå‹ä¸º$V_{FB}$ï¼Œåé¦ˆå¼•è„šçš„åç½®ç”µæµä¸º$I_{FB}$ï¼Œå¯ä»¥å¾—åˆ°å¦‚ä¸‹å…³ç³»å¼ï¼š $$V_{out}=(\\frac{V_{FB}}{R_{2}}+I_{FB})\\cdot R_{1}+V_{FB}=V_{FB}\\cdot (\\frac{R_{1}}{R_{2}}+1+\\frac{I_{FB}\\cdot R_{1}}{V_{FB}})$$ &emsp;åœ¨ä¸Šå¼ä¸­ï¼Œå¯ä»¥æ§åˆ¶$I_{FB}$å¼•èµ·çš„è¯¯å·®å°½å¯èƒ½å°è€Œå¿½ç•¥ä¸è®¡ï¼Œåˆ™å¯è¦æ±‚å¦‚ä¸‹ï¼š $$\\frac{R_{1}}{R_{2}}+1\\gg \\frac{I_{FB}\\cdot R_{1}}{V_{FB}}$$ &emsp;ç­‰ä»·äºï¼š $$\\frac{V_{FB}}{\\frac{R_{1}\\cdot R_{2}}{R_{1}+R_{2}}}\\gg I_{FB}$$ $$\\frac{V_{FB}}{R_{1}//R_{2}}\\gg I_{FB}$$ &emsp;ç”±ä»¥ä¸Šæ¨å¯¼ï¼Œå¯ä»¥çœ‹åˆ°å¿½ç•¥åé¦ˆå¼•è„šåç½®ç”µæµè¯¯å·®çš„å…³é”®æ‰€åœ¨ï¼šæŒ‰ç…§å åŠ å®šç†è€ƒè™‘ï¼Œå½“ç”µè·¯ä¸­åªè€ƒè™‘$V_{FB}$ä½œç”¨æ—¶ï¼Œåˆ™$V_{FB}$åœ¨åˆ†å‹ç”µé˜»ä¸Šçš„ç”µæµåº”å½“è¿œè¿œå¤§äºåé¦ˆå¼•è„šåç½®ç”µæµã€‚é€šå¸¸è¦æ±‚è¾¾åˆ°100å€ä»¥ä¸Šï¼Œå¯ä»¥æ§åˆ¶åç½®ç”µæµå¼•èµ·çš„è¯¯å·®åœ¨1%ä»¥å†…ã€‚ ç³»ç»Ÿé™æ€åŠŸè€—&emsp;ç”±äº$V_{out}$ä½œç”¨åœ¨åˆ†å‹ç”µé˜»ä¸Šï¼Œåˆ†å‹ç”µé˜»ä¸Šä¼šå­˜åœ¨é™æ€åŠŸè€—ï¼›ä¸ºäº†è®©é™æ€åŠŸè€—å°½å¯èƒ½å°ï¼Œåˆ†å‹ç”µé˜»çš„å–å€¼åº”å½“å°½å¯èƒ½å¤§ã€‚ä½†æ˜¯è€ƒè™‘åˆ°åé¦ˆå¼•è„šåç½®ç”µæµè¯¯å·®ä¸­çš„åˆ†æï¼Œåˆ†å‹ç”µé˜»çš„å–å€¼ä¸å¯è¿‡å¤§ã€‚æ‰€ä»¥è¿™é‡Œåº”åœ¨æ»¡è¶³åç½®ç”µæµè€ƒé‡ç‚¹åå†å°½å¯èƒ½å–é˜»å€¼è¾ƒå¤§çš„åˆ†å‹ç”µé˜»ã€‚åŒæ—¶ï¼Œéœ€è¦å…³æ³¨åˆ†å‹ç”µé˜»çš„å°è£…æ˜¯å¦æ»¡è¶³åŠŸç‡è¦æ±‚ã€‚ ç¯è·¯ç¨³å®šæ€§&emsp;åé¦ˆç”µé˜»ä¼šå½±å“ç³»ç»Ÿçš„ç¯è·¯ç¨³å®šæ€§ï¼Œè¿™ä¸€éƒ¨åˆ†å°†åœ¨åç»­ç¯è·¯ç¨³å®šæ€§ç›¸å…³åˆ†æä¸­è¯´æ˜ã€‚ğŸ˜„ åŠŸç‡ç”µæ„Ÿ&emsp;åŠŸç‡ç”µæ„Ÿçš„é€‰å‹éœ€è¦å…³æ³¨å¦‚ä¸‹å‚æ•°ã€‚ çº¹æ³¢ç”µæµé™åˆ¶&emsp;è®¾å®šç”µæºçš„è¾“å‡ºç”µæµä¸º$I_{out}$ï¼Œç”µæ„Ÿç”µæµçº¹æ³¢ç³»æ•°ä¸ºICRR(inductor current ripple ratio)ï¼Œæœ‰å¦‚ä¸‹è¡¨è¾¾å¼ï¼š $$\\frac{V_{in}-V_{out}}{L}\\cdot D\\cdot T\\leqslant I_{out}\\cdot ICRR$$ å…¶ä¸­$\\frac{V_{in}-V_{out}}{L}\\cdot D\\cdot T$å³ä¸ºæœ€å¤§ç”µæ„Ÿçº¹æ³¢ç”µæµã€‚ &emsp;ç­‰ä»·äº $$\\frac{V_{in}-V_{out}}{L}\\cdot \\frac{V_{out}}{V_{in}}\\cdot \\frac{1}{f_{sw}}\\leqslant I_{out}\\cdot ICRR$$ &emsp;å¯ä»¥å¾—åˆ°ç”µæ„Ÿæ„Ÿå€¼çš„æœ€ä½è¦æ±‚ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š $$L_{min}\\geqslant \\frac{V_{in}-V_{out}}{I_{out}\\cdot ICRR}\\cdot \\frac{V_{out}}{V_{in}}\\cdot \\frac{1}{f_{sw}}$$ é¥±å’Œç”µæµé™åˆ¶&emsp;è®¡ç®—ç”µæ„Ÿç”µæµçš„æœ€å¤§å€¼ï¼Œå¯ä»¥ç”¨äºç¡®å®šç”µæ„Ÿçš„é¥±å’Œç”µæµè¦æ±‚ï¼Œç”µæ„Ÿç”µæµçš„æœ€å¤§å€¼è®¡ç®—å¦‚ä¸‹ï¼š $$I_{max}= \\frac{1}{2}\\cdot \\frac{V_{in}-V_{out}}{L}\\cdot \\frac{V_{out}}{V_{in}}\\cdot \\frac{1}{f_{sw}}+I_{out}$$ æ¸©å‡ç”µæµé™åˆ¶&emsp;å¯¹äºåŠŸç‡ç”µæ„Ÿï¼Œæ¸©å‡ç”µæµä¸€èˆ¬å®šä¹‰ä¸ºç”µæ„Ÿçš„æ¸©å‡ä¸º40æ‘„æ°åº¦æ—¶å¯¹åº”åœ°ç”µæµRMSå€¼ã€‚ç”µæ„Ÿçš„RMSå€¼è®¡ç®—å¦‚ä¸‹ï¼š&emsp;Mapleå·²ç»å°½åŠ›äº†ï¼Œä½†æ˜¯è¿™ä¸ªç»“æœå¹¶ä¸å¤Ÿä¼˜é›…ï¼Œä¸èƒ½ä½¿æˆ‘æ»¡æ„ï¼Œé‚£ä¹ˆåŒ–ç®€ä¸€ä¸‹ï¼š $$I_{L,rms}=\\sqrt{I{_{out}}^{2}+\\frac{1}{12}\\cdot (\\frac{V_{in}-V_{out}}{L}\\cdot \\frac{V_{out}}{V_{in}}\\cdot \\frac{1}{f_{sw}})^{2}}$$ &emsp;æ³¨æ„çœ‹ï¼Œæ‹¬å·é‡Œçš„éƒ¨åˆ†å°±æ˜¯æœ€å¤§ç”µæ„Ÿçº¹æ³¢ç”µæµã€‚ è¾“å…¥æ»¤æ³¢ç”µå®¹&emsp;è¾“å…¥æ»¤æ³¢ç”µå®¹ä¸»è¦ç”¨äºç¨³å®šè¾“å…¥ç”µå‹ï¼Œå°†è¾“å…¥çº¹æ³¢ç”µå‹æ§åˆ¶åœ¨ä¸€ä¸ªè¾ƒå°çš„èŒƒå›´ä»¥å†…ï¼Œä»¥æ»¡è¶³DCDCèŠ¯ç‰‡çš„è¾“å…¥ç”µå‹è¦æ±‚ã€‚å¦‚æœDCDCèŠ¯ç‰‡ç»™å‡ºæ˜ç¡®çš„è¾“å…¥çº¹æ³¢ç”µå‹èŒƒå›´ï¼Œå¯ä»¥å‚ç…§è¯¥å‚æ•°è¿›è¡Œè®¾è®¡ï¼›å¦åˆ™é€šå¸¸å°†å…¶æ§åˆ¶åœ¨100mVå³°å³°å€¼ä»¥å†…è¶³ä»¥æ»¡è¶³ç»å¤§å¤šæ•°è¦æ±‚ã€‚ RMSç”µæµé™åˆ¶&emsp;ç¨³æ€çŠ¶æ€ä¸‹ï¼Œå¦‚æœä¸è€ƒè™‘ç”µè·¯æœ¬èº«çš„èƒ½é‡æŸè€—ï¼Œåˆ™ç”µè·¯çš„è¾“å…¥åŠŸç‡ç­‰äºè¾“å‡ºåŠŸç‡ã€‚å‡è®¾è¾“å…¥ç”µæµä¸ºç›´æµï¼Œæ ¹æ®åŠŸç‡å®ˆæ’å¯ä»¥å¾—åˆ°å¦‚ä¸‹å¼å­ï¼š $$V_{in}\\cdot I_{in}= V_{out}\\cdot I_{out}$$ $$I_{in}= D\\cdot I_{out}$$ &emsp;è¾“å…¥æ»¤æ³¢ç”µå®¹çš„ç”µæµRMSå€¼è®¡ç®—è¿‡ç¨‹å¦‚ä¸‹ï¼š &emsp;Mapleçš„è¿ç®—ç»“æœå¯ä»¥è¿›è¡Œä¼˜åŒ–ï¼Œæœ€ç»ˆç»“æœå¦‚ä¸‹ï¼š $$I_{Cin,rms}=\\sqrt{I{_{out}}^{2}\\cdot D\\cdot (1-D)+\\frac{1}{12}\\cdot (\\frac{V_{in}-V_{out}}{L}\\cdot \\frac{V_{out}}{V_{in}}\\cdot \\frac{1}{f_{sw}})^{2}\\cdot D}â€‹$$ &emsp;ä¸Šå¼ç¡®å®šäº†è¾“å…¥æ»¤æ³¢ç”µå®¹çš„ç”µæµRMSå€¼è¦æ±‚ã€‚ è¾“å…¥çº¹æ³¢é™åˆ¶&emsp;ç»§ç»­è€ƒè™‘è¾“å…¥çº¹æ³¢ç”µæµçš„è¦æ±‚ï¼Œåœ¨è®¡ç®—è¾“å…¥æ»¤æ³¢ç”µå®¹RMSå€¼çš„è¿‡ç¨‹ä¸­ï¼Œå®¹æ˜“çœ‹å‡ºç”µå®¹å¤„äºç¨³å®šçš„å……æ”¾ç”µè¿‡ç¨‹ä¸­ï¼Œå–å……ç”µé˜¶æ®µè¿›è¡Œè®¡ç®—ï¼Œæ˜“çŸ¥ç”µå®¹çš„ç”µå‹çº¹æ³¢å³°å³°å€¼ä¸ºï¼š $$\\Delta V_{Cin,vpp}=\\frac{I_{in}\\cdot (1-D)\\cdot T_{s}}{C_{in}}=\\frac{I_{out}\\cdot D\\cdot (1-D)}{C_{in}\\cdot f_{sw}}$$ &emsp;ä¸Šå¼åœ¨å ç©ºæ¯”Dä¸º50%æ—¶å–æœ€å¤§å€¼ï¼Œæœ€å¤§å€¼ä¸ºï¼š $$\\Delta V_{Cin,vpp}=\\frac{I_{out}}{4\\cdot C_{in}\\cdot f_{sw}}$$ &emsp;æ ¹æ®ä¸Šå¼å¯ä»¥è·å¾—è¾“å…¥æ»¤æ³¢ç”µå®¹çš„æœ€ä½å®¹å€¼è¦æ±‚ï¼Œå³ï¼š $$C_{in,min}\\geqslant \\frac{I_{out}}{4\\cdot \\Delta V_{Cin,vpp}\\cdot f_{sw}}$$ è¾“å‡ºæ»¤æ³¢ç”µå®¹ESRçº¹æ³¢é™åˆ¶&emsp;è¾“å‡ºæ»¤æ³¢ç”µå®¹çš„ç­‰æ•ˆä¸²è”ç”µé˜»ESRä¹Ÿä¼šå› ä¸ºç”µæ„Ÿçº¹æ³¢ç”µæµäº§ç”Ÿçº¹æ³¢ï¼Œè¡¨è¾¾å¼å¦‚ä¸‹ï¼š $$\\Delta V_{out,ESR}=ESR\\cdot \\Delta I_{L}$$ è¾“å‡ºç”µå‹çº¹æ³¢é™åˆ¶&emsp;ä¸ºäº†ä¿è¯è¾“å…¥ç”µå‹çº¹æ³¢åœ¨ä¸€ä¸ªè¾ƒå°èŒƒå›´ä»¥å†…ï¼Œå®šä¹‰ç”µå®¹ç”µå‹çº¹æ³¢ç³»æ•°CVRR(capacitor voltage ripple ratio)å¦‚ä¸‹ï¼Œå…¶ä¸­$\\Delta V_{out}$ä¸ºè¾“å‡ºç”µå‹çº¹æ³¢çš„å³°å³°å€¼ï¼š $$CVRR=\\frac{\\Delta V_{out}}{V_{out}}$$ &emsp;å¯¹äºè¾“å‡ºæ»¤æ³¢ç”µå®¹ï¼Œå…¶ç”µæµæ³¢å½¢å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚å½“ç”µæ„Ÿç”µæµå¤§äºè¾“å‡ºç”µæµæ—¶ï¼Œç”µå®¹å……ç”µï¼Œç”µå®¹ç”µå‹ä¸Šå‡ï¼›å½“ç”µæ„Ÿç”µæµå°äºè¾“å‡ºç”µæµæ—¶ï¼Œç”µå®¹æ”¾ç”µï¼Œç”µå®¹ç”µå‹ä¸‹é™ã€‚ç¨³æ€çŠ¶æ€ä¸‹ï¼Œç”µå®¹çš„å……ç”µç”µè·ä¸æ”¾ç”µç”µè·ç›¸ç­‰ï¼Œç”µæµå¹³å‡å€¼ä¸º0ã€‚å› æ­¤ï¼Œé˜´å½±éƒ¨åˆ†ä¸­ç”µå®¹å……ç”µç”µè·å¼•èµ·çš„ç”µå®¹ç”µå‹å˜åŒ–å³ä¸ºç”µå®¹ç”µå‹çº¹æ³¢çš„å³°å³°å€¼ã€‚ åˆ™æœ‰ï¼š $$C_{out,min}\\geqslant \\frac{\\Delta Q}{\\Delta V_{out} }=\\frac{\\Delta I_{L}\\cdot\\Delta t}{\\Delta V_{out} }$$ å³ä¸ºï¼š $$C_{out,min}\\geqslant \\frac{I_{out}\\cdot ICRR}{2}\\cdot\\frac{1}{2\\cdot f_{sw}}\\cdot\\frac{1}{2}\\cdot \\frac{1}{V_{out}\\cdot CVRR}$$ æœ‰ï¼š $$C_{out,min}\\geqslant \\frac{I_{out}\\cdot ICRR}{8\\cdot f_{sw}\\cdot V_{out}\\cdot CVRR}$$ RMSç”µæµé™åˆ¶&emsp;è¾“å‡ºæ»¤æ³¢ç”µå®¹çš„ç”µæµRMSå€¼è®¡ç®—å¦‚ä¸‹ï¼š &emsp;åŒ–ç®€åå¯å¾—ï¼š $$I_{C_{out},RMS}= \\sqrt{I{_{out}}^{2}\\cdot (1-D)^{2}+\\frac{1}{12}\\cdot (\\frac{V_{in}-V_{out}}{L}\\cdot \\frac{V_{out}}{V_{in}}\\cdot \\frac{1}{f_{sw}})^{2}}$$ &emsp;è‡³æ­¤ï¼Œbuckç”µè·¯çš„åŠŸç‡éƒ¨åˆ†è®¡ç®—å®Œæ¯•ã€‚ğŸ˜„","categories":[{"name":"ç”µæº","slug":"ç”µæº","permalink":"http://jiaodi.tech/categories/ç”µæº/"}],"tags":[{"name":"Buck","slug":"Buck","permalink":"http://jiaodi.tech/tags/Buck/"},{"name":"DCDC","slug":"DCDC","permalink":"http://jiaodi.tech/tags/DCDC/"}]},{"title":"ä½¿ç”¨C#æ„å»ºä¸€ä¸ªä¸²å£ç¨‹åº","slug":"myserial","date":"2017-11-16T15:11:21.000Z","updated":"2018-03-15T13:46:58.848Z","comments":true,"path":"2017/11/16/myserial/","link":"","permalink":"http://jiaodi.tech/2017/11/16/myserial/","excerpt":"&emsp;æœ¬æ–‡ç®€è¿°å¦‚ä½•ä½¿ç”¨C#æ„å»ºä¸€ä¸ªç®€å•çš„ä¸²å£ç¨‹åºã€‚","text":"&emsp;æœ¬æ–‡ç®€è¿°å¦‚ä½•ä½¿ç”¨C#æ„å»ºä¸€ä¸ªç®€å•çš„ä¸²å£ç¨‹åºã€‚ æ–°å»ºä¸€ä¸ªC#ç¨‹åº&emsp;æ‰“å¼€VSï¼Œé€‰æ‹©æ–°å»ºä¸€ä¸ªC#çª—ä½“ç¨‹åºå¹¶è®¾ç½®å·¥ç¨‹å­˜å‚¨è·¯å¾„ï¼Œç‚¹å‡»ç¡®å®šå³å¯ã€‚ çª—ä½“è®¾ç½®&emsp;æ–°å»ºå¥½ç¨‹åºåï¼Œåœ¨çª—ä½“ä¸­æ·»åŠ å¿…è¦æ§ä»¶ï¼Œæ·»åŠ è¿‡ç¨‹è¿™é‡Œä¸å†å™è¿°ï¼Œå®Œæˆåå¦‚å›¾æ‰€ç¤ºã€‚&emsp;çª—ä½“ä¸­çš„æ§ä»¶ä¸»è¦å¦‚ä¸‹ã€‚ Label&emsp;Portã€Receiveç­‰ä¸ºlabelï¼Œæ— äº¤äº’åŠŸèƒ½ï¼Œä»…ä»…ä½œä¸ºæç¤ºæ˜¾ç¤ºã€‚ ComboBox&emsp;COM1å¤„ä¸ºComboBoxï¼Œå…·æœ‰ä¸‹æ‹‰é€‰æ‹©åŠŸèƒ½ã€‚ Button&emsp;Openã€Closeç­‰ä¸ºButtonï¼Œå…·æœ‰ç‚¹å‡»åŠŸèƒ½ã€‚ TextBox&emsp;çª—ä½“ä¸­ç©ºç™½åŒºåŸŸä»¥åŠæ³¢ç‰¹ç‡è®¾ç½®ç­‰å¤„ä¸ºTextBoxï¼Œä¸ºæ–‡æœ¬æ˜¾ç¤ºåŒºåŸŸã€‚ SerialPort&emsp;çª—ä½“ä¸‹æ–¹åŒºåŸŸä¸ºSerialPortï¼Œä¸ºserialç›¸å…³æ§ä»¶ã€‚ çª—ä½“ç»„ä»¶è®¾ç½®çª—ä½“åŠ è½½è®¾ç½®&emsp;åŒå‡»ä¸»çª—ä½“ï¼Œå¯ä»¥è®¾ç½®ä¸»çª—ä½“åŠ è½½æ—¶å€™æ‰§è¡Œçš„ä»£ç ã€‚ 12345678private void Form1_Load(object sender, EventArgs e)&#123; string[] ports = SerialPort.GetPortNames(); Array.Sort(ports); comboSerial.Items.Clear(); comboSerial.Items.AddRange(ports); btnClose.Enabled = false;&#125; &emsp;è¿™æ®µä»£ç çš„ä¸»è¦åŠŸèƒ½æ˜¯ï¼šè·å–å½“å‰å¯ç”¨ä¸²å£åˆ—è¡¨ï¼Œç„¶åå°†å…¶æ”¾åœ¨ä¸‹æ‹‰èœå•ä¸­ã€‚ Openæ§ä»¶&emsp;ç‚¹å‡»Openæ§ä»¶æ—¶å€™çš„æ‰§è¡Œä»£ç å¦‚ä¸‹ã€‚123456789101112131415161718private void btnOpen_Click(object sender, EventArgs e)&#123; btnOpen.Enabled = false; btnClose.Enabled = true; try &#123; serialPort1.PortName = comboSerial.Text; serialPort1.BaudRate = Convert.ToInt32(BaudRate.Text); serialPort1.Open(); &#125; catch (Exception ex) &#123; MessageBox.Show(ex.Message, \"Message\", MessageBoxButtons.OK, MessageBoxIcon.Error); btnOpen.Enabled = true; btnClose.Enabled = false; &#125;&#125; &emsp;è¿™æ®µä»£ç çš„ä¸»è¦åŠŸèƒ½æ˜¯ï¼šåŠ è½½ä¸²å£å·ä¸æ³¢ç‰¹ç‡ï¼Œå°è¯•æ‰“å¼€ä¸²å£ã€‚ Closeæ§ä»¶&emsp;ç‚¹å‡»Closeæ§ä»¶æ—¶å€™çš„æ‰§è¡Œä»£ç å¦‚ä¸‹ã€‚123456789101112131415private void btnClose_Click(object sender, EventArgs e)&#123; btnOpen.Enabled = true; btnClose.Enabled = false; try &#123; serialPort1.Close(); &#125; catch (Exception ex) &#123; MessageBox.Show(ex.Message, \"Message\", MessageBoxButtons.OK, MessageBoxIcon.Error); btnOpen.Enabled = false; btnClose.Enabled = true; &#125;&#125; &emsp;è¿™æ®µä»£ç çš„ä¸»è¦åŠŸèƒ½æ˜¯ï¼šå…³é—­ä¸²å£ã€‚ Sendæ§ä»¶&emsp;ç‚¹å‡»Sendæ§ä»¶æ—¶å€™çš„æ‰§è¡Œä»£ç å¦‚ä¸‹ã€‚ 1234567891011private void btnSend_Click(object sender, EventArgs e)&#123; try &#123; serialPort1.WriteLine(txtSend.Text + Environment.NewLine); &#125; catch (Exception ex) &#123; MessageBox.Show(ex.Message, \"Message\", MessageBoxButtons.OK, MessageBoxIcon.Error); &#125;&#125; &emsp;è¿™æ®µä»£ç çš„ä¸»è¦åŠŸèƒ½æ˜¯ï¼šå°†Sendæ–‡æœ¬åŒºçš„æ•°æ®å‘é€åˆ°ä¸²å£ã€‚ Clearæ§ä»¶&emsp;ç‚¹å‡»Clearæ§ä»¶æ—¶å€™çš„æ‰§è¡Œä»£ç å¦‚ä¸‹ã€‚ 1234567891011private void btnClear_Click(object sender, EventArgs e)&#123; try &#123; txtReceive.Clear(); &#125; catch (Exception ex) &#123; MessageBox.Show(ex.Message, \"Message\", MessageBoxButtons.OK, MessageBoxIcon.Error); &#125;&#125; &emsp;è¿™æ®µä»£ç çš„ä¸»è¦åŠŸèƒ½æ˜¯ï¼šå°†Receiveæ–‡æœ¬åŒºçš„æ•°æ®æ¸…ç©ºã€‚ ä¸²å£æ§ä»¶&emsp;ä¸ºä¸²å£æ§ä»¶å¢åŠ DataReceivedäº‹ä»¶EVentsï¼Œæ‰§è¡Œä»£ç å¦‚ä¸‹ã€‚1234567891011private void serialPort1_DataReceived(object sender, SerialDataReceivedEventArgs e)&#123; try &#123; txtReceive.Text += serialPort1.ReadExisting(); &#125; catch (Exception ex) &#123; MessageBox.Show(ex.Message, \"Message\", MessageBoxButtons.OK, MessageBoxIcon.Error); &#125;&#125; &emsp;è¿™æ®µä»£ç çš„ä¸»è¦åŠŸèƒ½æ˜¯ï¼šå½“ä¸²å£æ¥æ”¶åˆ°æ•°æ®æ—¶ï¼Œè¯»å–æ•°æ®å¹¶æ˜¾ç¤ºåœ¨Receiveæ–‡æœ¬åŒºåŸŸã€‚ å…³é—­IllegalCrossThreadCalls&emsp;åœ¨Form1()ä¸­å…³é—­IllegalCrossThreadCallsæ£€æŸ¥ã€‚12345public Form1()&#123; InitializeComponent(); CheckForIllegalCrossThreadCalls = false;&#125; Form1_FormClosing Eventsè®¾ç½®&emsp;å½“çª—ä½“å…³é—­æ—¶å€™ï¼Œåº”å½“é‡Šæ”¾ä¸²å£ï¼Œä»£ç å¦‚ä¸‹ã€‚12345private void Form1_FormClosing(object sender, FormClosingEventArgs e)&#123; if (serialPort1.IsOpen) serialPort1.Close();&#125; è¿è¡Œç¨‹åº&emsp;è¿è¡Œä¸Šè¿°ç¨‹åºï¼Œå¯ä»¥çœ‹åˆ°ä¸²å£å¯ä»¥æ­£å¸¸è¿›è¡Œå‘é€æ¥æ”¶åŠŸèƒ½ã€‚ &emsp;è‡³æ­¤ï¼Œä¸€ä¸ªç®€å•çš„ä¸²å£ç¨‹åºå°±å®Œæˆå•¦~~~ ğŸ˜„ğŸ˜„ğŸ˜„ å­¦ä¹ è¿‡ç¨‹ä¸»è¦å‚è€ƒäº†YouTubeçš„è§†é¢‘ï¼šC# Tutorial - Serial Communication | FoxLearnã€‚","categories":[{"name":"C#","slug":"C","permalink":"http://jiaodi.tech/categories/C/"}],"tags":[{"name":"ä¸²å£","slug":"ä¸²å£","permalink":"http://jiaodi.tech/tags/ä¸²å£/"},{"name":"C#","slug":"C","permalink":"http://jiaodi.tech/tags/C/"},{"name":"serial","slug":"serial","permalink":"http://jiaodi.tech/tags/serial/"}]},{"title":"Allegroå­¦ä¹ ç¬”è®°-å·®åˆ†çº¿ä¸ç­‰é•¿çº¿","slug":"allegro-guide-2","date":"2017-07-09T04:30:00.000Z","updated":"2018-03-15T13:46:45.391Z","comments":true,"path":"2017/07/09/allegro-guide-2/","link":"","permalink":"http://jiaodi.tech/2017/07/09/allegro-guide-2/","excerpt":"&emsp;æœ¬æ–‡ä»‹ç»Allegroä¸­å·®åˆ†çº¿ä¸ç­‰é•¿çº¿çš„è®¾ç½®æ–¹æ³•ã€‚","text":"&emsp;æœ¬æ–‡ä»‹ç»Allegroä¸­å·®åˆ†çº¿ä¸ç­‰é•¿çº¿çš„è®¾ç½®æ–¹æ³•ã€‚ Xnetçš„è®¾ç½®&emsp;å®é™…çš„ç”µè·¯è®¾è®¡ä¸­ï¼Œå·®åˆ†çº¿ä¸ç­‰é•¿çº¿ä¹‹é—´å¾€å¾€ä¸²æ¥ä¸€ä¸ªç”µé˜»ç”¨äºåŒ¹é…ï¼Œæˆ–è€…è¯´ç”¨äºè°ƒèŠ‚ä¿¡å·å¼ºåº¦è€Œå‡å¼±æŒ¯é“ƒæ•ˆåº”ã€‚è€Œå·®åˆ†çº¿æˆ–è€…ç­‰é•¿çº¿è®¾ç½®ä¸­ï¼Œå‡åªèƒ½é’ˆå¯¹åŒä¸€ç½‘ç»œè¿›è¡Œè®¾ç½®ã€‚ç”±äºä¸²è”ç”µé˜»ä¹‹åï¼Œç”µé˜»ä¸¤ç«¯çš„ç½‘ç»œå·²ç»ä¸å†æ˜¯åŒä¸€ä¸ªç½‘ç»œï¼Œè€Œæ— æ³•æŒ‰ç…§å•ä¸€ç½‘ç»œè¿›è¡Œå·®åˆ†æˆ–è€…ç­‰é•¿æ§åˆ¶ã€‚&emsp;Allegroä¸­é€šè¿‡Xnetè§£å†³è¿™ä¸€é—®é¢˜ã€‚Xnetå³ä¸ºæ‹“å±•ç½‘ç»œï¼ˆExtended netï¼‰ï¼šè¿ç»­çš„ç”±è¢«åŠ¨å…ƒä»¶è¿æ¥çš„netç»„ä¸è¢«åŠ¨å…ƒä»¶å…±åŒæ„æˆXnetï¼Œå…¶ä¸­è¢«åŠ¨åŸä»¶é€šå¸¸ä¸ºç”µé˜»ã€‚è¿™é‡Œç»™å‡ºAllegroå®˜æ–¹çš„å®šä¹‰ï¼š An Xnet is a connection between drivers and receivers. An Xnet includes all the drivers and receivers connected to each other plus any discrete components that are connected to the Xnet. Xnets pass through devices such as resistors and capacitors as shown in the following figure. &emsp;æ¥ä¸Šä¸€ç¯‡æ–‡ç« ä¸­åŸºæœ¬çš„åŸç†å›¾ä¸PCBè§„åˆ™è®¾ç½®æ‰€è¿°ï¼Œè¿™é‡Œä¸¾ä¾‹å°†DACä¸²æ¥ç”µé˜»çš„è¾“å‡ºç½‘ç»œè®¾ç½®ä¸ºXnetã€‚å…·ä½“æ­¥éª¤å¦‚ä¸‹ã€‚&emsp;æ‰“å¼€Allegroï¼Œæ˜ç¡®éœ€è¦è®¾ç½®çš„Xnetï¼Œè¿™é‡Œå°†R1ä»¥åŠä¸¤ç«¯ç½‘ç»œè®¾ç½®ä¸ºXnetã€‚ &emsp;é€‰æ‹©èœå•æ Analyze-Model Assignmentï¼Œæ‰“å¼€SI Design Auditï¼Œé€‰æ‹©OKå¿½ç•¥ç°æœ‰çš„Audit Errorsã€‚ &emsp;é€‰æ‹©R1ï¼Œç‚¹å‡»Create Modelã€‚&emsp;é€‰æ‹©Create ESpiceDevice modelï¼Œç‚¹å‡»OKã€‚&emsp;åœ¨Create ESpiceDevice Modelè®¾ç½®ä¸­ï¼ŒSingle Pinsä¸­æ¯ä¸¤ä¸ªpinè¿æ¥çš„ç½‘ç»œä¸å…ƒä»¶æœ¬èº«æ„æˆä¸€ä¸ªXnetã€‚å¦‚æœå™¨ä»¶ä¸ºæ’é˜»ç­‰æŒ‰ç…§ä¸¤ä¸¤å¯¹åº”è®¾ç½®Xnetã€‚ç¡®è®¤æ— è¯¯åç‚¹å‡»OKã€‚&emsp;ä¹‹åå¼¹å‡ºSignal Model Assigment Changesæç¤ºæ¡†ã€‚&emsp;è‡³æ­¤ï¼ŒR1è¿æ¥çš„Xnetè®¾ç½®å®Œæ¯•ã€‚åŒç†è®¾ç½®R2ç›¸å…³ç½‘ç»œã€‚å¯ä»¥æ‰“å¼€Constraint ManageræŸ¥çœ‹å·²ç»è®¾ç½®å¥½çš„Xnetã€‚ å·®åˆ†çº¿çš„è®¾ç½®å·®åˆ†çº¿çš„å®šä¹‰&emsp;ç»´åŸºç™¾ç§‘ä¸­å…³äºå·®åˆ†çº¿çš„å®šä¹‰å¦‚ä¸‹ï¼š å·®åˆ†ä¼ è¾“æ˜¯ä¸€ç§ä¿¡å·ä¼ è¾“çš„æŠ€æœ¯ï¼ŒåŒºåˆ«äºä¼ ç»Ÿçš„ä¸€æ ¹ä¿¡å·çº¿ä¸€æ ¹åœ°çº¿çš„åšæ³•ï¼Œå·®åˆ†ä¼ è¾“åœ¨è¿™ä¸¤æ ¹çº¿ä¸Šéƒ½ä¼ è¾“ä¿¡å·ï¼Œè¿™ä¸¤ä¸ªä¿¡å·çš„æŒ¯å¹…ç›¸åŒï¼Œç›¸ä½ç›¸åã€‚åœ¨è¿™ä¸¤æ ¹çº¿ä¸Šçš„ä¼ è¾“çš„ä¿¡å·å°±æ˜¯å·®åˆ†ä¿¡å·ã€‚ä¿¡å·æ¥æ”¶ç«¯æ¯”è¾ƒè¿™ä¸¤ä¸ªç”µå‹çš„å·®å€¼æ¥åˆ¤æ–­å‘é€ç«¯å‘é€çš„æ˜¯é€»è¾‘0è¿˜æ˜¯é€»è¾‘1ã€‚åœ¨ç”µè·¯æ¿ä¸Šï¼Œå·®åˆ†èµ°çº¿å¿…é¡»æ˜¯ç­‰é•¿ã€ç­‰å®½ã€ç´§å¯†é è¿‘ã€ä¸”åœ¨åŒä¸€å±‚é¢çš„ä¸¤æ ¹çº¿ã€‚ å·®åˆ†çº¿å¯¹çš„è®¾ç½®&emsp;æ‰“å¼€Constraint Managerï¼Œé€‰æ‹©Physical-Net-All Layersï¼›é€‰ä¸­éœ€è¦è®¾ç½®ä¸ºå·®åˆ†çº¿å¯¹çš„2ä¸ªç½‘ç»œï¼Œè¿™é‡Œé€‰æ‹©VOUTAä¸VOUTBç½‘ç»œã€‚ &emsp;å³é”®ï¼Œé€‰æ‹©Create-Differential Pairï¼Œæ­¤æ—¶å¯ä»¥ç¼–è¾‘å·®åˆ†çº¿å¯¹åå­—ï¼Œä¹‹åç‚¹å‡»Createå³å¯ã€‚è‡³æ­¤ï¼Œå·®åˆ†çº¿å¯¹è®¾ç½®å®Œæ¯•ã€‚ å·®åˆ†çº¿çš„è§„åˆ™è®¾ç½®&emsp;æ‰“å¼€Constraint Managerï¼Œé€‰æ‹©Electrical Constraint Set-Routing-Differential Pairï¼›é€‰æ‹©Objects-Create-Electrical CSetï¼Œè¾“å…¥è§„åˆ™çº¦æŸåå­—DIFFï¼Œç‚¹å‡»OKç¡®è®¤ã€‚å¯ä»¥çœ‹åˆ°æ‰€æœ‰çš„è§„åˆ™è®¾ç½®é¡¹å¦‚ä¸‹æ‰€ç¤ºã€‚ Coupling Parameters&emsp;åœ¨Allegroä¸­ï¼Œæœ€åŸºæœ¬çš„å·®åˆ†çº¿è®¾ç½®ä¸ºCoupling Parametersè®¾ç½®ï¼Œç¤ºæ„å›¾å¦‚ä¸‹ã€‚ &emsp;å…¶ä¸­Primaryè®¾ç½®ä¸ºå…¸å‹æƒ…å†µä¸‹å·®åˆ†çº¿çš„çº¿å®½ä¸çº¿è·è®¾ç½®ï¼ŒNeckè®¾ç½®ä¸ºå¸ƒå±€å—é™æƒ…å†µä¸‹å·®åˆ†çº¿çš„çº¿å®½ä¸çº¿è·è®¾ç½®ã€‚å…·ä½“è®¾ç½®å‚æ•°éœ€è¦æŒ‰ç…§é˜»æŠ—è§„åˆ™ã€PCBåŠ å·¥èƒ½åŠ›ç­‰å…·ä½“åˆ†æã€‚ Uncoupled Length&emsp;Uncoupled Lengthç”¨äºçº¦æŸå·®åˆ†çº¿çš„ä¸åŒ¹é…é•¿åº¦ï¼Œä¾‹å¦‚å·®åˆ†çº¿å¼•çº¿å¤„å¯èƒ½å­˜åœ¨ä¸è€¦åˆçš„æƒ…å†µã€‚å¯ä»¥é€šè¿‡ä½¿èƒ½Gather Controlï¼Œè®¾ç½®Maxå€¼è®¾ç½®ä¸è€¦åˆé•¿åº¦çš„æœ€å¤§å…è®¸å€¼ã€‚ Static Phase&emsp;Cadenceå®˜æ–¹è®ºå›ä¸­å¯¹Static Phase Toleranceåšå‡ºçš„è§£é‡Šå¦‚ä¸‹ï¼š a one time check from Driver to Receiver comparing lengths or delay of each member. If a Driver cannot be determined, the check is performed across the longest path of the pair. &emsp;å³Static Phaseä¸ºé™æ€ç›¸ä½æ£€æŸ¥ï¼Œä¸€æ¬¡æ€§æ£€æµ‹æ•´ä¸ªå·®åˆ†çº¿å¯¹çš„é•¿åº¦æˆ–è€…å»¶æ—¶è¯¯å·®ï¼Œæ˜¯å¯¹å·®åˆ†çº¿å¯¹çš„æ•´ä½“è¯¯å·®æ§åˆ¶ã€‚ Dynamic Phase&emsp;Cadenceå®˜æ–¹è®ºå›ä¸­å¯¹Dynamic Phase Toleranceåšå‡ºçš„è§£é‡Šå¦‚ä¸‹ï¼š Etch length of each member is compared at each bend point interval across the Driver-Receiver path of the Diff Pair. Etch length is always measured back to the Driver pins. &emsp;å³Dynamic Phaseä¸ºåŠ¨æ€ç›¸ä½æ£€æŸ¥ï¼Œå°†å¯¹å·®åˆ†çº¿å¯¹çš„æ¯ä¸€ä¸ªè½¬è§’å¤„è¿›è¡Œè¯¯å·®æ£€æŸ¥ï¼Œæ§åˆ¶æ¯ä¸€ä¸ªè½¬è§’å¤„ç›¸å¯¹äºé©±åŠ¨ç«¯çš„é•¿åº¦æˆ–è€…å»¶æ—¶è¯¯å·®ã€‚ &emsp;Cadenceå®˜æ–¹è®ºå›ä¸­å¯¹Dynamic Phase Max Lengthåšå‡ºçš„è§£é‡Šå¦‚ä¸‹ï¼š When specified, the Diff Pair is permitted to exceed the phase tolerance constraint for a contiguous etch length of less than or equal to the value of Max Length specified. If no compensation is made within this specified distance, a DRC will be reported at the point where the Diff Pair first goes out of phase. &emsp;Dynamic Phase Max Lengthçš„å…·ä½“æ„ä¹‰ä¸ºï¼šåœ¨Dynamic Phase Max LengthèŒƒå›´ä»¥å†…ï¼Œå·®åˆ†çº¿çš„è¯¯å·®å¯ä»¥è¶…è¿‡Toleranceã€‚ä½†å¦‚æœåœ¨Dynamic Phase Max Lengthè§„å®šçš„é•¿åº¦å†…ä»ç„¶æœªèƒ½å°†è¯¯å·®è¡¥å¿ï¼Œåˆ™ç»™å‡ºä¸€ä¸ªDRCé”™è¯¯ã€‚&emsp;Dynamic Phaseçš„åº”ç”¨ä¸¾ä¾‹æ¥è¯´ã€‚ &emsp;è®¾å®šToleranceä¸ºx milï¼ŒDynamic Phase Max Lengthä¸ºy milã€‚åˆ™Dynamic Phaseçš„åŠŸèƒ½åœ¨äºä¿è¯æ•´ä¸ªå·®åˆ†å¯¹ç½‘ç»œçš„è¯¯å·®ä¸ä¼šè¶…è¿‡x milã€‚å¦‚æœåœ¨ç½‘ç»œçš„æŸä¸ªç‚¹å·®åˆ†å¯¹çš„è¯¯å·®è¶…è¿‡äº†x milï¼Œåˆ™è¶…è¿‡çš„éƒ¨åˆ†å¿…é¡»åœ¨y milä»¥å†…è¡¥å¿å›æ¥ã€‚&emsp;è¡¥å¿çš„å½¢å¼å¯ä»¥é€šè¿‡è›‡å½¢çº¿æˆ–è€…æ‹è§’è¿›è¡Œå®ç°ã€‚ ç­‰é•¿çº¿çš„è®¾ç½®ç­‰é•¿çº¿çš„å®šä¹‰&emsp;ç­‰é•¿çº¿çš„æ„ä¹‰åœ¨äºä¿è¯ç­‰é•¿çº¿ç»„çš„é•¿åº¦æˆ–è€…å»¶æ—¶è¯¯å·®åœ¨å…è®¸èŒƒå›´ä»¥å†…ã€‚ä¾‹å¦‚åœ¨DDRå¸ƒçº¿è¿‡ç¨‹ä¸­ï¼Œéœ€è¦ä¿è¯æ•°æ®çº¿çš„ç­‰é•¿ä»¥ç¡®ä¿æ•°æ®ä¼ è¾“çš„å‡†ç¡®æ€§ã€‚ ç­‰é•¿çº¿çš„è®¾ç½®&emsp;æ‰“å¼€Constraint Managerï¼Œé€‰æ‹©Electrical-Net-Routingï¼›é€‰æ‹©éœ€è¦è®¾ç½®ç­‰é•¿çš„ç½‘è·¯ï¼Œè¿™é‡Œä¸¾ä¾‹é€‰æ‹©SPIçš„SCLKã€DINã€SYNCç½‘ç»œï¼ˆäº‹å®ä¸ŠSPIä¿¡å·é€šå¸¸åœ¨50MHzä»¥å†…ï¼Œå¯¹ç­‰é•¿çš„è¦æ±‚å¹¶ä¸ä¸¥æ ¼ï¼‰ã€‚é€‰ä¸­ç½‘ç»œåï¼Œä¸è®¾ç½®å·®åˆ†çº¿ä¸€æ ·ï¼Œå³é”®é€‰æ‹©Create-Match Groupï¼Œå‘½åä¸ºSPIå³å¯ã€‚ Allegroçš„è®¾ç½®&emsp;åœ¨è¿›è¡Œç­‰é•¿çº¿è®¾ç½®ä¹‹å‰ï¼Œéœ€è¦æ‰“å¼€Allegroçš„ç›¸å…³è®¾ç½®ã€‚æŒ‰ç…§å›¾æ‰“å¼€å¦‚ä¸‹2å¤„è®¾ç½®ï¼Œä½¿å¾—AllegroåŠ¨æ€æ˜¾ç¤ºèµ°çº¿çš„é•¿åº¦ä»¥åŠå·®åˆ†çº¿çš„è¯¯å·®ã€‚ ç­‰é•¿è§„åˆ™çš„è®¾ç½®&emsp;è®¾ç½®Pin Pairsä¸ºLongest Pin Pairsï¼Œè¡¨ç¤ºä»¥æœ€é•¿çš„ä¸€æ¡çº¿ä¸ºæ ‡å‡†è¿›è¡Œæ¯”å¯¹ï¼›è®¾ç½®Relative Delayä¸º-40milï¼›40milï¼Œä»£è¡¨è¯¯å·®åœ¨Â±40milä¹‹é—´ã€‚æ­¤æ—¶ï¼Œç­‰é•¿çº¿ç»„çš„èµ°çº¿é•¿åº¦æœ¨åŒ¾è®¾ç½®ä¸ºLongest Pin Pair - 40milï¼Œåœ¨æ­¤åŸºç¡€ä¸Šè¯¯å·®ä¸ºÂ±40å³ä¸ºæ»¡è¶³è¦æ±‚ã€‚&emsp;æŒ‰ä»¥ä¸Šè¦æ±‚è®¾ç½®å®Œæ¯•åï¼Œé€‰æ‹©ç­‰é•¿çº¿ç»„ï¼Œå³é”®é€‰æ‹©Analyseå³å¯å¯¹ç­‰é•¿çº¿ç»„è¿›è¡Œåˆ†æï¼Œä¾‹å¦‚æ­¤æ—¶çš„åˆ†æç»“æœå¦‚ä¸‹ï¼š &emsp;æ­¤æ—¶DINä¸ºæœ€é•¿çº¿ï¼Œé•¿åº¦ä¸º755milï¼Œå¯çŸ¥æ­¤æ—¶çš„ç›®æ ‡çº¿é•¿ä¸º755-40=715milã€‚ç›®æ ‡çº¿é•¿å‡å»40milåˆ™ä¸ºå…è®¸çš„æœ€çŸ­çº¿é•¿ï¼Œä¸º675milã€‚å¯¹äºSCLKï¼ŒMarginä¸º675-621=54milï¼Œå·²ç»ä¸æ»¡è¶³è¦æ±‚ï¼›è€ŒSYNCçš„Marginä¸º686-675=11ï¼Œæ»¡è¶³è¦æ±‚ã€‚å› æ­¤SCLKéœ€è¦è°ƒæ•´ã€‚ ç­‰é•¿çº¿çš„è°ƒæ•´&emsp;ç­‰é•¿çº¿çš„è°ƒæ•´å¯ä»¥é€šè¿‡Delay Tuneå®ç°ï¼Œæ³¨æ„optionsé€‰é¡¹ä¸­è¦è®¾ç½®Gapä¸º3å€çº¿å®½ï¼ŒåŒæ—¶ä½¿ç”¨å¼§å½¢çº¿ã€‚ç»è¿‡ç»•çº¿å¯ä»¥è°ƒæ•´ç­‰é•¿çº¿åˆ°ç›¸è¿‘é•¿åº¦ï¼Œæ­¤æ—¶Marginå……è¶³ï¼Œæ»¡è¶³è¦æ±‚ã€‚ğŸ˜„","categories":[{"name":"EDA","slug":"EDA","permalink":"http://jiaodi.tech/categories/EDA/"}],"tags":[{"name":"Cadence","slug":"Cadence","permalink":"http://jiaodi.tech/tags/Cadence/"},{"name":"Allegro","slug":"Allegro","permalink":"http://jiaodi.tech/tags/Allegro/"},{"name":"é«˜é€Ÿç”µè·¯","slug":"é«˜é€Ÿç”µè·¯","permalink":"http://jiaodi.tech/tags/é«˜é€Ÿç”µè·¯/"},{"name":"å·®åˆ†çº¿","slug":"å·®åˆ†çº¿","permalink":"http://jiaodi.tech/tags/å·®åˆ†çº¿/"},{"name":"ç­‰é•¿çº¿","slug":"ç­‰é•¿çº¿","permalink":"http://jiaodi.tech/tags/ç­‰é•¿çº¿/"}]},{"title":"Allegroå­¦ä¹ ç¬”è®°-åŸºç¡€ç¯‡","slug":"allegro-guide-1","date":"2017-06-11T15:47:54.000Z","updated":"2018-03-15T13:46:26.316Z","comments":true,"path":"2017/06/11/allegro-guide-1/","link":"","permalink":"http://jiaodi.tech/2017/06/11/allegro-guide-1/","excerpt":"&emsp;Allegroæ˜¯Cadenceå…¬å¸æ——ä¸‹çš„åŠŸèƒ½å¼ºå¤§çš„PCBè®¾è®¡å·¥å…·ï¼Œåœ¨é«˜é€Ÿç”µè·¯è®¾è®¡ä¸­åº”ç”¨è¾ƒå¤šã€‚æœ€è¿‘å­¦ä¹ Allegroæ•´ç†äº†ä¸€äº›ç¬”è®°ï¼Œè¿™é‡Œä¸å¤§å®¶åˆ†äº«ã€‚","text":"&emsp;Allegroæ˜¯Cadenceå…¬å¸æ——ä¸‹çš„åŠŸèƒ½å¼ºå¤§çš„PCBè®¾è®¡å·¥å…·ï¼Œåœ¨é«˜é€Ÿç”µè·¯è®¾è®¡ä¸­åº”ç”¨è¾ƒå¤šã€‚æœ€è¿‘å­¦ä¹ Allegroæ•´ç†äº†ä¸€äº›ç¬”è®°ï¼Œè¿™é‡Œä¸å¤§å®¶åˆ†äº«ã€‚ å‡†å¤‡å·¥ä½œ&emsp;é¦–å…ˆå»ºç«‹ä¸€ä¸ªç®€å•çš„å·¥ç¨‹ï¼Œæœ¬æ–‡å»ºç«‹çš„å·¥ç¨‹å¦‚å›¾æ‰€ç¤ºï¼Œå³DAC8552çš„ä¸€ä¸ªæ¥å£ç”µè·¯ï¼ŒåŒ…æ‹¬DACçš„æ¨¡æ‹Ÿè¾“å…¥è¾“å‡ºä»¥åŠSPIæ•°å­—æ¥å£ã€‚&emsp;åŸç†å›¾åŠå°è£…è®¾è®¡è¿™é‡Œä¸å†è¯´æ˜ã€‚ ä¸ºPCBæ·»åŠ outlineæ¿æ¡†ä»¥åŠRoute KeepinåŒºåŸŸ&emsp;å»ºç«‹PCBåï¼Œé¦–å…ˆè¦æ·»åŠ ä¸€ä¸ªæ¿æ¡†ï¼Œå³è§„å®šäº†PCBçš„å¤–å½¢ã€‚åœ¨èœå•æ ä¸­é€‰æ‹©Add-lineï¼ŒOptionsæ ä¸­é€‰æ‹©Board Geometry-Outlineï¼Œä¹‹åå¯ä»¥æŒ‰ç…§æ‰€éœ€å¤§å°è¿›è¡Œç”»çº¿å³å¯ã€‚å¦‚æœéœ€è¦ç²¾ç¡®æ§åˆ¶å¤–æ¿æ¡†å¤§å°ï¼Œå¯ä»¥åœ¨å‘½ä»¤çª—å£ä¸­é€šè¿‡xï¼Œixï¼ŒiyæŒ‡ä»¤è¿›è¡Œç²¾ç¡®ç»˜åˆ¶ã€‚ç»˜åˆ¶å®Œæ¯•åï¼Œå•å‡»é¼ æ ‡å³é”®é€‰æ‹©Doneå³å®Œæˆã€‚&emsp;Outlineç»˜åˆ¶å®Œæˆåï¼Œéœ€è¦è§„å®šå…è®¸å¸ƒçº¿åŒºåŸŸï¼Œåœ¨èœå•æ ä¸­é€‰æ‹©Edit-Z-Copyï¼ŒOptionsæ ä¸­é€‰æ‹©ROUTE KEEPIN-ALLï¼ŒOffsetè®¾ç½®ä¸ºæ‰€éœ€è¦çš„å®‰å…¨è·ç¦»ï¼Œä¾‹å¦‚20milï¼ŒFindæ ä¸­é€‰æ‹©Linesï¼Œä¹‹åç‚¹å‡»æ¿æ¡†çš„ä»»ä½•ä¸€ä¸ªè¾¹çº¿å³å¯ç”ŸæˆRoute Keepinè¾¹æ¡†ã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚&emsp;åŒç†ï¼Œè¿˜å¯ä»¥è®¾ç½®å…ƒå™¨ä»¶çš„å…è®¸æ‘†æ”¾åŒºåŸŸï¼Œå³Package Keepinã€‚è®¾ç½®è¯¥åŒºåŸŸå³è§„å®šäº†å…ƒå™¨ä»¶çš„æ‘†æ”¾èŒƒå›´ï¼Œä¸»è¦æ˜¯PCBè¿›è¡Œç„Šæ¥è¿‡ç¨‹ä¸­çš„é—´è·è¦æ±‚ï¼Œä»¥åŠé˜²æ­¢æ‹¼ç‰ˆä¹‹åéš”æ¿è¿‡ç¨‹æŸä¼¤å™¨ä»¶ã€‚ é€šè¿‡Constraint Managerè®¾ç½®åŸºæœ¬è§„åˆ™&emsp;ç¡¬ä»¶è®¾è®¡ä¸­ï¼Œå®ŒæˆåŸç†å›¾è®¾è®¡ä»…ä»…æ˜¯ç¬¬ä¸€æ­¥ï¼ŒPCBè®¾è®¡æ˜¯æ›´ä¸ºå…³é”®çš„ä¸€æ­¥ã€‚PCB layoutä¸­éœ€è¦å…³æ³¨ä¿¡å·å®Œæ•´æ€§ã€ç”µæºå®Œæ•´æ€§ã€ç”µç£è¾å°„ã€çƒ­è®¾è®¡ä»¥åŠç»“æ„è®¾è®¡ç­‰ç­‰è¦ç´ ï¼Œå› æ­¤è®¾è®¡åŸºæœ¬çš„è§„åˆ™éå¸¸é‡è¦ã€‚åœ¨Cadenceä¸­ï¼Œå¯ä»¥åœ¨åŸç†å›¾ä¸­å®Œæˆéƒ¨åˆ†è§„åˆ™è®¾è®¡ï¼Œä½†æ˜¯è€ƒè™‘åˆ°é€šå¸¸çš„è®¾è®¡æµç¨‹æ˜¯ç¡¬ä»¶å·¥ç¨‹å¸ˆå®ŒæˆåŸç†å›¾è®¾è®¡ï¼Œæä¾›ç½‘è¡¨ç»™CADå·¥ç¨‹å¸ˆå®ŒæˆPCB layoutå·¥ä½œã€‚é€šå¸¸æ¥è¯´ï¼Œç¡¬ä»¶å·¥ç¨‹å¸ˆç»™å‡ºå¸ƒå±€ä»¥åŠé˜»æŠ—æ§åˆ¶ç­‰è¦æ±‚ï¼ŒCADå·¥ç¨‹å¸ˆè®¾è®¡è§„åˆ™å¹¶å…·ä½“å®ç°ã€‚å› æ­¤ï¼Œæœ¬æ–‡çš„æ€è·¯æ˜¯ä¸åœ¨åŸç†å›¾ä¸­è®¾ç½®è§„åˆ™ï¼Œå…¨éƒ¨è§„åˆ™åœ¨PCBä¸­è®¾ç½®ã€‚&emsp;Constraint Managerå¯ä»¥åœ¨Setup-Constraintä¸­æ‰“å¼€ï¼Œæˆ–è€…ç›´æ¥ç‚¹å‡»èœå•æ CMå›¾æ ‡ã€‚Constraint Managerå…±Electricalã€Physicalã€Spacingã€Same net spacingã€Propertiesä¸DRCï¼Œå…¶ä¸­å‰4é¡¹è¾ƒä¸ºå¸¸ç”¨ã€‚&emsp;é€šå¸¸æƒ…å†µä¸‹ï¼Œå¯ä»¥æŒ‰ç…§ç±»å‹å¯¹èµ°çº¿ç½‘ç»œè¿›è¡Œåˆ†ç±»ï¼Œä¾‹å¦‚æŒ‰ç…§ç”µæºã€å°„é¢‘ã€é«˜é€Ÿä¿¡å·ç­‰å¯¹ç½‘ç»œåˆ†ç±»ï¼Œä¹‹åå¯ä»¥å¯¹åŒä¸€ç±»å‹ç½‘ç»œè®¾ç½®ä¸€è‡´è§„åˆ™ï¼Œå¯ä»¥æé«˜æ•ˆç‡ã€‚å› æ­¤é¦–å…ˆä»‹ç»å¯¹ç½‘ç»œåˆ†ç±»çš„æ–¹æ³•ã€‚ 1. å¯¹ç½‘ç»œè¿›è¡Œåˆ†ç±»&emsp;æ‰“å¼€Constraint Managerï¼Œé€‰æ‹©Objects-Create-Classï¼Œè¿›å…¥Net Classè®¾ç½®é¡µé¢ã€‚è¿™é‡Œä¸¾ä¾‹è®¾ç½®SPIæ¥å£çš„SYNCã€SCLKä¸DINä¸ºåŒä¸€ä¸ªclassã€‚&emsp;å°†Net Classå‘½åä¸ºSPIï¼ŒåŒæ—¶å‹¾é€‰â€œCreate for both physical and spacingâ€ï¼Œä»¥ä¾¿ç½‘ç»œåˆ†ç±»å¯ä»¥åœ¨ä¸åŒçš„è§„åˆ™ç¯å¢ƒä¸‹å‡å¯ä½¿ç”¨ã€‚ç‚¹å‡»OKè¿›å…¥ä¸‹ä¸€æ­¥è®¾ç½®ã€‚&emsp;åœ¨Physical-Net-All Layersä¸­é€‰æ‹©SPI Net Classï¼Œå³é”®é€‰æ‹©Net Class Membersï¼Œæ·»åŠ DINã€SCLKã€SYNCç½‘ç»œï¼Œç‚¹å‡»OKå®Œæˆè®¾ç½®ã€‚ 2. Physicalè§„åˆ™è®¾ç½®&emsp;Physicalå³ä¸ºç‰©ç†è§„åˆ™çš„è®¾ç½®ï¼Œé€šå¸¸ç”¨äºè®¾ç½®èµ°çº¿çš„å®½åº¦ä»¥åŠå·®åˆ†çº¿çš„ä¸€äº›æ€§è´¨ç­‰ã€‚å…³äºå·®åˆ†çº¿çš„è®¾ç½®å°†ä¼šå•ç‹¬å¼€ä¸€ç¯‡åšå®¢è®²è§£ï¼Œæ‰€ä»¥è¿™é‡Œä»…ä»…è¿›è¡Œçº¿å®½çš„è®¾ç½®ã€‚ä¸¾ä¾‹æ¥è¯´ï¼ŒPCBä¸­é€šå¸¸ç”µæºä¸ºäº†æ»¡è¶³ç”µæµè¦æ±‚ï¼Œçº¿å®½ä¸€èˆ¬å¤§äºä¿¡å·çº¿å®½åº¦ï¼Œæ‰€ä»¥å¯ä»¥è®¾ç½®ä¸€ä¸ªphysicalçº¦æŸè§„åˆ™ç”¨äºæ§åˆ¶ç”µæºçº¿çº¿å®½ã€‚&emsp;æ‰“å¼€Constraint Managerï¼Œé€‰ä¸­Physical Constraint Setï¼Œèœå•æ ä¸­é€‰æ‹©Objects-Create-Physical CSetï¼Œè¿›å…¥Net Classè®¾ç½®é¡µé¢ï¼Œå°†è§„åˆ™çº¦æŸå‘½åä¸ºPowerã€‚æ­¤æ—¶ï¼Œå¯ä»¥çœ‹åˆ°Physicalé¡µé¢ä¸‹å­˜åœ¨2æ¡çº¦æŸè§„åˆ™ï¼ŒDEFAULTä¸POWERã€‚DEFAULTè¡¨ç¤ºPCBçš„é»˜è®¤è§„åˆ™ï¼Œæ²¡æœ‰å•ç‹¬è®¾ç½®çº¦æŸè§„åˆ™çš„ç½‘ç»œå°†éµå¾ªæ­¤è§„åˆ™ï¼Œæ­¤æ—¶å°†çº¿å®½è®¾ç½®ä¸º6milï¼›POWERä¸ºè®¾ç½®çš„ç”µæºç½‘ç»œè§„åˆ™ï¼Œè®¾ç½®çº¿å®½ä¸º12milã€‚&emsp;ä¹‹åå¯¹ç›¸åº”ç½‘ç»œåº”ç”¨è§„åˆ™ã€‚å¯¹ç½‘ç»œP5Våº”ç”¨POWERè§„åˆ™ï¼Œå…¶ä½™ç½‘ç»œé»˜è®¤ä¸ºDEFAULTè§„åˆ™ã€‚å¯ä»¥çœ‹åˆ°å±äºåŒä¸€ä¸ªClassçš„ç½‘ç»œå¯ä»¥ç»Ÿä¸€åº”ç”¨è§„åˆ™ã€‚ 3. Spacingè§„åˆ™è®¾ç½®&emsp;Physicalå³ä¸ºé—´è·è§„åˆ™çš„è®¾ç½®ï¼Œé€šå¸¸ç”¨äºè®¾ç½®æŒ‡å®šç½‘ç»œä¸å…¶å®ƒç½‘ç»œã€è¿‡å­”åŠæ•·é“œç­‰çš„é—´è·ã€‚ä¸ç‰©ç†è§„åˆ™è®¾ç½®è¿‘ä¼¼ï¼Œå¯ä»¥é’ˆå¯¹æŒ‡å®šç½‘ç»œè®¾ç½®ç›¸åº”è§„åˆ™ï¼Œä¾‹å¦‚POWERç½‘ç»œä¸å…¶å®ƒç½‘ç»œçš„é—´è·å¯ä»¥é€‚å½“å¢å¤§ã€‚ 4. RegionåŒºåŸŸè®¾ç½®&emsp;PCB layoutä¸­ç»å¸¸é‡åˆ°çš„ä¸€ä¸ªé—®é¢˜æ˜¯ï¼šå¯¹äºCPUä»¥åŠå…¶å®ƒé«˜å¯†åº¦å°è£…åŒºåŸŸå¸ƒå±€æ—¶ï¼Œéœ€è¦é€‚å½“å‡å°çº¿å®½ä¸èµ°çº¿è·ç¦»ç­‰ï¼Œè€Œåœ¨PCBå…¶å®ƒåŒºåŸŸï¼Œåº”å½“ä¿è¯è¶³å¤Ÿçš„çº¿å®½ä¸çº¿è·ä»¥è·å–æœ€ä½³åŠ å·¥å¯é æ€§ã€‚Allegroä¸­å¯ä»¥è®¾ç½®ç‹¬ç«‹çš„åŒºåŸŸæ¥è§£å†³æ­¤é—®é¢˜ã€‚&emsp;é€‰æ‹©Objects-Create-Regionï¼Œè®¾ç½®ä¸ºDGK8ï¼Œæ­¤æ—¶DGK8çš„è§„åˆ™çº¦æŸå¯ä»¥ç‹¬ç«‹è®¾ç½®ï¼Œå¯ä»¥è°ƒæ•´çº¿å®½ä¸çº¿è·ã€‚&emsp;ä¹‹åï¼Œåœ¨PCB layoutç•Œé¢ä¸­é€‰æ‹©Shape-Polygonï¼ŒOPtionsä¸­é€‰æ‹©Constraint Regionä»¥åŠå¯¹åº”çš„åŒºåŸŸDKG8ï¼Œå®ŒæˆåŒºåŸŸè¾¹æ¡†çš„è®¾ç½®å³å¯ã€‚","categories":[{"name":"EDA","slug":"EDA","permalink":"http://jiaodi.tech/categories/EDA/"}],"tags":[{"name":"Cadence","slug":"Cadence","permalink":"http://jiaodi.tech/tags/Cadence/"},{"name":"Allegro","slug":"Allegro","permalink":"http://jiaodi.tech/tags/Allegro/"},{"name":"é«˜é€Ÿç”µè·¯","slug":"é«˜é€Ÿç”µè·¯","permalink":"http://jiaodi.tech/tags/é«˜é€Ÿç”µè·¯/"},{"name":"å°è£…","slug":"å°è£…","permalink":"http://jiaodi.tech/tags/å°è£…/"}]},{"title":"ä½¿ç”¨Ultra Librarianåˆ›å»ºCadenceåŸç†å›¾ä¸PCBå°è£…","slug":"cadence-allegro-package","date":"2017-04-04T07:49:27.000Z","updated":"2018-03-15T13:46:14.054Z","comments":true,"path":"2017/04/04/cadence-allegro-package/","link":"","permalink":"http://jiaodi.tech/2017/04/04/cadence-allegro-package/","excerpt":"&emsp;å…ƒå™¨ä»¶çš„å°è£…åˆ¶ä½œæ˜¯åŸç†å›¾ä¸PCBè®¾è®¡çš„ç¬¬ä¸€æ­¥ã€‚è‡ªè¡Œè®¾è®¡å°è£…å›ºç„¶å¯è¡Œï¼Œä½†é€šå¸¸è¦èŠ±è´¹ä¸€å®šæ—¶é—´ã€‚ä½¿ç”¨èŠ¯ç‰‡å‚å®¶æä¾›çš„å°è£…åº“æ˜¯ä¸€ä¸ªä¾¿æ·çš„æ‰‹æ®µï¼Œå°¤å…¶å¯¹äºå…·æœ‰é€šç”¨æ€§çš„PCBå°è£…ã€‚ä¾‹å¦‚å¾·å·ä»ªå™¨å…¬å¸ä¸ Accelerated Designså…¬å¸åˆä½œåˆ¶ä½œäº†è‡ªå·±å‡ ä¹å…¨éƒ¨å…ƒå™¨ä»¶çš„å°è£…åº“ï¼Œæ•´åˆä¸ºbxlæ–‡ä»¶ï¼Œå¯ä»¥ä½¿ç”¨Ultra Librarianåˆ›å»ºCadenceåŸç†å›¾ä¸PCBå°è£…ã€‚ &emsp;ä»¥C2000å¤„ç†å™¨TMS320F28069èŠ¯ç‰‡ä¸ºä¾‹ï¼Œæœ¬æ–‡å°†ä»‹ç»ä½¿ç”¨è¯¥å·¥å…·ç”Ÿæˆå°è£…åº“çš„æ–¹æ³•ã€‚","text":"&emsp;å…ƒå™¨ä»¶çš„å°è£…åˆ¶ä½œæ˜¯åŸç†å›¾ä¸PCBè®¾è®¡çš„ç¬¬ä¸€æ­¥ã€‚è‡ªè¡Œè®¾è®¡å°è£…å›ºç„¶å¯è¡Œï¼Œä½†é€šå¸¸è¦èŠ±è´¹ä¸€å®šæ—¶é—´ã€‚ä½¿ç”¨èŠ¯ç‰‡å‚å®¶æä¾›çš„å°è£…åº“æ˜¯ä¸€ä¸ªä¾¿æ·çš„æ‰‹æ®µï¼Œå°¤å…¶å¯¹äºå…·æœ‰é€šç”¨æ€§çš„PCBå°è£…ã€‚ä¾‹å¦‚å¾·å·ä»ªå™¨å…¬å¸ä¸ Accelerated Designså…¬å¸åˆä½œåˆ¶ä½œäº†è‡ªå·±å‡ ä¹å…¨éƒ¨å…ƒå™¨ä»¶çš„å°è£…åº“ï¼Œæ•´åˆä¸ºbxlæ–‡ä»¶ï¼Œå¯ä»¥ä½¿ç”¨Ultra Librarianåˆ›å»ºCadenceåŸç†å›¾ä¸PCBå°è£…ã€‚ &emsp;ä»¥C2000å¤„ç†å™¨TMS320F28069èŠ¯ç‰‡ä¸ºä¾‹ï¼Œæœ¬æ–‡å°†ä»‹ç»ä½¿ç”¨è¯¥å·¥å…·ç”Ÿæˆå°è£…åº“çš„æ–¹æ³•ã€‚ Ultra Librariançš„å®‰è£…ä¸bxlæ–‡ä»¶çš„ä¸‹è½½&emsp;Ultra Librarianè½¯ä»¶å¯ä»¥åœ¨tiå®˜ç½‘ç›´æ¥ä¸‹è½½ã€‚åœ¨tiå®˜ç½‘æœç´¢TMS320F28069ï¼Œåœ¨èŠ¯ç‰‡ä¸»é¡µæ‰“å¼€è´¨é‡ä¸å°è£…é€‰é¡¹ï¼Œé¡µé¢ä¸‹æ–¹å¯ä»¥çœ‹åˆ°bxlæ–‡ä»¶ä¸Ultra Librarianè½¯ä»¶çš„ä¸‹è½½é“¾æ¥ã€‚&emsp;Ultra Librarianè½¯ä»¶æŒ‰ç…§é»˜è®¤å®‰è£…å³å¯ã€‚&emsp;TMS320F28069å°è£…ä¸­ï¼Œä¸‹è½½LQFP100ä¸ºä¾‹ã€‚ ä½¿ç”¨Ultra Librarianç”ŸæˆCadenceåŸç†å›¾ä¸PCBå°è£…&emsp;Ultra Librarianå¯ä»¥ç›´æ¥æ‰“å¼€bxlæ–‡ä»¶ï¼Œå…¶ä¸­å·¦ä¾§ä¸ºPCBå°è£…é¢„è§ˆï¼Œå³ä¾§ä¸ºåŸç†å›¾å°è£…é¢„è§ˆï¼ˆä¸Šé¢è¿˜æœ‰ä¸€ä¸ª3Då°è£…ï¼Œæˆ‘ä¸çŸ¥é“æ˜¯å“ªé‡Œæ¥çš„â€¦ï¼‰ã€‚&emsp;Ultra Librarianè½¯ä»¶è®¾ç½®å¦‚ä¸‹ï¼šå…¶ä¸­å‹¾é€‰Cadence Allegroé€‰é¡¹ï¼Œæ³¨æ„é€‰æ‹©è‡ªå·±çš„Cadenceè½¯ä»¶ç‰ˆæœ¬ï¼Œæœ¬æ–‡ä»¥16.6ç‰ˆæœ¬ä¸ºä¾‹ã€‚è¯¥é€‰é¡¹å¯¹åº”PCBå°è£…ï¼›åŒæ—¶å‹¾é€‰Cadence Allegro Captureé€‰é¡¹ï¼Œè¯¥é€‰é¡¹å¯¹åº”åŸç†å›¾å°è£…ã€‚&emsp;ç‚¹å‡»Step 3. Export to Selected Toolsç”Ÿæˆå°è£…ã€‚PCBå°è£…ç”Ÿæˆè¿‡ç¨‹ä¸­ï¼Œéœ€è¦è°ƒç”¨Allegroè½¯ä»¶ã€‚å¤„ç†è¿‡ç¨‹å¯èƒ½æ¯”è¾ƒé•¿ï¼Œè¯·è€å¿ƒç­‰å¾…ã€‚ PCBå°è£…çš„å¤„ç†ä»¥åŠåŠ å…¥3Dæ¨¡å‹&emsp;å°è£…ç”Ÿæˆä¹‹åï¼Œå¯ä»¥æ‰“å¼€Ultra Librarianè¾“å‡ºæ–‡ä»¶å¤¹ï¼ˆUltraLibrarian\\Library\\Exported\\Allegroï¼‰ä¸­å¯¹åº”æ—¶é—´ç”Ÿæˆçš„æ–‡ä»¶ï¼Œå…¶ä¸­.dra .psm .padæ–‡ä»¶å‡ä¸ºå¿…é¡»æ–‡ä»¶ï¼Œå…¶ä¸­pz100ä»£è¡¨ä¸­ç­‰å¯†åº¦å°è£…ï¼Œpz100-lä»£è¡¨é«˜å¯†åº¦å°è£…ï¼Œpz100-mä»£è¡¨ä½å¯†åº¦å°è£…ã€‚æ­¤æ—¶å¯ä»¥ç”¨Allegroè½¯ä»¶æ‰“å¼€draæ–‡ä»¶æŸ¥çœ‹å…·ä½“å°è£…ã€‚&emsp;ä¸ºäº†ä¾¿äºæ•´ç†ï¼Œå¯ä»¥å°†ä¸Šè¿°æ–‡ä»¶å¤åˆ¶åˆ°è‡ªå·±çš„å°è£…åº“æ–‡ä»¶å¤¹ä¸­ï¼Œæœ¬æ–‡ä¸­å°†å…¶å¤åˆ¶åˆ°C:\\Cadence\\mypcblibç›®å½•ä¸‹ã€‚&emsp;ä¸ºäº†ä½¿å¾—PCBå°è£…æ›´æ¥è¿‘äºå®é™…æ•ˆæœï¼Œå¯ä»¥ä¸‹è½½å…¶3Då¤–å½¢åŠ å…¥åˆ°å°è£…ä¸­ã€‚è¿™é‡Œæ¨èåˆ°3D ContentCentralä¸‹è½½3Då°è£…ã€‚&emsp;æœç´¢LQFP100ï¼Œé€‰æ‹©åˆé€‚çš„å™¨ä»¶ã€‚&emsp;æ‰“å¼€å™¨ä»¶é¡µé¢ï¼Œé€‰æ‹©STEPæ–‡ä»¶ä¸‹è½½å¹¶ä¿å­˜åœ¨3Då°è£…æ–‡ä»¶å¤¹ä¸­ï¼Œæœ¬æ–‡å¯¹åº”ä¸ºC:\\Cadence\\stepã€‚&emsp;æ‰“å¼€Allegroè½¯ä»¶ï¼Œæ·»åŠ steppathè·¯å¾„ã€‚&emsp;æ‰“å¼€pz100å°è£…ï¼Œé€‰æ‹©setup-Step Packaging Mappingï¼Œé€‰æ‹©LQFP100å¹¶è¿›è¡Œæ–¹å‘ä½ç½®çš„å¾®è°ƒï¼Œç‚¹å‡»Saveè¿›è¡Œä¿å­˜å¹¶é€€å‡ºã€‚æ­¤æ—¶ï¼Œå¦‚æœAllegroè°ƒç”¨è¯¥PCBå°è£…ï¼Œåˆ™ä¼šè‡ªåŠ¨åŠ è½½å…¶3Dæ¨¡å‹ã€‚ åŸç†å›¾å°è£…çš„å¤„ç†&emsp;Ultra Librarianç”Ÿæˆçš„å°è£…éœ€è¦ç»è¿‡Cadenceå¯¼å…¥æ–¹å¯ä½¿ç”¨ã€‚æ‰“å¼€Cadence Captureè½¯ä»¶ï¼Œé€‰æ‹©file-Import Designï¼Œæ‰“å¼€UltraLibrarian\\Library\\Exported\\Orcadè·¯å¾„ä¸‹å¯¹åº”çš„edf cfgæ–‡ä»¶ï¼Œå¦‚å›¾æ‰€ç¤ºã€‚&emsp;ç”Ÿæˆå®Œæ¯•åï¼Œæ–‡ä»¶å¤¹å†…ä¼šå‡ºç°OLBï¼Œå³ä¸ºåŸç†å›¾åº“æ–‡ä»¶ã€‚ä¸ºäº†æ–¹ä¾¿èµ·è§ï¼Œå¯ä»¥å°†åº“é‡Œçš„å…ƒå™¨ä»¶å¤åˆ¶åˆ°è‡ªå»ºåº“ä¸­ï¼ŒåŒæ—¶æŒ‡å®šPCBå°è£…ä¸ºpz100ã€‚ æ–°å»ºå·¥ç¨‹è¿›è¡Œæµ‹è¯•&emsp;æ–°å»ºä¸€ä¸ªå·¥ç¨‹è¿›è¡ŒåŸç†å›¾ä¸PCBå°è£…æµ‹è¯•ã€‚&emsp;åŸç†å›¾ä¸­ä»…ä»…æ”¾ç½®F28069ï¼Œç„¶åç”Ÿæˆç½‘ç»œè¡¨å¹¶ç”¨Allegroè½¯ä»¶æ‰“å¼€ã€‚æ­¤æ—¶å¯ä»¥åœ¨Allegroè½¯ä»¶ä¸­å¯¹è¯¥å™¨ä»¶è¿›è¡Œæ”¾ç½®ï¼Œé€‰æ‹©3Dæ–¹å¼è¿›è¡ŒæŸ¥çœ‹ï¼Œå¯ä»¥çœ‹åˆ°å™¨ä»¶çš„3Dæ•ˆæœã€‚","categories":[{"name":"EDA","slug":"EDA","permalink":"http://jiaodi.tech/categories/EDA/"}],"tags":[{"name":"Cadence","slug":"Cadence","permalink":"http://jiaodi.tech/tags/Cadence/"},{"name":"Allegro","slug":"Allegro","permalink":"http://jiaodi.tech/tags/Allegro/"},{"name":"å°è£…","slug":"å°è£…","permalink":"http://jiaodi.tech/tags/å°è£…/"}]},{"title":"æ–°å»ºä¸€ä¸ªC2000å·¥ç¨‹","slug":"æ–°å»ºä¸€ä¸ªC2000å·¥ç¨‹","date":"2017-03-06T05:13:46.000Z","updated":"2018-03-15T13:47:19.445Z","comments":true,"path":"2017/03/06/æ–°å»ºä¸€ä¸ªC2000å·¥ç¨‹/","link":"","permalink":"http://jiaodi.tech/2017/03/06/æ–°å»ºä¸€ä¸ªC2000å·¥ç¨‹/","excerpt":"&emsp;å®‰è£…å¥½å¼€å‘ç¯å¢ƒCCSä¸å¯¹åº”è½¯ä»¶å¥—ä»¶controlSUITEä¹‹åï¼Œå¯ä»¥å°è¯•æ–°å»ºä¸€ä¸ªCCSå·¥ç¨‹ã€‚æ–°å»ºçš„CCSå·¥ç¨‹ç›®æ ‡æ˜¯ï¼šå°½å¯èƒ½ä½¿è¯¥å·¥ç¨‹æ¨¡å—æ›´æ–¹ä¾¿ä½¿ç”¨ï¼Œæ¸…æ™°æ˜äº†ï¼ŒåŒæ—¶ä¾¿äºç§»æ¤ã€‚","text":"&emsp;å®‰è£…å¥½å¼€å‘ç¯å¢ƒCCSä¸å¯¹åº”è½¯ä»¶å¥—ä»¶controlSUITEä¹‹åï¼Œå¯ä»¥å°è¯•æ–°å»ºä¸€ä¸ªCCSå·¥ç¨‹ã€‚æ–°å»ºçš„CCSå·¥ç¨‹ç›®æ ‡æ˜¯ï¼šå°½å¯èƒ½ä½¿è¯¥å·¥ç¨‹æ¨¡å—æ›´æ–¹ä¾¿ä½¿ç”¨ï¼Œæ¸…æ™°æ˜äº†ï¼ŒåŒæ—¶ä¾¿äºç§»æ¤ã€‚ å‡†å¤‡å·¥ä½œ&emsp;å®‰è£…å®Œæ¯•çš„CCSä¸controlSUITEï¼Œå¯ä»¥å‚ç…§å®‰è£…CCSä¸controlSUITEã€‚ æ–°å»ºä¸€ä¸ªç©ºé¡¹ç›® å¯åŠ¨CCS v5ï¼Œé€‰æ‹©å·¥ä½œç©ºé—´ã€‚ é€‰æ‹©èœå•æ File-&gt;New-&gt;CCS Projectã€‚è¿›å…¥New CCS Projectè®¾ç½®é€‰é¡¹ã€‚ &emsp;Targetï¼šç›®æ ‡å™¨ä»¶ï¼Œå·¦æ¡†é€‰æ‹©2806x Piccoloï¼Œå³æ¡†é€‰æ‹©TMS320F28069ï¼› &emsp;Connectionï¼šä»¿çœŸå™¨ï¼Œé€‰æ‹©Texs Instruments XDS100v2 USB Debug Probeï¼› &emsp;Project nameï¼šæ–°å»ºé¡¹ç›®çš„åç§°ï¼Œç¤ºä¾‹è¾“å…¥F28069Emptyã€‚å°†ä½œä¸ºåç»­çš„å·¥ç¨‹æ¨¡æ¿ä½¿ç”¨ï¼› &emsp;å‹¾é€‰Use default locationï¼› &emsp;Compiler versionï¼šç¼–è¯‘å™¨ç‰ˆæœ¬ï¼Œé‡‡ç”¨é»˜è®¤å€¼TI v6.2.10ã€‚ &emsp;Advance settingsä¿æŒé»˜è®¤å³å¯ï¼› &emsp;Project templates and examplesï¼šé¡¹ç›®æ¨¡æ¿ï¼Œé€‰æ‹©Empty Projectï¼ˆwith main.cï¼‰ã€‚ &emsp;é€‰æ‹©finishå®Œæˆç©ºé¡¹ç›®å·¥ç¨‹çš„å»ºç«‹ã€‚ ç©ºé¡¹ç›®å»ºç«‹å®Œæˆåï¼Œå¯ä»¥çœ‹åˆ°Project Exploreä¸­å­˜åœ¨F28069Emptyå·¥ç¨‹ã€‚CCSå·²ç»è‡ªåŠ¨åŠ å…¥äº†é“¾æ¥å™¨å‘½ä»¤æ–‡ä»¶28069_RAM_lnk.cmdã€‚åŒæ—¶main.cä¸­å­˜åœ¨ä¸€ä¸ªç©ºçš„mainå‡½æ•°ã€‚ å¢åŠ å¤–è®¾ä¸åˆå§‹åŒ–æ–‡ä»¶&emsp;åœ¨ç©ºé¡¹ç›®å»ºç«‹å®Œæˆåï¼Œå°†éœ€è¦ä½¿ç”¨åˆ°çš„å¤´æ–‡ä»¶ä¸æºæ–‡ä»¶å¯¼å…¥ï¼Œæ‰èƒ½æ­£å¸¸ä½¿ç”¨å…¶ä¸­çš„åˆå§‹åŒ–ä¸å¤–è®¾é©±åŠ¨å‡½æ•°ã€‚ å¢åŠ å¤´æ–‡ä»¶ å•å‡»é€‰ä¸­F28069Emptyç©ºé¡¹ç›®ã€‚å³é”®ï¼Œé€‰æ‹©New-&gt;Folderï¼Œè¿›å…¥æ–°å»ºæ–‡ä»¶å¤¹ç•Œé¢ã€‚åœ¨Folder nameæ è¾“å…¥includeï¼Œä½œä¸ºå¤´æ–‡ä»¶æ–‡ä»¶å¤¹ã€‚ é€‰æ‹©controlSUITEå®‰è£…ç›®å½•ä¸‹controlSUITE\\device_support\\f2806x\\v136\\F2806x_headers\\includeï¼Œé€‰æ‹©å…¶ä¸­æ‰€æœ‰å¤´æ–‡ä»¶å¹¶å¤åˆ¶ã€‚å³é”®F28069Emptyç©ºé¡¹ç›®ä¸‹includeæ–‡ä»¶å¤¹ï¼Œé€‰æ‹©pasteç²˜è´´æŒ‡ä»¤ã€‚æ­¤æ—¶ï¼Œå¤´æ–‡ä»¶å°†å¤åˆ¶äºincludeæ–‡ä»¶å¤¹ä¸­ã€‚ é€‰æ‹©controlSUITEå®‰è£…ç›®å½•ä¸‹controlSUITE\\device_support\\f2806x\\v136\\F2806x_common\\includeï¼Œé€‰æ‹©å…¶ä¸­æ‰€æœ‰å¤´æ–‡ä»¶ï¼Œå¤åˆ¶åˆ°includeæ–‡ä»¶å¤¹ä¸­ã€‚ å¢åŠ æºæ–‡ä»¶ å•å‡»é€‰ä¸­F28069Emptyç©ºé¡¹ç›®ã€‚å³é”®ï¼Œé€‰æ‹©New-&gt;Folderï¼Œè¿›å…¥æ–°å»ºæ–‡ä»¶å¤¹ç•Œé¢ã€‚åœ¨Folder nameæ è¾“å…¥sourceï¼Œä½œä¸ºæºæ–‡ä»¶æ–‡ä»¶å¤¹ã€‚ é€‰æ‹©controlSUITEå®‰è£…ç›®å½•ä¸‹controlSUITE\\device_support\\f2806x\\v136\\F2806x_common\\sourceï¼Œé€‰æ‹©å…¶ä¸­(é™¤F2806x_CSMPasswords.asmã€F2806x_SWPrioritizedDefaultIsr.cä¸F2806x_SWPrioritizedPieVect.cå¤–æ‰€æœ‰)æºæ–‡ä»¶å¹¶å¤åˆ¶ã€‚å³é”®F28069Emptyç©ºé¡¹ç›®ä¸‹sourceæ–‡ä»¶å¤¹ï¼Œé€‰æ‹©pasteç²˜è´´æŒ‡ä»¤ã€‚æ­¤æ—¶ï¼Œæºæ–‡ä»¶å°†å¤åˆ¶äºincludeæ–‡ä»¶å¤¹ä¸­ã€‚ æ³¨æ„ï¼šå™¨ä»¶å¯åŠ¨æ–‡ä»¶F2806x_CodeStartBranch.asmä¸å»¶æ—¶å‡½æ•°æºæ–‡ä»¶F2806x_usDelay.asmä¹Ÿå·²ç»å¤åˆ¶ä¸sourceæ–‡ä»¶å¤¹ä¸‹ã€‚ å¢åŠ ä½åŸŸç»“æ„ä½“æ”¯æŒæºæ–‡ä»¶ å¤åˆ¶controlSUITE\\device_support\\f2806x\\v136\\F2806x_headers\\sourceä¸­F2806x_GlobalVariableDefs.cæ–‡ä»¶ï¼Œæ”¾åˆ°å·¥ç¨‹å·¥ç¨‹ç›®å½•sourceæ–‡ä»¶å¤¹ä¸‹ã€‚ å¤åˆ¶controlSUITE\\device_support\\f2806x\\v136\\F2806x_headers\\cmdä¸­F2806x_Headers_nonBIOS.cmdæ–‡ä»¶ï¼Œæ”¾åˆ°å·¥ç¨‹æ ¹ç›®å½•æ–‡ä»¶å¤¹ä¸‹ã€‚å³å¤åˆ¶åï¼Œå³é”®F28069Emptyç©ºé¡¹ç›®é€‰æ‹©pasteæŒ‡ä»¤ã€‚ è®¾ç½®åŒ…å«é€‰é¡¹&emsp;å°½ç®¡å·²ç»å¢åŠ äº†å¤´æ–‡ä»¶ä¸æºæ–‡ä»¶ï¼Œä½†æ˜¯è¿˜éœ€è¦è®¾ç½®åŒ…å«è·¯å¾„ï¼Œç¼–è¯‘å™¨æ‰èƒ½æœç´¢åˆ°éœ€è¦çš„æ–‡ä»¶ã€‚&emsp;åœ¨æ–°å»ºF28069Emptyç©ºé¡¹ç›®å³é”®ï¼Œé€‰æ‹©å±æ€§ã€‚é€‰æ‹©Build-&gt;C2000 Compiler-&gt;Include Optionsã€‚&emsp;å•å‡»Addï¼Œé€‰æ‹©Workspaceâ€¦ï¼ˆå³é€‰æ‹©ç›¸å¯¹è·¯å¾„ï¼‰ï¼Œé€‰æ‹©æ–°å»ºF28069Emptyç©ºé¡¹ç›®ä¸‹çš„includeæ–‡ä»¶å¤¹ã€‚ &emsp;ç‚¹å‡»OKï¼Œå›å¤åˆ°å±æ€§è®¾ç½®ç•Œé¢ï¼Œå†æ¬¡ç‚¹å‡»OKç¡®è®¤ã€‚&emsp;ç‚¹å‡»buildï¼Œè¯¥é¡¹ç›®å¯ä»¥ç¼–è¯‘é€šè¿‡ã€‚ ä½¿ç”¨æ–°å·¥ç¨‹è¿›è¡ŒLEDé—ªçƒå®éªŒ&emsp;æ–°å»ºé¡¹ç›®ä¸­mainä¸ºç©ºå‡½æ•°ã€‚ä¸ºäº†æ£€éªŒåˆ›å»ºçš„å·¥ç¨‹æ˜¯å¦å¯ä»¥æ­£å¸¸ä½¿ç”¨ï¼Œè¿™é‡Œè¿›è¡Œç®€å•çš„æµ‹è¯•ã€‚&emsp;åœ¨è¿™é‡Œï¼Œå°†main.cæ–‡ä»¶å†…å®¹æ›¿æ¢ä¸ºå¦‚ä¸‹å†…å®¹ã€‚ 1234567891011121314151617181920212223242526272829#include \"DSP28x_Project.h\" void main(void)&#123; InitSysCtrl(); DINT; InitPieCtrl(); IER = 0x0000; IFR = 0x0000; InitPieVectTable(); EALLOW; GpioCtrlRegs.GPAMUX1.all = 0x00000000; // All GPIO GpioCtrlRegs.GPAMUX2.all = 0x00000000; // All GPIO GpioCtrlRegs.GPBMUX1.all = 0x00000000; // All GPIO GpioCtrlRegs.GPADIR.all = 0xCFFFFFFF; // All outputs GpioCtrlRegs.GPBDIR.all = 0x0000000F; // All outputs EDIS; for(;;) &#123; GpioDataRegs.GPADAT.all =0xffffffff; //èµ‹å€¼ä¿®æ”¹ä¸º0xffffffff GpioDataRegs.GPBDAT.all =0xffffffff; //èµ‹å€¼ä¿®æ”¹ä¸º0xffffffff DELAY_US(1000000); GpioDataRegs.GPADAT.all =0x0; //èµ‹å€¼ä¿®æ”¹ä¸º0x0 GpioDataRegs.GPBDAT.all =0x0; //èµ‹å€¼ä¿®æ”¹ä¸º0x0 DELAY_US(1000000); &#125;&#125; &emsp;å•å‡»buildç¼–è¯‘å·¥ç¨‹ï¼Œå·¥ç¨‹å¯ä»¥ç¼–è¯‘é€šè¿‡ã€‚&emsp;å°†F28069æ ¸å¿ƒæ¿è¿æ¥åˆ°ç”µè„‘ï¼Œå°†å·¥ç¨‹debugä¸‹è½½åˆ°æ ¸å¿ƒæ¿ã€‚è¿è¡Œå·¥ç¨‹ï¼Œå¯ä»¥çœ‹åˆ°LEDå¼€å§‹é—ªçƒã€‚&emsp;å¯ä»¥è¯æ˜ï¼Œå»ºç«‹å·¥ç¨‹çš„æ–¹æ³•æ˜¯å¯è¡Œçš„ã€‚ å¯¹å·¥ç¨‹è¿›è¡Œä¸€ç‚¹ä¼˜åŒ–ä¿®æ”¹&emsp;æŒ‰ç…§ä¸Šè¿°æ­¥éª¤ï¼Œå»ºç«‹äº†ä¸€ä¸ªå¯ç”¨çš„å·¥ç¨‹æ¨¡æ¿ã€‚ä»¥ä¸‹ï¼Œä¸ºäº†åç»­å­¦ä¹ çš„ä¾¿æ·æ€§ï¼Œéœ€è¦å¯¹å·¥ç¨‹è¿›è¡Œå°‘è®¸ä¿®æ”¹ã€‚ å®šä¹‰æ•°æ®ç±»å‹å¤´æ–‡ä»¶&emsp;ä¸åŒçš„å™¨ä»¶å¹³å°å’Œä¸åŒçš„ç¼–è¯‘å™¨ï¼Œå¯èƒ½å…·æœ‰ä¸åŒçš„æ•°æ®ç±»å‹ï¼Œæˆ–è€…åŒåçš„æ•°æ®ç±»å‹å…·æœ‰ä¸åŒçš„é•¿åº¦ã€‚ä¸ºäº†ç¨‹åºæ›´æ˜“äºç§»æ¤ä½¿ç”¨ï¼Œåº”è¯¥åœ¨ç¨‹åºè®¾è®¡ä¸­å°½å¯èƒ½æ¶ˆé™¤è¿™ç§å·®å¼‚ã€‚&emsp;å› æ­¤ï¼Œå¯ä»¥å°è¯•å»ºç«‹æ•°æ®ç±»å‹å®šä¹‰ã€‚&emsp;å³é”®F28069Emptyå·¥ç¨‹ï¼Œé€‰æ‹©New-&gt;Header Fileï¼Œä¸ºå·¥ç¨‹æ·»åŠ ä¸€ä¸ªå¤´æ–‡ä»¶ã€‚æ–‡ä»¶åå®šä¹‰ä¸ºmytype.hã€‚&emsp;åœ¨mytype.hä¸­ï¼Œè¾“å…¥å¦‚ä¸‹æ•°æ®ç±»å‹å®šä¹‰ã€‚ 1234567891011121314151617181920212223242526272829//Optimizing C C++ User's Guide.pdf//chapter 6.4 Data Types#ifndef MYTYPE_H_#define MYTYPE_H_ typedef char int8; //in fact,16 bits.//typedef unsigned char Uint8;//in fact,16 bits.typedef unsigned char uint8;//in fact,16 bits.//typedef int int16;//typedef unsigned int Uint16;typedef unsigned int uint16;//typedef long int32;//typedef unsigned long Uint32;typedef unsigned long uint32;//typedef long long int64;//typedef unsigned long long Uint64;typedef unsigned long long uint64;typedef volatile int8 vint8;typedef volatile uint8 vuint8;typedef volatile int16 vint16;typedef volatile uint16 vuint16;typedef volatile int32 vint32;typedef volatile uint32 vuint32;typedef volatile long long vint64;typedef volatile unsigned long long vuint64;//typedef float float32;//typedef long double float64; #endif /* MYTYPE_H_ */ &emsp;æŸ¥é˜…Optimizing C C++ User&#39;s Guide.pdfæ‰‹å†Œ6.4èŠ‚data typeå¯ä»¥çœ‹åˆ°ç›¸å…³çš„æ•°æ®ç±»å‹å®šä¹‰ã€‚åŸºäºæ­¤ç¡®å®šæ•°æ®ç±»å‹çš„å®šä¹‰ã€‚&emsp;å…¶ä¸­éƒ¨åˆ†å®šä¹‰è¢«æ³¨é‡Šæ‰äº†ï¼ŒåŸå› åœ¨äºå¼•å…¥çš„å¤´æ–‡ä»¶ä¸­ï¼Œå·²ç»æŒ‰ç…§ä¸€è‡´çš„æ–¹æ³•å®šä¹‰äº†ï¼Œè¿™é‡Œä¸èƒ½å†æ¬¡é‡å¤å®šä¹‰ã€‚ å®šä¹‰å…¬ç”¨åŒ…å«å¤´æ–‡ä»¶&emsp;åœ¨åç»­å®éªŒä¸­ï¼Œä¸ºäº†å¢åŠ ä»£ç çš„å¯è¯»æ€§ï¼Œç¨‹åºå°†è¿›è¡Œæ¨¡å—åŒ–è®¾è®¡ã€‚ç®€å•åœ°è¯´ï¼Œå¯¹äºä¸åŒå¤–è®¾ï¼Œè®¾ç½®å•ç‹¬çš„æ–‡ä»¶å¤¹å­˜å‚¨å¤´æ–‡ä»¶ä¸æºæ–‡ä»¶ã€‚&emsp;å¯¹äºæ¯ä¸€ä¸ªå¤–è®¾å‡éœ€è¦å¼•å…¥èŠ¯ç‰‡æ”¯æŒæ–‡ä»¶ï¼Œä¾‹å¦‚ï¼Œä½åŸŸç»“æ„ä½“æ”¯æŒæ–‡ä»¶æ¯ä¸€ä¸ªå¤–è®¾å‡éœ€è¦ä½¿ç”¨ã€‚ä¸ºæ­¤ï¼Œå¯ä»¥è®¾ç½®ä¸€ä¸ªå…¬å…±åŒ…å«æ–‡ä»¶common.hï¼Œè¯¥æ–‡ä»¶åœ¨æ¯ä¸ªå¤–è®¾æ–‡ä»¶å¤¹ä¸­è¢«å¼•å…¥ã€‚&emsp;åœ¨é¡¹ç›®æ ¹ç›®å½•ä¸‹æ·»åŠ åä¸ºcommon.hçš„å¤´æ–‡ä»¶ï¼Œå¹¶æ·»åŠ å¦‚ä¸‹å†…å®¹ã€‚ 12345678#ifndef COMMON_H_#define COMMON_H_ #include \"include\\DSP28x_Project.h\" #include \"mytype.h\" #endif /* COMMON_H_ */ å®šä¹‰æ€»åŒ…å«æ–‡ä»¶&emsp;æŒ‰ç…§æ–‡ä»¶å¤¹åŒºåˆ†å¤–è®¾åï¼Œéœ€è¦å®šä¹‰æ€»çš„åŒ…å«æ–‡ä»¶ï¼Œä¾¿äºç¨‹åºæ­£å¸¸è°ƒç”¨ä¸åŒå¤–è®¾çš„ä¸åŒå‡½æ•°ã€‚ä¾‹å¦‚ï¼Œä¸€èˆ¬æ¥è®²ï¼Œmainä¸»ç¨‹åºéœ€è¦è®¿é—®å…¨éƒ¨å¤–è®¾çš„å‡½æ•°ã€‚&emsp;å¦‚æœæ¯ä¸ªå¤–è®¾å¯¼å…¥ä¸€ä¸ªå¤´æ–‡ä»¶ï¼Œåœ¨å¤–è®¾è¾ƒå¤šçš„æ—¶å€™ï¼Œå¯¼å…¥éƒ¨åˆ†å°†å æœ‰è¾ƒå¤§ç¯‡å¹…ï¼Œä½¿ç¨‹åºçœ‹èµ·æ¥ä¸ç®€æ´ã€‚æˆ–è€…ï¼Œå¦‚æœç³»ç»Ÿæ§åˆ¶çš„ä¸­æ–­æœåŠ¡å‡½æ•°åŒæ ·éœ€è¦è®¿é—®æ‰€æœ‰å¤–è®¾ï¼Œè¿˜éœ€è¦åŒæ ·å¤§ç¯‡å¹…å¯¼å…¥ã€‚&emsp;å› æ­¤ï¼Œå¯ä»¥è®¾ç½®ä¸€ä¸ªincludes.hå¤´æ–‡ä»¶ï¼Œç”¨æ¥å•ç‹¬ç®¡ç†å¤–è®¾å¤´æ–‡ä»¶ã€‚&emsp;æ–°å»ºincludes.hï¼Œå¹¶æ·»åŠ å¦‚ä¸‹ä»£ç ã€‚åœ¨åç»­å­¦ä¹ ä¸­ï¼Œå¤–è®¾çš„å¤´æ–‡ä»¶å°†åœ¨#include &quot;common.h&quot;åç»§ç»­æ·»åŠ ã€‚123456#ifndef INCLUDES_H_#define INCLUDES_H_ #include \"common.h\" #endif /* INCLUDES_H_ */ ä¿®æ”¹mainå‡½æ•°åŒ…å«æ–‡ä»¶&emsp;ä¸Šä¸€æ­¥å®šä¹‰äº†æ€»åŒ…å«æ–‡ä»¶ï¼Œè¿™é‡Œï¼Œå°†mainä¸»å‡½æ•°ä¸­åŸæœ‰çš„#include &quot;DSP28x_Project.h&quot;ä¿®æ”¹ä¸º#include &quot;includes.h&quot;ã€‚&emsp;é‡æ–°ç¼–è¯‘å¹¶è°ƒè¯•å·¥ç¨‹ï¼Œè¯¥å·¥ç¨‹ä»ç„¶å¯ä»¥æ­£å¸¸è¿è¡Œã€‚ åˆ é™¤æµ‹è¯•ä»£ç &emsp;ä¸Šè¿°å®Œæˆçš„F28069Emptyå·¥ç¨‹ä¸­ï¼ŒåŠ å…¥äº†LEDé—ªçƒçš„æµ‹è¯•ä»£ç ã€‚æœ¬èŠ‚ç›®çš„æ˜¯æ–°å»ºä¸€ä¸ªç©ºå·¥ç¨‹ï¼Œå› æ­¤ï¼Œè¿™é‡Œå¯ä»¥å°†æµ‹è¯•ä»£ç åˆ é™¤ã€‚å»ºè®®mainå‡½æ•°è°ƒæ•´ä¸ºå¦‚ä¸‹æ‰€ç¤ºã€‚123456789101112131415161718#include \"includes.h\"uint32 loop_count = 0; void main(void)&#123; InitSysCtrl(); DINT; InitPieCtrl(); IER = 0x0000; IFR = 0x0000; InitPieVectTable(); EINT; // Enable Global interrupt INTM ERTM; // Enable Global realtime interrupt DBGM for(;;) &#123; loop_count++; &#125;&#125; &emsp;å…¶ä¸­åŠ å…¥çš„EINTä¸ERTMä¸ºä¸­æ–­æ§åˆ¶æŒ‡ä»¤ï¼Œåç»­ç« èŠ‚ä¼šæœ‰ä»‹ç»ã€‚&emsp;æ–°å»ºäº†å˜é‡loop_countè®¡æ•°ä¸»å¾ªç¯è¿è¡Œæ¬¡æ•°ï¼Œåœ¨è°ƒè¯•ç¨‹åºæ—¶æœ‰ä¸€äº›ç”¨é€”ã€‚&emsp;ä»¥åçš„å­¦ä¹ ä¸­ï¼Œå°†ä½¿ç”¨è¯¥å·¥ç¨‹ä½œä¸ºæ¨¡æ¿ã€‚&emsp;CCSæ”¯æŒå·¥ç¨‹çš„ç›´æ¥å¤åˆ¶ã€‚åœ¨ä½¿ç”¨çš„è¿‡ç¨‹ä¸­ï¼Œå•å‡»é€‰ä¸­å·¥ç¨‹ã€‚æŒ‰ä½ctrl+Cå¯ä»¥å¤åˆ¶å·¥ç¨‹ï¼Œå†æŒ‰ä½ctrl+Vï¼Œåˆ™å¯ä»¥å®Œæˆå·¥ç¨‹çš„å¤åˆ¶ã€‚&emsp;é‡å‘½ååï¼Œåˆ™å¯ä»¥å¼€å§‹å¼€å‘æ–°çš„é¡¹ç›®ã€‚ ç¨‹åºåœ¨flashä¸­æ‰§è¡Œ&emsp;ç›®å‰ä¸ºæ­¢ï¼Œæ‰€åˆ›å»ºçš„å·¥ç¨‹å‡æ˜¯åœ¨RAMä¸­è¿è¡Œã€‚ç°åœ¨ï¼Œä»…ä»…éœ€è¦å¯¹åŸæœ‰å·¥ç¨‹è¿›è¡Œä¸€äº›ä¿®æ”¹ï¼Œå³å¯å®Œæˆåœ¨flashè¿è¡Œçš„å·¥ç¨‹ã€‚è¿™æ ·ï¼Œå™¨ä»¶å†é‡æ–°ä¸Šç”µåå¯ä»¥ç»§ç»­æ‰§è¡ŒåŸæœ‰ç¨‹åºã€‚&emsp;æ³¨æ„ï¼šå°½ç®¡ä»‹ç»äº†ç¨‹åºåœ¨flashè¿è¡Œçš„æ–¹å¼ï¼Œä½†æ˜¯åœ¨å­¦ä¹ è¿‡ç¨‹ä¸­ï¼Œå¼ºçƒˆå»ºè®®å°½é‡ä½¿ç”¨ramè¿è¡Œæ–¹å¼è¿›è¡Œå®éªŒã€‚åœ¨ramè¿è¡Œç¨‹åºä½¿å¾—å™¨ä»¶ç›¸å¯¹å®‰å…¨ã€‚å¦‚æœä½¿ç”¨flashè¿›è¡Œç¨‹åºçƒ§å½•ï¼Œåˆå­¦è€…ç”±äºæ“ä½œä¸æ­£ç¡®æˆ–è€…ä¸ç†Ÿç»ƒç­‰ï¼Œå¯èƒ½é€ æˆflashé”æ­»ç­‰æƒ…å†µå‘ç”Ÿã€‚&emsp;ä¿®æ”¹æ­¥éª¤å¦‚ä¸‹ã€‚ æ›´æ”¹é“¾æ¥å™¨å‘½ä»¤æ–‡ä»¶ï¼Œå°†28069_RAM_lnk.cmdæ–‡ä»¶è¿›è¡Œåˆ é™¤ï¼ŒåŒæ—¶æ›¿æ¢ä¸ºcontrolSUITE\\device_support\\f2806x\\v136\\F2806x_common\\cmdä¸‹çš„F28069.cmdï¼› åœ¨mainå‡½æ•°#include &quot;includes.h&quot;ä¹‹åï¼Œå¢åŠ å¦‚ä¸‹4æ¡è¯­å¥ï¼› 12345// These are defined by the linker (see F2808.cmd)extern Uint16 RamfuncsLoadStart;extern Uint16 RamfuncsLoadEnd;extern Uint16 RamfuncsRunStart;extern Uint16 RamfuncsLoadSize; åœ¨mainå‡½æ•°InitPieVectTable()åï¼Œå¢åŠ å¦‚ä¸‹2æ¡è¯­å¥ã€‚ 12memcpy(&amp;RamfuncsRunStart, &amp;RamfuncsLoadStart, (Uint32)&amp;RamfuncsLoadSize);InitFlash(); æ­¤æ—¶ï¼Œç¨‹åºå†è¿›è¡Œçƒ§å½•ï¼Œå¯ä»¥çœ‹åˆ°æ‰‡åŒºæ“¦é™¤çš„è¿‡ç¨‹ã€‚","categories":[{"name":"åµŒå…¥å¼","slug":"åµŒå…¥å¼","permalink":"http://jiaodi.tech/categories/åµŒå…¥å¼/"}],"tags":[{"name":"C2000","slug":"C2000","permalink":"http://jiaodi.tech/tags/C2000/"},{"name":"DSP","slug":"DSP","permalink":"http://jiaodi.tech/tags/DSP/"},{"name":"CCS","slug":"CCS","permalink":"http://jiaodi.tech/tags/CCS/"}]},{"title":"å®‰è£…CCSä¸controlSUITE","slug":"å®‰è£…CCSä¸controlSUITE","date":"2017-03-06T02:11:59.000Z","updated":"2017-03-06T12:47:53.423Z","comments":true,"path":"2017/03/06/å®‰è£…CCSä¸controlSUITE/","link":"","permalink":"http://jiaodi.tech/2017/03/06/å®‰è£…CCSä¸controlSUITE/","excerpt":"&emsp;åœ¨å­¦ä¹ TI C2000ç³»åˆ—DSPä¹‹å‰ï¼Œéœ€è¦é¦–å…ˆå®‰è£…å¥½å¼€å‘ç¯å¢ƒCCSä¸å¯¹åº”è½¯ä»¶å¥—ä»¶controlSUITEã€‚","text":"&emsp;åœ¨å­¦ä¹ TI C2000ç³»åˆ—DSPä¹‹å‰ï¼Œéœ€è¦é¦–å…ˆå®‰è£…å¥½å¼€å‘ç¯å¢ƒCCSä¸å¯¹åº”è½¯ä»¶å¥—ä»¶controlSUITEã€‚ CCSçš„å®‰è£…&emsp;Code Composer Studioâ„¢ (CCStudio) æ˜¯ç”¨äºå¾·å·ä»ªå™¨ (TI) åµŒå…¥å¼å¤„ç†å™¨ç³»åˆ—çš„é›†æˆå¼€å‘ç¯å¢ƒ (IDE)ã€‚ CCStudio åŒ…å«ä¸€æ•´å¥—ç”¨äºå¼€å‘å’Œè°ƒè¯•åµŒå…¥å¼åº”ç”¨çš„å·¥å…·ã€‚ å®ƒåŒ…å«é€‚ç”¨äºæ¯ä¸ª TI å™¨ä»¶ç³»åˆ—çš„ç¼–è¯‘å™¨ã€æºç ç¼–è¾‘å™¨ã€é¡¹ç›®æ„å»ºç¯å¢ƒã€è°ƒè¯•å™¨ã€æè¿°å™¨ã€ä»¿çœŸå™¨ã€å®æ—¶æ“ä½œç³»ç»Ÿä»¥åŠå¤šç§å…¶ä»–åŠŸèƒ½ã€‚ ç›´è§‚çš„ IDE æä¾›äº†å•ä¸ªç”¨æˆ·ç•Œé¢ï¼Œå¯å¸®åŠ©ç”¨æˆ·å®Œæˆåº”ç”¨å¼€å‘æµç¨‹çš„æ¯ä¸ªæ­¥éª¤ã€‚å€ŸåŠ©äºç²¾å¯†çš„é«˜æ•ˆå·¥å…·ï¼Œç”¨æˆ·èƒ½å¤Ÿåˆ©ç”¨ç†Ÿæ‚‰çš„å·¥å…·å’Œç•Œé¢å¿«é€Ÿä¸Šæ‰‹å¹¶å°†åŠŸèƒ½æ·»åŠ è‡³ä»–ä»¬çš„åº”ç”¨ã€‚&emsp;Code Composer Studio ä»¥ Eclipse å¼€æºè½¯ä»¶æ¡†æ¶ä¸ºåŸºç¡€ã€‚&emsp;Code Composer Studio å¯åœ¨ Windows å’Œ Linux PC ä¸Šè¿è¡Œã€‚ å¹¶éæ‰€æœ‰åŠŸèƒ½æˆ–å™¨ä»¶éƒ½ä¸ Linux å…¼å®¹ï¼Œè¯¦ç»†ä¿¡æ¯è¯·å‚è§ Linux ä¸»æœºæ”¯æŒã€‚ CCSé›†æˆå¼€å‘ç¯å¢ƒçš„ä¸‹è½½&emsp;CCSå¯ä»¥åœ¨å¾·å·ä»ªå™¨å®˜ç½‘ï¼ˆwww.ti.com.cnï¼‰ä¸‹è½½ã€‚å¯å‚è€ƒTI ç½‘é¡µä¸Šçš„WIKI ä¸­æœ‰å…³CCStudio å®‰è£…çš„æè¿°ã€‚ä¸‹è½½ç½‘å€&emsp;ç™»é™†TIå®˜ç½‘åï¼Œåœ¨æœç´¢æ è¾“å…¥code composer studioæˆ–CCSå¹¶ç‚¹å‡»æœç´¢ï¼Œå³å¯è·å¾—ç›¸å…³èµ„æ–™ã€‚&emsp;ä¸‹è½½CCSéœ€è¦ä½¿ç”¨TIè´¦æˆ·ç™»å½•ã€‚åˆ›å»ºTIè´¦æˆ·å¯ä»¥ä¸‹è½½TIæ›´å¤šçš„è½¯ä»¶èµ„æ–™å’Œä½¿ç”¨ä¸€äº›åœ¨çº¿ä»¿çœŸå·¥å…·ç­‰ã€‚å¦‚æœä½¿ç”¨æ•™è‚²é‚®ç®±æˆ–ä¼ä¸šé‚®ç®±ç”³è¯·ï¼Œè¿˜å¯ä»¥è¿›è¡Œç”³è¯·æ ·ç‰‡ç­‰ã€‚ CCSé›†æˆå¼€å‘ç¯å¢ƒçš„å®‰è£…&emsp;æ³¨æ„ï¼š 1.å®‰è£…CCSçš„è¿‡ç¨‹ä¸­ï¼Œè¯·åŠ¡å¿…ä¿è¯è®¡ç®—æœºçš„æ€æ¯’è½¯ä»¶å’Œé˜²ç«å¢™è½¯ä»¶å·²ç»å…³é—­ï¼Œå¦åˆ™åœ¨å®‰è£…è¿‡ç¨‹ä¸­å¾ˆå¯èƒ½å¤±è´¥æˆ–è€…éƒ¨åˆ†ç»„ä»¶æ— æ³•å®‰è£…ï¼› 2.CCSå®‰è£…è·¯å¾„ä¸åç»­çš„å·¥ä½œç©ºé—´æ‰€åœ¨è·¯å¾„ä¸¥ç¦å‡ºç°ä¸­æ–‡å­—ç¬¦ï¼› 3.å¯¹äºwin 8ç”¨æˆ·ï¼Œè¯·æ³¨æ„ç³»ç»Ÿç”¨æˆ·åå¿…é¡»æ˜¯è‹±æ–‡å­—ç¬¦ï¼Œå‡ºç°ä¸­æ–‡å¾ˆæœ‰å¯èƒ½å®‰è£…å¤±è´¥æ— æ³•ä½¿ç”¨ã€‚&emsp;ç»å®éªŒï¼ŒCCSå¯åœ¨win 7å’Œwin 8å¹³å°è¿è¡Œï¼Œå¯¹32ä½å’Œ64ä½ç³»ç»Ÿå…¼å®¹ã€‚å»ºè®®è¯»è€…ä½¿ç”¨win 7æˆ–è€…win 8å¹³å°è®¡ç®—æœºã€‚ è¿è¡Œä¸‹è½½çš„å®‰è£…ç¨‹åºccs_setup.exeï¼Œå½“è¿›å…¥å®‰è£…ç›®å½•ç•Œé¢æ—¶ï¼Œå¯ä»¥ç‚¹å‡»Browseè¿›è¡Œå®‰è£…è·¯å¾„çš„é€‰æ‹©ï¼Œä½†æ¨èç›´æ¥å®‰è£…åœ¨é»˜è®¤çš„Cç›˜ä¸­ã€‚ å½“è¿è¡Œåˆ°ä¸‹å›¾å¤„æ—¶ï¼Œé€‰æ‹©Customé€‰é¡¹ï¼Œè¿›å…¥æ‰‹åŠ¨é€‰æ‹©å®‰è£…é€šé“ã€‚å¦‚æœä¸‹è½½çš„ä¸ºåœ¨çº¿å®‰è£…åŒ…ï¼Œéœ€è¦åœ¨å®‰è£…è¿‡ç¨‹ä¸­ä¿è¯è”ç½‘ã€‚ å•å‡»Nextå¾—åˆ°å¦‚ä¸‹å›¾æ‰€ç¤ºçš„çª—å£ï¼Œä¸ºäº†å®‰è£…å¿«æ·ï¼Œåœ¨æ­¤åªé€‰æ‹©æ”¯æŒC28x 32-bit Real-time MCUSçš„é€‰é¡¹ã€‚å•å‡»Nextï¼Œä¿æŒé»˜è®¤é…ç½®ï¼Œç»§ç»­å®‰è£…ã€‚CCSç›®å‰ä¸æ”¯æŒåœ¨å®‰è£…å®Œæ¯•åå¢åŠ å™¨ä»¶æ”¯æŒçš„å®‰è£…ï¼Œæ•…å¦‚æœ‰å¯èƒ½ï¼Œå»ºè®®åŒæ—¶å®‰è£…å¯èƒ½ç”¨åˆ°çš„å™¨ä»¶ï¼Œä»¥é¿å…é‡è£…çš„éº»çƒ¦ã€‚ å®‰è£…è¿‡ç¨‹ä¸­å‡ºç°çš„å¯¹è¯æ¡†å…¨éƒ¨é€‰æ‹©â€œå®‰è£…â€é€‰é¡¹ã€‚å®‰è£…å®Œæ¯•åï¼Œå‡ºç°ä»¥ä¸‹ç•Œé¢ã€‚&emsp;å•å‡»Finishï¼Œå¾€å¾€è¦æ±‚å…ˆé‡å¯Windowsã€‚è‡³æ­¤ï¼ŒCCSå®‰è£…å®Œæ¯•ã€‚&emsp;ä¹‹åå°†è¿è¡ŒCCSï¼Œå¼¹å‡ºå¦‚ä¸‹å›¾æ‰€ç¤ºçª—å£ï¼Œå•å‡»Browseï¼Œå°†å·¥ä½œåŒºé—´é“¾æ¥åˆ°æ‰€å»ºæ–‡ä»¶å¤¹ã€‚CCSé¦–å…ˆè¦æ±‚çš„æ˜¯å®šä¹‰ä¸€ä¸ªå·¥ä½œåŒºï¼Œå³ç”¨äºä¿å­˜å¼€å‘è¿‡ç¨‹ä¸­ç”¨åˆ°çš„æ‰€æœ‰å…ƒç´ ï¼ˆé¡¹ç›®å’ŒæŒ‡å‘é¡¹ç›®çš„é“¾æ¥ï¼Œå¯èƒ½è¿˜æœ‰æºä»£ç ï¼‰çš„ç›®å½•ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œä¼šåœ¨C:\\Users\\&lt;ç”¨æˆ·&gt;\\Documents æˆ–C:\\Documents and Settings\\&lt;ç”¨æˆ·&gt;\\My Documentsç›®å½•ä¸‹åˆ›å»ºå·¥ä½œåŒºï¼Œä½†å¯ä»¥ä»»æ„é€‰æ‹©å…¶ä½ç½®ã€‚æ¯æ¬¡æ‰§è¡ŒCCSéƒ½ä¼šè¦æ±‚å·¥ä½œåŒºç›®å½•ã€‚å¦‚æœè®¡åˆ’å¯¹æ‰€æœ‰é¡¹ç›®ä½¿ç”¨ä¸€ä¸ªç›®å½•ï¼Œåªéœ€é€‰ä¸­â€œUse this as the default and do not ask againï¼ˆé»˜è®¤ä½¿ç”¨æ­¤ç›®å½•ä¸”ä¸å†è¯¢é—®ï¼‰â€é€‰é¡¹ã€‚ä»¥åéšæ—¶å¯ä»¥åœ¨CCSä¸­æ›´æ”¹å·¥ä½œåŒºã€‚&emsp;å®éªŒä¸­ï¼Œä½¿ç”¨äº†å¦‚å›¾çš„æ–‡ä»¶å¤¹ä½œä¸ºå·¥ä½œç©ºé—´ã€‚å·¥ä½œæ–‡ä»¶å¯èƒ½è¾ƒå¤šï¼Œå¯ä»¥åœ¨Dæˆ–Eç›˜ä¸­å•ç‹¬å»ºç«‹æ–‡ä»¶å¤¹å¹¶ä»¥èŠ¯ç‰‡çš„åå­—å»ºç«‹å­ç›®å½•ã€‚å¦‚ï¼šD:\\ti\\tms320f28069ã€‚ å•å‡»OKï¼Œç¬¬ä¸€æ¬¡è¿è¡ŒCCSéœ€è¿›è¡Œè½¯ä»¶è®¸å¯çš„é€‰æ‹©ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºã€‚åœ¨æ­¤ï¼Œé€‰æ‹©FREE LICENSEé€‰é¡¹ï¼Œåœ¨è¯¥é€‰é¡¹ä¸‹ï¼Œä½¿ç”¨XDS100ä»¿çœŸå™¨å°†ä¸é™åˆ¶ä»£ç å®¹é‡ä½¿ç”¨ã€‚è€Œæˆ‘ä»¬å­¦ä¹ C2000ç³»åˆ—DSPå³ä½¿ç”¨è¯¥ä»¿çœŸå™¨ã€‚è‹¥æ‚¨æœ‰è½¯ä»¶è®¸å¯ï¼Œå¯ä»¥å‚è€ƒé“¾æ¥è¿›è¡Œè½¯ä»¶è®¸å¯çš„è®¤è¯. å•å‡»Finishå³å¯è¿›å…¥CCSv5 è½¯ä»¶å¼€å‘é›†æˆç¯å¢ƒï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºã€‚ controlSUITEçš„å®‰è£…&emsp;controlSUITEæ˜¯å¾·å·ä»ªå™¨å…¬å¸ä¸ºC2000ç³»åˆ—å¾®å¤„ç†å™¨è®¾è®¡çš„ä¸€æ¬¾é›†è½¯ä»¶ã€ç¡¬ä»¶ä¸æŠ€æœ¯èµ„æ–™ä¸€ä½“çš„å¤åˆå¥—ä»¶ã€‚å¥—ä»¶ä¸­æä¾›äº†C2000å…¨å¥—å™¨ä»¶çš„ç¤ºä¾‹ç¨‹åºï¼Œè¿™å¯¹å­¦ä¹ è¯¥ç³»åˆ—å™¨ä»¶éå¸¸æœ‰ç”¨ã€‚ç¤ºä¾‹ç¨‹åºå±•ç¤ºäº†ç»å¤§å¤šæ•°å¤–è®¾çš„å¸¸ç”¨ä½¿ç”¨æ–¹æ³•å’ŒæŠ€å·§ï¼Œå€ŸåŠ©ç¤ºä¾‹ç¨‹åºï¼Œæˆ‘ä»¬å¯ä»¥æ›´å¿«å…¥æ‰‹C2000å™¨ä»¶çš„å­¦ä¹ ï¼Œæˆ–è€…ç›´æ¥å€ŸåŠ©å…¶åº•å±‚é©±åŠ¨è¿›è¡Œå¼€å‘ã€‚&emsp;controlSUITEä¸­åŒ…å«äº†å®Œå–„çš„è®¾å¤‡åˆå§‹åŒ–å‡½æ•°å’Œç»å¤§å¤šæ•°å¤–è®¾çš„åº•å±‚é©±åŠ¨å‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥å€ŸåŠ©å…¶æ›´å¥½åœ°å…¥æ‰‹å­¦ä¹ C2000è®¾å¤‡ã€‚å› æ­¤ï¼Œæœ¬èŠ‚æˆ‘ä»¬å°†ä»‹ç»controlSUITEçš„å®‰è£…ä¸ä½¿ç”¨æ–¹æ³•ã€‚ controlSUITEçš„ä¸‹è½½&emsp;controlSUITEå¯ä»¥åœ¨å¾·å·ä»ªå™¨å®˜ç½‘ï¼ˆwww.ti.com.cnï¼‰ä¸‹è½½ã€‚&emsp;ç™»é™†TIå®˜ç½‘åï¼Œåœ¨æœç´¢æ è¾“å…¥controlSUITEå¹¶ç‚¹å‡»æœç´¢ï¼Œå³å¯è·å¾—ç›¸å…³èµ„æ–™ã€‚&emsp;ä¸‹è½½controlSUITEåŒæ ·éœ€è¦ä½¿ç”¨TIè´¦æˆ·ç™»å½•ã€‚ controlSUITEçš„å®‰è£… å°†å‹ç¼©åŒ…è§£å‹ï¼Œè¿è¡Œä¸‹è½½çš„å®‰è£…ç¨‹åºcontrolSUITE.exeã€‚è¿è¡Œåˆ°ä¸‹å›¾æ­¥éª¤æ—¶ï¼Œå¯ä»¥è‡ªå®šä¹‰é€‰æ‹©å®‰è£…åœ°å€ã€‚&emsp;ç¤ºä¾‹ä¸­ï¼ŒcontrolSUITEå®‰è£…äºDç›˜ä¸‹tiæ–‡ä»¶å¤¹ä¸‹ã€‚è¯¥åœ°å€éœ€è¦è®°ä½ï¼Œåç»­éœ€è¦ä½¿ç”¨è¯¥åœ°å€å°†controlSUITEå¯¼å…¥åˆ°CCSä¸­ã€‚ å®‰è£…å®Œæˆåï¼Œå¯ä»¥æ‰“å¼€controlSUITEå¥—ä»¶æ‰€åœ¨å®‰è£…ç›®å½•ä¸‹çš„controlSUITE.exeï¼Œå³å¯æ‰“å¼€ä½¿ç”¨ã€‚ controlSUITEä¸­åŒ…å«äº†ä¼—å¤šçš„æŠ€æœ¯èµ„æ–™ï¼Œä»¥Piccolo F2806xä¸ºä¾‹ï¼Œå…¶ä¸­åŒ…å«äº†æŠ€æœ¯æ‰‹å†Œã€ç”¨æˆ·æŒ‡å—å’Œç¤ºä¾‹ç¨‹åºç­‰å¤šç§èµ„æ–™ã€‚ å°†controlSUITEæ·»åŠ è¿›CCS&emsp;controlSUITEå¯ä»¥é€šè¿‡CCSçš„èµ„æºç®¡ç†å™¨è¿›è¡Œç®¡ç†ã€‚é€šè¿‡CCSç®¡ç†ï¼Œå¯ä»¥æ›´ä¾¿æ·åœ°ä½¿ç”¨controlSUITEçš„èµ„æºï¼Œä¾‹å¦‚å¯¼å…¥å…¶ä¸­çš„ç¤ºä¾‹ç¨‹åºè¿›è¡Œå­¦ä¹ ç­‰ã€‚&emsp;äº‹å®ä¸Šï¼ŒTIé’ˆå¯¹ä¸åŒå™¨ä»¶å‡æœ‰ç±»ä¼¼ç»„ä»¶åŒ…ã€‚ä¾‹å¦‚msp430çš„430WAREå’ŒTIVAç³»åˆ—ARMçš„TIVAWAREï¼Œä¹Ÿéƒ½å¯ä»¥é€šè¿‡å¦‚ä¸‹æ–¹æ³•å¯¼å…¥åˆ°CCSä¸­è¿›è¡Œç®¡ç†ã€‚&emsp;æœ¬èŠ‚å°†ä»‹ç»å°†controlSUITEå¯¼å…¥CCSçš„æ–¹æ³•ã€‚ æ‰“å¼€CCSï¼Œé€‰æ‹©èœå•æ ä¸­View-&gt;Resource Exploreï¼Œå³å¯æ‰“å¼€TIèµ„æºç®¡ç†å™¨ã€‚ åœ¨èµ„æºç®¡ç†å™¨å·¦ä¸Šè§’packageså³ä¾§ï¼Œæœ‰Add additional packagesæŒ‰é’®ã€‚ å•å‡»æŒ‰é’®ï¼Œå‡ºç°Package Configurationç•Œé¢ã€‚é€‰æ‹©AddæŒ‰é’®ï¼Œåœ¨æµè§ˆæ–‡ä»¶å¤¹ä¸­é€‰æ‹©controlSUITEæ‰€åœ¨çš„ç›®å½•ã€‚ç‚¹å‡»ç¡®å®šã€‚ ä¹‹åå›åˆ°Package Configurationç•Œé¢ï¼Œç‚¹å‡»OKã€‚CCSå°†å®ŒæˆcontrolSUITEçš„å¯¼å…¥ã€‚ åœ¨å®Œæˆå¯¼å…¥åï¼Œåœ¨packagesæ å¯ä»¥é€‰æ‹©controlSUITEã€‚æ­¤æ—¶å¯ä»¥é€šè¿‡CCSå®Œæˆå¯¹controlSUITEèµ„æºçš„ä½¿ç”¨ã€‚","categories":[{"name":"åµŒå…¥å¼","slug":"åµŒå…¥å¼","permalink":"http://jiaodi.tech/categories/åµŒå…¥å¼/"}],"tags":[{"name":"C2000","slug":"C2000","permalink":"http://jiaodi.tech/tags/C2000/"},{"name":"DSP","slug":"DSP","permalink":"http://jiaodi.tech/tags/DSP/"},{"name":"CCS","slug":"CCS","permalink":"http://jiaodi.tech/tags/CCS/"}]}]}